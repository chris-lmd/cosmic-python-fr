{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Patterns d'Architecture en Python","text":"<p>Guide francophone des patterns d'architecture logicielle en Python</p>"},{"location":"#de-quoi-parle-ce-guide","title":"De quoi parle ce guide ?","text":"<p>Ce guide vous accompagne dans la construction d'une application Python bien architectur\u00e9e, en introduisant progressivement des patterns \u00e9prouv\u00e9s issus du Domain-Driven Design (DDD) et de l'architecture \u00e9v\u00e9nementielle.</p> <p>Le fil rouge est un syst\u00e8me d'allocation de stock : un probl\u00e8me m\u00e9tier suffisamment r\u00e9aliste pour illustrer les enjeux, mais suffisamment simple pour se concentrer sur l'architecture.</p>"},{"location":"#positionnement-de-ce-guide","title":"Positionnement de ce guide","text":"<p>Ce guide adopte une approche combinant Domain-Driven Design (DDD), architecture hexagonale (Ports &amp; Adapters) et architecture \u00e9v\u00e9nementielle. Si vous avez d\u00e9j\u00e0 entendu parler de la Clean Architecture de Robert C. Martin, vous retrouverez ici les m\u00eames principes fondamentaux \u2014 isolation du domaine, inversion des d\u00e9pendances, d\u00e9couplage de l'infrastructure \u2014 mais avec des patterns et un vocabulaire mieux adapt\u00e9s \u00e0 Python.</p> <p>L\u00e0 o\u00f9 la Clean Architecture propose des Use Cases sous forme de classes et un d\u00e9coupage en 4 couches formelles (pens\u00e9 pour Java/C#), ce guide privil\u00e9gie des handlers l\u00e9gers (de simples fonctions), des patterns \u00e9prouv\u00e9s comme le Repository et le Unit of Work, et une architecture \u00e9v\u00e9nementielle compl\u00e8te (Events, Commands, Message Bus, CQRS) qui permet au syst\u00e8me de grandir progressivement.</p> Aspect Clean Architecture (Uncle Bob) Ce guide (DDD + Hexagonal) Orchestration Use Case (une classe avec <code>execute()</code>) Handler (une simple fonction) Formatage de la sortie Presenter d\u00e9di\u00e9 Retour direct, l'entrypoint formate Couches 4 couches strictes et formelles Ajout\u00e9es progressivement selon le besoin Architecture \u00e9v\u00e9nementielle Peu d\u00e9taill\u00e9e Centrale (Events, Commands, Message Bus, CQRS) Mod\u00e9lisation du domaine Peu d\u00e9taill\u00e9e Riche (Aggregates, Value Objects, Domain Events) Persistance Gateways (concept g\u00e9n\u00e9rique) Repository + Unit of Work (patterns \u00e9prouv\u00e9s) <p>En r\u00e9sum\u00e9 : m\u00eame philosophie, outillage diff\u00e9rent, taill\u00e9 pour Python.</p>"},{"location":"#pourquoi-ces-patterns","title":"Pourquoi ces patterns ?","text":"<p>La plupart des applications commencent simples, puis deviennent difficiles \u00e0 maintenir au fil du temps. La logique m\u00e9tier se disperse entre les routes de l'API, les requ\u00eates SQL, et les scripts utilitaires. Les tests deviennent fragiles car coupl\u00e9s \u00e0 la base de donn\u00e9es.</p> <p>Les patterns pr\u00e9sent\u00e9s ici r\u00e9solvent ces probl\u00e8mes en :</p> <ul> <li>Isolant la logique m\u00e9tier dans un mod\u00e8le de domaine pur (sans d\u00e9pendance \u00e0 la BDD ou au framework web)</li> <li>D\u00e9couplant les couches gr\u00e2ce \u00e0 des abstractions (Repository, Unit of Work)</li> <li>Rendant le syst\u00e8me extensible gr\u00e2ce \u00e0 une architecture \u00e9v\u00e9nementielle (Events, Message Bus, CQRS)</li> </ul>"},{"location":"#organisation-du-guide","title":"Organisation du guide","text":""},{"location":"#partie-1-construire-une-architecture-pour-le-domain-modeling","title":"Partie 1 \u2014 Construire une architecture pour le Domain Modeling","text":"Chapitre Pattern Probl\u00e8me r\u00e9solu 1. Le mod\u00e8le de domaine Domain Model O\u00f9 mettre la logique m\u00e9tier ? 2. Le pattern Repository Repository Comment d\u00e9coupler le domaine de la BDD ? 3. Couplage et abstractions Dependency Inversion Pourquoi et comment introduire des abstractions ? 4. La Service Layer Service Layer O\u00f9 placer l'orchestration ? 5. TDD \u00e0 haute et basse vitesse Testing Pyramid Comment tester efficacement ? 6. Le pattern Unit of Work Unit of Work Comment g\u00e9rer les transactions ? 7. Agr\u00e9gats et fronti\u00e8res Aggregate Comment garantir la coh\u00e9rence ?"},{"location":"#partie-2-architecture-evenementielle","title":"Partie 2 \u2014 Architecture \u00e9v\u00e9nementielle","text":"Chapitre Pattern Probl\u00e8me r\u00e9solu 8. Events et le Message Bus Domain Events Comment r\u00e9agir aux changements du domaine ? 9. Aller plus loin avec le Message Bus Message Bus Comment le bus devient le coeur de l'architecture ? 10. Commands Command Comment distinguer intentions et faits ? 11. Events externes Integration Events Comment communiquer entre services ? 12. CQRS CQRS Comment optimiser lectures et \u00e9critures s\u00e9par\u00e9ment ? 13. Injection de d\u00e9pendances Dependency Injection Comment assembler les composants proprement ?"},{"location":"#epilogue","title":"\u00c9pilogue","text":"\u00c9pilogue -- Pi\u00e8ges, compromis et conseils pragmatiques Quand utiliser (et ne pas utiliser) ces patterns"},{"location":"#le-domaine-metier-lallocation-de-stock","title":"Le domaine m\u00e9tier : l'allocation de stock","text":"<p>Imaginons une entreprise de e-commerce qui doit g\u00e9rer son stock. Quand un client passe commande, le syst\u00e8me doit allouer les produits command\u00e9s \u00e0 des lots de stock (batches).</p> <p>Les r\u00e8gles m\u00e9tier :</p> <ul> <li>Chaque lot a une r\u00e9f\u00e9rence, un SKU (identifiant produit), une quantit\u00e9, et une ETA (date d'arriv\u00e9e) optionnelle</li> <li>Les lots en stock (sans ETA) sont pr\u00e9f\u00e9r\u00e9s aux lots en transit</li> <li>Parmi les lots en transit, on choisit celui avec l'ETA la plus proche</li> <li>On ne peut pas allouer plus que la quantit\u00e9 disponible</li> </ul> <pre><code>@dataclass(unsafe_hash=True)\nclass LigneDeCommande:\n    \"\"\"Value Object : une ligne de commande.\"\"\"\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n\nclass Lot:\n    \"\"\"Entity : un lot de stock.\"\"\"\n    def __init__(self, r\u00e9f, sku, quantit\u00e9, eta=None):\n        self.r\u00e9f\u00e9rence = r\u00e9f\n        self.sku = sku\n        self.eta = eta\n        self._quantit\u00e9_achet\u00e9e = quantit\u00e9\n        self._allocations: set[LigneDeCommande] = set()\n</code></pre>"},{"location":"#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li>Python 3.12+</li> <li>Notions de base en programmation orient\u00e9e objet</li> <li>Familiarit\u00e9 avec pytest</li> <li>Curiosit\u00e9 pour l'architecture logicielle</li> </ul>"},{"location":"#credits","title":"Cr\u00e9dits","text":"<p>Ce guide s'inspire des concepts pr\u00e9sent\u00e9s dans Architecture Patterns with Python de Harry Percival et Bob Gregory (disponible sur cosmicpython.com), ainsi que des travaux fondateurs d'Eric Evans (Domain-Driven Design) et de Martin Fowler (Patterns of Enterprise Application Architecture).</p> <p>Ce guide a \u00e9t\u00e9 r\u00e9dig\u00e9 avec l'assistance de l'IA g\u00e9n\u00e9rative Claude (Anthropic). Le contenu, les explications et les exemples de code sont originaux mais ont \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9s et structur\u00e9s \u00e0 l'aide de cet outil.</p>"},{"location":"#licence","title":"Licence","text":"<p>Ce contenu est mis \u00e0 disposition sous licence Creative Commons Attribution-NonCommercial-ShareAlike 4.0.</p>"},{"location":"chapitre_00_mise_en_route/","title":"Chapitre 0 -- Mise en route","text":""},{"location":"chapitre_00_mise_en_route/#pre-requis","title":"Pr\u00e9-requis","text":"<p>Avant de commencer, assurez-vous d'avoir install\u00e9 :</p> Outil Version V\u00e9rification Python 3.12+ <code>python --version</code> git r\u00e9cent <code>git --version</code> uv (recommand\u00e9) ou pip r\u00e9cent <code>uv --version</code> ou <code>pip --version</code>"},{"location":"chapitre_00_mise_en_route/#installation","title":"Installation","text":"<pre><code># 1. Cloner le d\u00e9p\u00f4t\ngit clone &lt;url-du-d\u00e9p\u00f4t&gt; cosmic-python-fr\ncd cosmic-python-fr\n\n# 2. Installer les d\u00e9pendances\n# Option A : avec uv (recommand\u00e9)\nuv sync\n\n# Option B : avec pip\npip install -e \".[dev]\"\n</code></pre>"},{"location":"chapitre_00_mise_en_route/#verification","title":"V\u00e9rification","text":"<p>Lancez la suite de tests pour v\u00e9rifier que tout fonctionne :</p> <pre><code>pytest\n</code></pre> <p>Vous devriez voir 33 tests qui passent. Les tests sont organis\u00e9s avec trois marqueurs :</p> Marqueur Description Commande <code>unit</code> Tests unitaires, rapides, sans I/O <code>pytest -m unit</code> <code>integration</code> Tests d'int\u00e9gration (base de donn\u00e9es) <code>pytest -m integration</code> <code>e2e</code> Tests end-to-end (API compl\u00e8te) <code>pytest -m e2e</code>"},{"location":"chapitre_00_mise_en_route/#documentation-locale","title":"Documentation locale","text":"<p>Pour consulter ce guide en local avec un rendu complet :</p> <pre><code># Installer les d\u00e9pendances de documentation\npip install -e \".[docs]\"\n\n# Lancer le serveur de documentation\nmkdocs serve\n</code></pre> <p>Puis ouvrez http://127.0.0.1:8000 dans votre navigateur.</p>"},{"location":"chapitre_00_mise_en_route/#structure-du-projet","title":"Structure du projet","text":"<pre><code>cosmic-python-fr/\n\u251c\u2500\u2500 src/allocation/\n\u2502   \u251c\u2500\u2500 adapters/            # Couche infrastructure\n\u2502   \u2502   \u251c\u2500\u2500 orm.py           # Mapping SQLAlchemy\n\u2502   \u2502   \u251c\u2500\u2500 repository.py    # Impl\u00e9mentation du Repository\n\u2502   \u2502   \u2514\u2500\u2500 notifications.py # Adapter de notifications\n\u2502   \u251c\u2500\u2500 domain/              # Couche domaine (code pur)\n\u2502   \u2502   \u251c\u2500\u2500 model.py         # Entit\u00e9s, Value Objects, Agr\u00e9gats\n\u2502   \u2502   \u251c\u2500\u2500 commands.py      # Messages de type Command\n\u2502   \u2502   \u2514\u2500\u2500 events.py        # Messages de type Event\n\u2502   \u251c\u2500\u2500 entrypoints/         # Points d'entr\u00e9e\n\u2502   \u2502   \u2514\u2500\u2500 flask_app.py     # API REST Flask\n\u2502   \u251c\u2500\u2500 service_layer/       # Couche service\n\u2502   \u2502   \u251c\u2500\u2500 handlers.py      # Handlers (orchestration)\n\u2502   \u2502   \u251c\u2500\u2500 messagebus.py    # Message Bus\n\u2502   \u2502   \u251c\u2500\u2500 unit_of_work.py  # Unit of Work\n\u2502   \u2502   \u2514\u2500\u2500 bootstrap.py     # Composition Root\n\u2502   \u2514\u2500\u2500 views/               # Lecture (CQRS)\n\u2502       \u2514\u2500\u2500 views.py         # Requ\u00eates en lecture\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/                # Tests unitaires (fakes, pas d'I/O)\n\u2502   \u251c\u2500\u2500 integration/         # Tests d'int\u00e9gration (BDD r\u00e9elle)\n\u2502   \u2514\u2500\u2500 e2e/                 # Tests end-to-end (API HTTP)\n\u251c\u2500\u2500 docs/                    # Ce guide (MkDocs)\n\u2514\u2500\u2500 pyproject.toml           # Configuration du projet\n</code></pre>"},{"location":"chapitre_00_mise_en_route/#comment-lire-ce-guide","title":"Comment lire ce guide","text":"<p>Le guide est organis\u00e9 en deux parties qui se lisent dans l'ordre :</p> <p>Partie 1 (Chapitres 1-7) introduit les fondations : mod\u00e8le de domaine, Repository, Service Layer, Unit of Work, et Agr\u00e9gats. Chaque chapitre ajoute un pattern et montre comment il r\u00e9sout un probl\u00e8me concret.</p> <p>Partie 2 (Chapitres 8-13) construit l'architecture \u00e9v\u00e9nementielle : Domain Events, Message Bus, Commands, events externes, CQRS et injection de d\u00e9pendances.</p> <p>Conseils de lecture</p> <ul> <li>Lisez dans l'ordre. Chaque chapitre s'appuie sur le pr\u00e9c\u00e9dent.</li> <li>Regardez le code. Les fichiers dans <code>src/allocation/</code> correspondent exactement \u00e0 l'\u00e9tat final d\u00e9crit dans le guide.</li> <li>Lancez les tests. Apr\u00e8s chaque chapitre, identifiez les tests correspondants dans <code>tests/</code> et ex\u00e9cutez-les pour v\u00e9rifier votre compr\u00e9hension.</li> <li>Chaque chapitre commence par un tableau \"Avant/Apr\u00e8s\" qui r\u00e9sume la transformation d'un coup d'\u0153il.</li> </ul>"},{"location":"epilogue/","title":"\u00c9pilogue -- Pi\u00e8ges, compromis et conseils pragmatiques","text":"<p>Vous avez parcouru 13 chapitres. Vous connaissez maintenant le Domain Model, le Repository, la Service Layer, le Unit of Work, les Agr\u00e9gats, les Events, le Message Bus, les Commands, le CQRS et l'Injection de d\u00e9pendances. C'est un arsenal puissant.</p> <p>Mais ces patterns ne sont pas gratuits. Ils ajoutent de la complexit\u00e9, de l'indirection et des abstractions. Ce chapitre de cl\u00f4ture est l\u00e0 pour prendre du recul et poser les questions que l'enthousiasme du d\u00e9but fait parfois oublier.</p>"},{"location":"epilogue/#larchitecture-complete-en-un-coup-dil","title":"L'architecture compl\u00e8te en un coup d'\u0153il","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                          BOOTSTRAP                                   \u2502\n\u2502               (Composition Root \u2014 bootstrap.py)                      \u2502\n\u2502                                                                      \u2502\n\u2502  Cr\u00e9e :  UoW, Notifications, Publisher                               \u2502\n\u2502  Configure : routing commands/events \u2192 handlers                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502              ENTRYPOINTS                 \u2502\n        \u2502   Flask API  \u2502  Redis Consumer  \u2502  CLI   \u2502\n        \u2502   (thin adapters \u2014 traduisent le         \u2502\n        \u2502    protocole externe en commands)         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502 Command\n                           \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502              MESSAGE BUS                  \u2502\n        \u2502                                          \u2502\n        \u2502  queue = [command]                       \u2502\n        \u2502  while queue:                            \u2502\n        \u2502      dispatch \u2192 handler                  \u2502\n        \u2502      collect_new_events \u2192 queue           \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502                     \u2502\n        Command Handlers       Event Handlers\n               \u2502                     \u2502\n               \u25bc                     \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502  UNIT OF WORK \u2502     \u2502  Notifications   \u2502\n        \u2502  (transaction)\u2502     \u2502  Publisher        \u2502\n        \u2502  + Repository \u2502     \u2502  Read Model       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502           MOD\u00c8LE DE DOMAINE               \u2502\n        \u2502                                          \u2502\n        \u2502  Produit (Aggregate Root)                \u2502\n        \u2502    \u251c\u2500\u2500 Lot (Entity)                      \u2502\n        \u2502    \u2502     \u2514\u2500\u2500 {LigneDeCommande} (VO)      \u2502\n        \u2502    \u251c\u2500\u2500 num\u00e9ro_version                    \u2502\n        \u2502    \u2514\u2500\u2500 \u00e9v\u00e9nements[]                      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Chaque fl\u00e8che pointe vers l'int\u00e9rieur : les d\u00e9pendances vont de l'infrastructure vers le domaine, jamais l'inverse. Le domaine ne sait rien du monde ext\u00e9rieur.</p>"},{"location":"epilogue/#quand-ne-pas-utiliser-ces-patterns","title":"Quand NE PAS utiliser ces patterns","text":"<p>C'est la question la plus importante de ce guide, et elle arrive en dernier \u00e0 dessein.</p>"},{"location":"epilogue/#lapplication-est-un-crud-simple","title":"L'application est un CRUD simple","text":"<p>Si votre application lit et \u00e9crit des lignes dans une base de donn\u00e9es sans logique m\u00e9tier complexe, un framework comme Django avec ses mod\u00e8les \"fat\" ou FastAPI avec SQLModel sera infiniment plus productif que cette architecture. Les patterns pr\u00e9sent\u00e9s ici n'apportent de la valeur que quand la logique m\u00e9tier est complexe.</p>"},{"location":"epilogue/#lequipe-est-petite-et-le-projet-est-jeune","title":"L'\u00e9quipe est petite et le projet est jeune","text":"<p>Une \u00e9quipe de 1 \u00e0 3 d\u00e9veloppeurs sur un projet de quelques mois ne tirera pas assez de b\u00e9n\u00e9fices de cette architecture pour justifier sa complexit\u00e9. Commencez simple, et refactorez vers ces patterns quand la douleur se fait sentir.</p>"},{"location":"epilogue/#vous-navez-pas-dexpert-ddd-dans-lequipe","title":"Vous n'avez pas d'expert DDD dans l'\u00e9quipe","text":"<p>Ces patterns n\u00e9cessitent une compr\u00e9hension partag\u00e9e. Si l'\u00e9quipe ne comprend pas la distinction entre Entity et Value Object, ou entre Command et Event, l'architecture deviendra un fardeau plut\u00f4t qu'un outil.</p> <p>La r\u00e8gle pragmatique</p> <p>Commencez avec l'architecture la plus simple qui fonctionne. Ajoutez des patterns quand la complexit\u00e9 m\u00e9tier l'exige, pas par anticipation. Le refactoring est moins co\u00fbteux qu'une abstraction inutile.</p>"},{"location":"epilogue/#les-pieges-courants","title":"Les pi\u00e8ges courants","text":""},{"location":"epilogue/#1-mettre-de-la-logique-metier-dans-les-handlers","title":"1. Mettre de la logique m\u00e9tier dans les handlers","text":"<p>Le sympt\u00f4me : un handler de 30 lignes avec des <code>if/else</code>, des boucles et des calculs. La r\u00e8gle : si vous enlevez le handler et appelez directement le domaine dans un test, la logique fonctionne-t-elle ? Si non, de la logique m\u00e9tier s'est gliss\u00e9e dans le handler.</p>"},{"location":"epilogue/#2-oublier-de-commiter","title":"2. Oublier de commiter","text":"<p>Le <code>with uow</code> garantit un rollback si <code>commit()</code> n'est pas appel\u00e9. C'est un filet de s\u00e9curit\u00e9, pas un comportement normal. Si vos tests passent mais que les donn\u00e9es ne sont pas persist\u00e9es en production, v\u00e9rifiez que <code>uow.commit()</code> est bien appel\u00e9 explicitement.</p>"},{"location":"epilogue/#3-confondre-events-et-commands","title":"3. Confondre events et commands","text":"<p>Les events sont des faits (pass\u00e9 compos\u00e9, broadcast, erreur loggu\u00e9e). Les commands sont des intentions (imp\u00e9ratif, point-\u00e0-point, erreur propag\u00e9e). Nommer un event \u00e0 l'imp\u00e9ratif ou traiter une command comme un broadcast est un signe de confusion.</p>"},{"location":"epilogue/#4-agregats-trop-gros","title":"4. Agr\u00e9gats trop gros","text":"<p>Si votre agr\u00e9gat contient 50 entit\u00e9s et 200 attributs, chaque modification verrouille tout. Le bon agr\u00e9gat est le plus petit groupe d'objets qui doit rester coh\u00e9rent. En cas de doute, commencez petit et \u00e9largissez si n\u00e9cessaire.</p>"},{"location":"epilogue/#5-tester-les-mocks-plutot-que-le-comportement","title":"5. Tester les mocks plut\u00f4t que le comportement","text":"<p>Si vos tests v\u00e9rifient que <code>repo.add()</code> a \u00e9t\u00e9 appel\u00e9 avec tel argument (<code>mock.assert_called_with</code>), vous testez l'impl\u00e9mentation, pas le comportement. Utilisez des fakes et v\u00e9rifiez les r\u00e9sultats observables.</p>"},{"location":"epilogue/#6-cqrs-partout","title":"6. CQRS partout","text":"<p>Le CQRS est puissant mais co\u00fbteux : une table suppl\u00e9mentaire, des event handlers de synchronisation, de l'eventual consistency. Ne l'appliquez qu'aux requ\u00eates de lecture qui posent r\u00e9ellement un probl\u00e8me de performance ou de complexit\u00e9.</p>"},{"location":"epilogue/#7-boucles-infinies-dans-le-message-bus","title":"7. Boucles infinies dans le message bus","text":"<p>Si un event handler \u00e9met le m\u00eame event qu'il traite, le bus tourne ind\u00e9finiment. Soyez attentif aux cascades d'events et consid\u00e9rez un compteur de profondeur maximale si votre syst\u00e8me devient complexe.</p>"},{"location":"epilogue/#les-compromis-a-assumer","title":"Les compromis \u00e0 assumer","text":"<p>Chaque pattern de ce guide implique un compromis. Les voici r\u00e9sum\u00e9s :</p> Pattern Ce que vous gagnez Ce que vous payez Domain Model Logique m\u00e9tier isol\u00e9e, testable Complexit\u00e9 initiale, mapping ORM Repository D\u00e9couplage de la persistance Couche d'abstraction suppl\u00e9mentaire Service Layer Orchestration claire, handlers fins Un fichier de plus, risque de \"pass-through\" Unit of Work Transactions atomiques, events Complexit\u00e9 du context manager Agr\u00e9gats Coh\u00e9rence garantie Contention en cas d'agr\u00e9gat trop gros Events D\u00e9couplage, extensibilit\u00e9 Flux indirect, plus difficile \u00e0 suivre Message Bus Point d'entr\u00e9e unique Indirection, cascade potentielle CQRS Performances de lecture Eventual consistency, table \u00e0 synchroniser DI/Bootstrap Testabilit\u00e9, flexibilit\u00e9 Indirection, \"magie\" de l'introspection"},{"location":"epilogue/#conseils-pour-demarrer-un-nouveau-projet","title":"Conseils pour d\u00e9marrer un nouveau projet","text":"<ol> <li> <p>Commencez par le domaine. \u00c9crivez les classes du domaine et leurs tests unitaires avant toute infrastructure. Si le domaine fonctionne en m\u00e9moire, vous \u00eates sur la bonne voie.</p> </li> <li> <p>Ajoutez le Repository et le UoW ensemble. Ils forment un couple naturel. Cr\u00e9ez le fake en m\u00eame temps que l'impl\u00e9mentation r\u00e9elle.</p> </li> <li> <p>Le Message Bus peut attendre. Si vous n'avez pas d'events \u00e0 propager, un simple appel de fonction suffit. Ajoutez le bus quand le besoin de r\u00e9activit\u00e9 appara\u00eet.</p> </li> <li> <p>CQRS est un ajout tardif. Commencez avec le m\u00eame mod\u00e8le pour les lectures et les \u00e9critures. S\u00e9parez quand les requ\u00eates de lecture deviennent un probl\u00e8me.</p> </li> <li> <p>\u00c9crivez des tests high gear d\u00e8s le d\u00e9but. Ils sont votre filet de s\u00e9curit\u00e9 pour le refactoring. Les tests low gear viendront naturellement quand vous d\u00e9velopperez la logique m\u00e9tier.</p> </li> </ol>"},{"location":"epilogue/#ressources-pour-aller-plus-loin","title":"Ressources pour aller plus loin","text":"<ul> <li>Architecture Patterns with Python (Harry Percival &amp; Bob Gregory) -- cosmicpython.com -- le livre original qui a inspir\u00e9 ce guide.</li> <li>Domain-Driven Design (Eric Evans) -- le livre fondateur du DDD.</li> <li>Patterns of Enterprise Application Architecture (Martin Fowler) -- la r\u00e9f\u00e9rence pour les patterns Repository, Unit of Work, Service Layer.</li> <li>Implementing Domain-Driven Design (Vaughn Vernon) -- un guide pratique pour appliquer le DDD.</li> <li>Clean Architecture (Robert C. Martin) -- une perspective compl\u00e9mentaire sur l'isolation du domaine.</li> </ul> <p>Le mot de la fin</p> <p>L'architecture n'est pas une fin en soi. C'est un outil au service de la maintenabilit\u00e9, de la testabilit\u00e9 et de l'\u00e9volutivit\u00e9. Le meilleur code est celui qui r\u00e9sout le probl\u00e8me du jour avec la complexit\u00e9 juste n\u00e9cessaire -- ni plus, ni moins.</p>"},{"location":"partie1/chapitre_01_modele_domaine/","title":"Chapitre 1 -- Le Domain Model","text":"<p>Avant / Apr\u00e8s</p> Avant Logique m\u00e9tier dispers\u00e9e dans des transaction scripts Apr\u00e8s Classes pures <code>Lot</code>, <code>LigneDeCommande</code> + fonction <code>allouer()</code>"},{"location":"partie1/chapitre_01_modele_domaine/#pourquoi-un-modele-de-domaine","title":"Pourquoi un mod\u00e8le de domaine ?","text":"<p>Imaginons un syst\u00e8me d'allocation de stock. Un client passe une commande, et le syst\u00e8me doit d\u00e9cider quel lot de marchandise utiliser pour honorer cette commande. Simple en apparence, mais les r\u00e8gles s'accumulent vite : on pr\u00e9f\u00e8re puiser dans le stock d\u00e9j\u00e0 en entrep\u00f4t plut\u00f4t que dans une livraison \u00e0 venir, on choisit la livraison la plus proche si tout le stock en entrep\u00f4t est \u00e9puis\u00e9, on ne peut pas allouer plus que ce qui est disponible, on ne peut pas allouer un SKU diff\u00e9rent de celui command\u00e9...</p> <p>Dans beaucoup de projets, cette logique finit dispers\u00e9e un peu partout : dans les vues Django, dans les endpoints FastAPI, dans des scripts SQL. C'est ce qu'on appelle parfois un transaction script -- un gros bloc proc\u00e9dural qui m\u00e9lange logique m\u00e9tier, acc\u00e8s aux donn\u00e9es et orchestration. \u00c7a fonctionne au d\u00e9but, puis \u00e7a devient un cauchemar \u00e0 maintenir et \u00e0 tester.</p> <p>Le Domain Model est une r\u00e9ponse \u00e0 ce probl\u00e8me. L'id\u00e9e est de concentrer toute la logique m\u00e9tier dans une couche de code pur Python, sans aucune d\u00e9pendance technique. Pas de base de donn\u00e9es, pas de framework web, pas d'import <code>requests</code> ou <code>sqlalchemy</code>. Juste des classes, des m\u00e9thodes et des r\u00e8gles m\u00e9tier.</p> <p>L'avantage principal</p> <p>Un mod\u00e8le de domaine pur se teste avec de simples tests unitaires, sans fixtures de base de donn\u00e9es ni serveur HTTP. Les tests s'ex\u00e9cutent en millisecondes.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#quest-ce-quun-domain-model","title":"Qu'est-ce qu'un Domain Model ?","text":"<p>Le Domain Model est une repr\u00e9sentation en code des concepts, des r\u00e8gles et des processus du domaine m\u00e9tier. C'est la traduction directe de ce que les experts m\u00e9tier d\u00e9crivent quand ils parlent de leur travail.</p> <p>Dans notre cas, les experts m\u00e9tier parlent de lignes de commande, de lots de stock, de SKU (Stock Keeping Unit), d'allocation et de quantit\u00e9 disponible. Le Domain Model reprend exactement ce vocabulaire.</p> <pre><code>Vocabulaire metier          Code\n-----------------          ----\nLigne de commande    --&gt;   LigneDeCommande\nLot de stock         --&gt;   Lot\nAllouer              --&gt;   allouer()\nQuantite disponible  --&gt;   quantit\u00e9_disponible\nReference produit    --&gt;   SKU (str)\n</code></pre> <p>La distinction fondamentale avec un transaction script, c'est l'endroit o\u00f9 vivent les r\u00e8gles. Dans un transaction script, la logique est dans le handler :</p> <pre><code># Transaction script -- a eviter\ndef allouer(id_commande, sku, quantit\u00e9, session):\n    lots = session.query(Lot).filter_by(sku=sku).all()\n    lots.sort(key=lambda l: (l.eta is not None, l.eta))\n    for lot in lots:\n        if lot._quantit\u00e9_achet\u00e9e - lot.quantit\u00e9_allou\u00e9e &gt;= quantit\u00e9:\n            lot.quantit\u00e9_allou\u00e9e += quantit\u00e9\n            session.commit()\n            return lot.r\u00e9f\u00e9rence\n    raise Exception(f\"Rupture de stock pour {sku}\")\n</code></pre> <p>Dans un Domain Model, la logique vit dans les objets du domaine eux-m\u00eames. Le handler ne fait que les orchestrer. C'est cette s\u00e9paration qui rend le code testable, lisible et maintenable.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#value-objects","title":"Value Objects","text":"<p>Un Value Object est un objet d\u00e9fini par ses attributs, pas par une identit\u00e9. Deux billets de 10 euros sont interchangeables : peu importe lequel vous avez, ce qui compte c'est la valeur. De la m\u00eame fa\u00e7on, deux lignes de commande avec le m\u00eame <code>id_commande</code>, le m\u00eame <code>sku</code> et la m\u00eame <code>quantit\u00e9</code> sont identiques.</p> <p>Voici notre Value Object <code>LigneDeCommande</code> :</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass(unsafe_hash=True)\nclass LigneDeCommande:\n    \"\"\"\n    Value Object repr\u00e9sentant une ligne de commande.\n\n    Un value object est d\u00e9fini par ses attributs, pas par une identit\u00e9.\n    Deux LigneDeCommande avec les m\u00eames attributs sont consid\u00e9r\u00e9es\n    comme identiques.\n    \"\"\"\n\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n</code></pre> <p>Le d\u00e9corateur <code>@dataclass(unsafe_hash=True)</code> fait deux choses essentielles :</p> <ol> <li> <p>\u00c9galit\u00e9 structurelle -- <code>@dataclass</code> g\u00e9n\u00e8re automatiquement <code>__eq__</code> en comparant tous les attributs. Deux <code>LigneDeCommande</code> avec les m\u00eames valeurs sont consid\u00e9r\u00e9es comme identiques.</p> </li> <li> <p>Hashabilit\u00e9 -- <code>unsafe_hash=True</code> g\u00e9n\u00e8re <code>__hash__</code> \u00e0 partir des attributs, ce qui permet d'utiliser l'objet dans des <code>set</code> et comme cl\u00e9 de <code>dict</code>. C'est indispensable pour notre mod\u00e8le, car <code>Lot</code> stocke ses allocations dans un <code>set[LigneDeCommande]</code>.</p> </li> </ol> <p>Pourquoi <code>unsafe_hash</code> et pas <code>frozen</code> ?</p> <p>On pourrait utiliser <code>@dataclass(frozen=True)</code> pour rendre l'objet strictement immuable. Mais <code>frozen=True</code> entre en conflit avec le mapping ORM de SQLAlchemy : quand l'ORM charge un objet depuis la base de donn\u00e9es, il a besoin de lui assigner un attribut interne (<code>_sa_instance_state</code>), ce que <code>frozen</code> interdit. <code>unsafe_hash=True</code> offre le m\u00eame comportement d'\u00e9galit\u00e9 et de hashabilit\u00e9, tout en restant compatible avec l'ORM. La convention dans l'\u00e9quipe est de ne jamais modifier une <code>LigneDeCommande</code> apr\u00e8s cr\u00e9ation -- c'est une discipline plut\u00f4t qu'une contrainte technique.</p> Pourquoi <code>@dataclass</code> et pas <code>NamedTuple</code> ? <p>Les deux sont des choix valables. <code>@dataclass</code> offre plus de flexibilit\u00e9 (h\u00e9ritage, m\u00e9thodes, valeurs par d\u00e9faut mutables via <code>field</code>). <code>NamedTuple</code> est l\u00e9g\u00e8rement plus performant en m\u00e9moire. Pour un Domain Model, la diff\u00e9rence est n\u00e9gligeable. L'important, c'est l'\u00e9galit\u00e9 structurelle et la hashabilit\u00e9.</p> <p>On peut v\u00e9rifier le comportement d'\u00e9galit\u00e9 :</p> <pre><code>def test_equality():\n    \"\"\"Deux LigneDeCommande avec les m\u00eames attributs sont \u00e9gales (value object).\"\"\"\n    ligne1 = LigneDeCommande(\"commande1\", \"SKU-001\", 10)\n    ligne2 = LigneDeCommande(\"commande1\", \"SKU-001\", 10)\n    assert ligne1 == ligne2\n\ndef test_inequality():\n    ligne1 = LigneDeCommande(\"commande1\", \"SKU-001\", 10)\n    ligne2 = LigneDeCommande(\"commande2\", \"SKU-001\", 10)\n    assert ligne1 != ligne2\n</code></pre> <p>Pas besoin d'\u00e9crire <code>__eq__</code> : <code>@dataclass</code> le g\u00e9n\u00e8re automatiquement en comparant tous les attributs.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#entities","title":"Entities","text":"<p>Une Entity est un objet avec une identit\u00e9 qui persiste dans le temps. M\u00eame si ses attributs changent, l'entit\u00e9 reste la m\u00eame. Un lot de stock avec la r\u00e9f\u00e9rence <code>\"lot-042\"</code> reste le m\u00eame lot, qu'il contienne 100 ou 50 unit\u00e9s.</p> <p>Voici notre entit\u00e9 <code>Lot</code> :</p> <pre><code>class Lot:\n    \"\"\"\n    Entit\u00e9 repr\u00e9sentant un lot de stock.\n\n    Un Lot a une identit\u00e9 (sa r\u00e9f\u00e9rence) et un cycle de vie.\n    Il contient une quantit\u00e9 de stock pour un SKU donn\u00e9,\n    avec une date d'arriv\u00e9e (ETA) optionnelle.\n    \"\"\"\n\n    def __init__(self, r\u00e9f: str, sku: str, quantit\u00e9: int, eta: Optional[date] = None):\n        self.r\u00e9f\u00e9rence = r\u00e9f\n        self.sku = sku\n        self.eta = eta\n        self._quantit\u00e9_achet\u00e9e = quantit\u00e9\n        self._allocations: set[LigneDeCommande] = set()\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Lot {self.r\u00e9f\u00e9rence}&gt;\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Lot):\n            return NotImplemented\n        return self.r\u00e9f\u00e9rence == other.r\u00e9f\u00e9rence\n\n    def __hash__(self) -&gt; int:\n        return hash(self.r\u00e9f\u00e9rence)\n</code></pre> <p>Trois points importants :</p> <p><code>__eq__</code> compare uniquement la r\u00e9f\u00e9rence. Deux objets <code>Lot</code> avec la m\u00eame r\u00e9f\u00e9rence sont consid\u00e9r\u00e9s comme la m\u00eame entit\u00e9, peu importe les autres attributs. C'est la d\u00e9finition m\u00eame d'une entit\u00e9 : l'\u00e9galit\u00e9 est bas\u00e9e sur l'identit\u00e9, pas sur la valeur.</p> <p><code>__hash__</code> est bas\u00e9 sur la r\u00e9f\u00e9rence. Quand on red\u00e9finit <code>__eq__</code>, Python rend l'objet non-hashable par d\u00e9faut. On doit donc red\u00e9finir <code>__hash__</code> explicitement, en se basant sur le m\u00eame attribut que <code>__eq__</code>.</p> <p><code>NotImplemented</code> plut\u00f4t que <code>False</code>. Quand on compare un <code>Lot</code> avec un objet d'un autre type, on retourne <code>NotImplemented</code> pour laisser Python essayer l'autre op\u00e9rande. C'est une bonne pratique souvent oubli\u00e9e.</p> <p>Entity vs Value Object : la r\u00e8gle</p> <p>Si deux objets avec les m\u00eames attributs sont interchangeables, c'est un Value Object. Si un objet a un cycle de vie et une identit\u00e9 qui persiste m\u00eame quand ses attributs changent, c'est une Entity.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#les-regles-metier-dans-le-domaine","title":"Les r\u00e8gles m\u00e9tier dans le domaine","text":"<p>C'est ici que le Domain Model prend tout son sens. Les r\u00e8gles m\u00e9tier ne sont pas dans un service externe ou dans un handler : elles vivent directement dans les objets du domaine.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#verifier-quon-peut-allouer","title":"V\u00e9rifier qu'on peut allouer","text":"<pre><code>def peut_allouer(self, ligne: LigneDeCommande) -&gt; bool:\n    \"\"\"V\u00e9rifie si ce lot peut accueillir la ligne de commande.\"\"\"\n    return self.sku == ligne.sku and self.quantit\u00e9_disponible &gt;= ligne.quantit\u00e9\n</code></pre> <p>Deux conditions, et elles se lisent comme du langage naturel : le SKU doit correspondre, et la quantit\u00e9 disponible doit \u00eatre suffisante.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#allouer-une-ligne-de-commande","title":"Allouer une ligne de commande","text":"<pre><code>def allouer(self, ligne: LigneDeCommande) -&gt; None:\n    \"\"\"Alloue une ligne de commande \u00e0 ce lot.\"\"\"\n    if self.peut_allouer(ligne):\n        self._allocations.add(ligne)\n</code></pre> <p>L'allocation revient \u00e0 ajouter la ligne de commande dans l'ensemble <code>_allocations</code>. Comme <code>LigneDeCommande</code> est un Value Object hashable, le <code>set</code> garantit l'idempotence : allouer deux fois la m\u00eame ligne n'a aucun effet.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#desallouer","title":"D\u00e9sallouer","text":"<pre><code>def d\u00e9sallouer(self, ligne: LigneDeCommande) -&gt; None:\n    \"\"\"D\u00e9salloue une ligne de commande de ce lot.\"\"\"\n    if ligne in self._allocations:\n        self._allocations.discard(ligne)\n</code></pre> <p>La d\u00e9sallocation est l'op\u00e9ration inverse. On utilise <code>discard</code> plut\u00f4t que <code>remove</code> pour \u00e9viter une exception si la ligne n'est pas pr\u00e9sente, mais la v\u00e9rification <code>if ligne in self._allocations</code> rend l'intention explicite.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#quantites-calculees","title":"Quantit\u00e9s calcul\u00e9es","text":"<pre><code>@property\ndef quantit\u00e9_allou\u00e9e(self) -&gt; int:\n    return sum(ligne.quantit\u00e9 for ligne in self._allocations)\n\n@property\ndef quantit\u00e9_disponible(self) -&gt; int:\n    return self._quantit\u00e9_achet\u00e9e - self.quantit\u00e9_allou\u00e9e\n</code></pre> <p>La quantit\u00e9 disponible est toujours calcul\u00e9e \u00e0 partir de l'\u00e9tat r\u00e9el des allocations. Pas de compteur \u00e0 maintenir manuellement, pas de risque de d\u00e9synchronisation. C'est un choix de conception d\u00e9lib\u00e9r\u00e9 : on pr\u00e9f\u00e8re recalculer plut\u00f4t que de maintenir un \u00e9tat d\u00e9riv\u00e9.</p> Performance <p>Recalculer <code>quantit\u00e9_disponible</code> \u00e0 chaque acc\u00e8s peut sembler co\u00fbteux. En pratique, un lot a rarement plus de quelques dizaines d'allocations. Si la performance devenait un probl\u00e8me, on pourrait ajouter un cache -- mais pas avant d'avoir mesur\u00e9. L'optimisation pr\u00e9matur\u00e9e est l'ennemi du code clair.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#la-strategie-dallocation","title":"La strat\u00e9gie d'allocation","text":"<p>Quand un client passe une commande, on veut allouer depuis le lot le plus pertinent. La r\u00e8gle m\u00e9tier est :</p> <ol> <li>D'abord les lots en stock (ceux qui sont d\u00e9j\u00e0 en entrep\u00f4t, sans ETA).</li> <li>Puis les livraisons par ETA croissante (la plus proche d'abord).</li> </ol> <p>Pour impl\u00e9menter cette strat\u00e9gie, on d\u00e9finit <code>__gt__</code> sur <code>Lot</code> :</p> <pre><code>def __gt__(self, other: Lot) -&gt; bool:\n    if self.eta is None:\n        return False\n    if other.eta is None:\n        return True\n    return self.eta &gt; other.eta\n</code></pre> <p>La logique est la suivante :</p> <ul> <li>Un lot sans ETA (en stock) n'est jamais \"plus grand\" qu'un autre. Il sera donc toujours tri\u00e9 en premier.</li> <li>Un lot avec ETA est toujours \"plus grand\" qu'un lot sans ETA.</li> <li>Entre deux lots avec ETA, le tri se fait par date.</li> </ul> <p>Cela permet d'\u00e9crire une fonction d'allocation qui utilise simplement <code>sorted()</code> :</p> <pre><code>def allouer(ligne: LigneDeCommande, lots: list[Lot]) -&gt; str:\n    \"\"\"\n    Alloue une ligne de commande au lot le plus appropri\u00e9.\n\n    La strat\u00e9gie d'allocation privil\u00e9gie les lots en stock\n    (sans ETA) puis les lots avec l'ETA la plus proche.\n\n    Retourne la r\u00e9f\u00e9rence du lot choisi.\n    L\u00e8ve une exception si aucun lot ne convient.\n    \"\"\"\n    try:\n        lot = next(\n            l for l in sorted(lots)\n            if l.peut_allouer(ligne)\n        )\n    except StopIteration:\n        raise RuptureDeStock(f\"Rupture de stock pour {ligne.sku}\")\n\n    lot.allouer(ligne)\n    return lot.r\u00e9f\u00e9rence\n\n\nclass RuptureDeStock(Exception):\n    \"\"\"Lev\u00e9e quand il n'y a plus de stock disponible.\"\"\"\n    pass\n</code></pre> <p><code>sorted(lots)</code> trie les lots gr\u00e2ce \u00e0 <code>__gt__</code>. Puis on prend le premier qui peut accueillir la ligne (<code>peut_allouer</code>). Si aucun lot ne convient, on l\u00e8ve une exception <code>RuptureDeStock</code>.</p> <p>Pourquoi <code>__gt__</code> et pas <code>__lt__</code> ?</p> <p>Python a besoin d'un seul op\u00e9rateur de comparaison pour que <code>sorted()</code> fonctionne. On aurait pu d\u00e9finir <code>__lt__</code> \u00e0 la place, avec la logique invers\u00e9e. Le choix de <code>__gt__</code> est une convention : on consid\u00e8re que les lots les \"plus grands\" sont ceux qui arrivent le plus tard, ce qui est naturel quand on pense aux dates.</p> <p>Et ensuite ?</p> <p>Cette fonction libre <code>allouer()</code> fonctionne bien, mais elle a un d\u00e9faut : rien ne garantit qu'on lui passe les bons lots, ni qu'on ne manipule pas un lot directement sans passer par la strat\u00e9gie. Au chapitre 7, nous introduirons le concept d'Agr\u00e9gat avec la classe <code>Produit</code>, qui regroupera les lots d'un m\u00eame SKU et servira de point d'entr\u00e9e unique pour toutes les op\u00e9rations d'allocation. Cette \u00e9volution n'est pas n\u00e9cessaire pour l'instant -- concentrons-nous d'abord sur les fondamentaux.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#tester-le-modele-de-domaine","title":"Tester le mod\u00e8le de domaine","text":"<p>L'avantage majeur d'un Domain Model pur, c'est la testabilit\u00e9. Les tests sont simples, rapides et ne n\u00e9cessitent aucune infrastructure.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#tests-du-lot","title":"Tests du Lot","text":"<pre><code>import pytest\nfrom datetime import date, timedelta\nfrom allocation.domain.model import Lot, LigneDeCommande, allouer, RuptureDeStock\n\n\ndef make_lot_et_ligne(\n    sku: str, quantit\u00e9_lot: int, quantit\u00e9_ligne: int\n) -&gt; tuple[Lot, LigneDeCommande]:\n    return (\n        Lot(\"lot-001\", sku, quantit\u00e9_lot, eta=date.today()),\n        LigneDeCommande(\"ref-commande\", sku, quantit\u00e9_ligne),\n    )\n\n\nclass TestLot:\n    def test_allouer_reduit_quantite_disponible(self):\n        lot, ligne = make_lot_et_ligne(\"PETITE-TABLE\", 20, 2)\n        lot.allouer(ligne)\n        assert lot.quantit\u00e9_disponible == 18\n\n    def test_peut_allouer_si_disponible_superieur_au_requis(self):\n        lot, ligne = make_lot_et_ligne(\"ELEGANTE-LAMPE\", 20, 2)\n        assert lot.peut_allouer(ligne)\n\n    def test_ne_peut_pas_allouer_si_disponible_inferieur_au_requis(self):\n        lot, ligne = make_lot_et_ligne(\"ELEGANTE-LAMPE\", 2, 20)\n        assert not lot.peut_allouer(ligne)\n\n    def test_ne_peut_pas_allouer_si_skus_differents(self):\n        lot = Lot(\"lot-001\", \"CHAISE-INCOMFORTABLE\", 100, eta=None)\n        ligne = LigneDeCommande(\"ref-commande\", \"COUSSIN-MOELLEUX\", 10)\n        assert not lot.peut_allouer(ligne)\n\n    def test_allocation_est_idempotente(self):\n        lot, ligne = make_lot_et_ligne(\"ANGULAR-DESK\", 20, 2)\n        lot.allouer(ligne)\n        lot.allouer(ligne)\n        assert lot.quantit\u00e9_disponible == 18\n\n    def test_desallouer(self):\n        lot, ligne = make_lot_et_ligne(\"ANGULAR-DESK\", 20, 2)\n        lot.allouer(ligne)\n        lot.d\u00e9sallouer(ligne)\n        assert lot.quantit\u00e9_disponible == 20\n</code></pre> <p>Remarquez la structure : chaque test cr\u00e9e ses objets, ex\u00e9cute une action et v\u00e9rifie le r\u00e9sultat. Pas de <code>setUp</code> complexe, pas de mock, pas de base de donn\u00e9es. Les noms des tests d\u00e9crivent le comportement attendu en langage naturel.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#tests-de-la-strategie-dallocation","title":"Tests de la strat\u00e9gie d'allocation","text":"<pre><code>class TestAllouer:\n    def test_prefere_lots_en_stock_aux_livraisons(self):\n        \"\"\"Les lots en stock (sans ETA) sont pr\u00e9f\u00e9r\u00e9s aux livraisons.\"\"\"\n        lot_en_stock = Lot(\"lot-en-stock\", \"HORLOGE-RETRO\", 100, eta=None)\n        lot_en_livraison = Lot(\n            \"lot-en-livraison\", \"HORLOGE-RETRO\", 100,\n            eta=date.today() + timedelta(days=1)\n        )\n        ligne = LigneDeCommande(\"r\u00e9f-cmd\", \"HORLOGE-RETRO\", 10)\n\n        allouer(ligne, [lot_en_stock, lot_en_livraison])\n\n        assert lot_en_stock.quantit\u00e9_disponible == 90\n        assert lot_en_livraison.quantit\u00e9_disponible == 100\n\n    def test_prefere_lots_plus_proches(self):\n        \"\"\"Parmi les livraisons, on pr\u00e9f\u00e8re la plus proche.\"\"\"\n        le_plus_tot = Lot(\"lot-rapide\", \"LAMPE-MINIMALE\", 100, eta=date.today())\n        moyen = Lot(\n            \"lot-normal\", \"LAMPE-MINIMALE\", 100,\n            eta=date.today() + timedelta(days=5)\n        )\n        le_plus_tard = Lot(\n            \"lot-lent\", \"LAMPE-MINIMALE\", 100,\n            eta=date.today() + timedelta(days=10)\n        )\n        ligne = LigneDeCommande(\"commande1\", \"LAMPE-MINIMALE\", 10)\n\n        allouer(ligne, [moyen, le_plus_tot, le_plus_tard])\n\n        assert le_plus_tot.quantit\u00e9_disponible == 90\n        assert moyen.quantit\u00e9_disponible == 100\n        assert le_plus_tard.quantit\u00e9_disponible == 100\n\n    def test_leve_rupture_de_stock_si_impossible(self):\n        \"\"\"RuptureDeStock est lev\u00e9e quand aucun lot ne convient.\"\"\"\n        lot = Lot(\"lot-001\", \"PETITE-FOURCHETTE\", 10, eta=date.today())\n        ligne = LigneDeCommande(\"commande1\", \"PETITE-FOURCHETTE\", 20)\n\n        with pytest.raises(RuptureDeStock, match=\"PETITE-FOURCHETTE\"):\n            allouer(ligne, [lot])\n</code></pre> <p>Notez comment les tests appellent directement la fonction <code>allouer()</code> avec une ligne et une liste de lots. Le test <code>test_prefere_lots_en_stock_aux_livraisons</code> passe les lots dans un ordre qui ne correspond pas \u00e0 la priorit\u00e9 attendue, pour v\u00e9rifier que le tri fonctionne. Le test <code>test_prefere_lots_plus_proches</code> m\u00e9lange volontairement l'ordre (<code>moyen, le_plus_tot, le_plus_tard</code>) pour la m\u00eame raison. Le test <code>test_leve_rupture_de_stock_si_impossible</code> v\u00e9rifie que l'exception <code>RuptureDeStock</code> est bien lev\u00e9e quand aucun lot ne peut satisfaire la demande.</p> <p>Ces tests s'ex\u00e9cutent en quelques millisecondes. On peut en avoir des centaines sans que la suite de tests ne ralentisse. C'est un avantage consid\u00e9rable par rapport aux tests d'int\u00e9gration qui n\u00e9cessitent une base de donn\u00e9es.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Ajouter une r\u00e8gle m\u00e9tier</p> <p>Ajoutez une r\u00e8gle : on ne peut pas allouer une quantit\u00e9 de z\u00e9ro ou n\u00e9gative. Modifiez la m\u00e9thode <code>peut_allouer()</code> de <code>Lot</code> et \u00e9crivez un test unitaire qui v\u00e9rifie ce comportement.</p> <p>Exercice 2 -- Nouveau Value Object</p> <p>Cr\u00e9ez un Value Object <code>Sku</code> qui encapsule la validation du SKU (non vide, uniquement des caract\u00e8res alphanum\u00e9riques et des tirets). Remplacez les <code>str</code> par <code>Sku</code> dans le mod\u00e8le. Quels tests changent ?</p> <p>Exercice 3 -- Comparer avec un transaction script</p> <p>\u00c9crivez la logique d'allocation compl\u00e8te sous forme de transaction script (une seule fonction proc\u00e9durale sans classes). Comparez la lisibilit\u00e9 et la testabilit\u00e9 avec le Domain Model.</p>"},{"location":"partie1/chapitre_01_modele_domaine/#resume","title":"R\u00e9sum\u00e9","text":""},{"location":"partie1/chapitre_01_modele_domaine/#les-concepts-cles","title":"Les concepts cl\u00e9s","text":"Concept Description Exemple Domain Model Couche de code pur qui repr\u00e9sente les r\u00e8gles m\u00e9tier, sans d\u00e9pendance technique. Le module <code>model.py</code> Value Object Objet d\u00e9fini par ses attributs, immuable, sans identit\u00e9 propre. <code>LigneDeCommande</code> Entity Objet avec une identit\u00e9 persistante, m\u00eame si ses attributs changent. <code>Lot</code> Fonction de domaine Logique m\u00e9tier encapsul\u00e9e dans une fonction libre, op\u00e9rant sur les objets du domaine. <code>allouer()</code>"},{"location":"partie1/chapitre_01_modele_domaine/#avantages-du-pattern","title":"Avantages du pattern","text":"<ul> <li>Testabilit\u00e9 -- La logique m\u00e9tier se teste en isolation, sans infrastructure. Les tests sont rapides et fiables.</li> <li>Lisibilit\u00e9 -- Le code du domaine utilise le vocabulaire m\u00e9tier. Un expert non-technique peut le relire et v\u00e9rifier les r\u00e8gles.</li> <li>Maintenabilit\u00e9 -- Les r\u00e8gles m\u00e9tier sont centralis\u00e9es. Quand une r\u00e8gle change, on sait exactement o\u00f9 intervenir.</li> <li>Ind\u00e9pendance technique -- Le domaine ne d\u00e9pend pas de la base de donn\u00e9es ni du framework web. On peut changer d'ORM ou de framework sans toucher aux r\u00e8gles m\u00e9tier.</li> </ul>"},{"location":"partie1/chapitre_01_modele_domaine/#inconvenients-du-pattern","title":"Inconv\u00e9nients du pattern","text":"<ul> <li>Complexit\u00e9 initiale -- Pour des CRUD simples, un Domain Model est excessif. Un transaction script suffit.</li> <li>Mapping objet-relationnel -- Le domaine \u00e9tant d\u00e9coupl\u00e9 de la persistance, il faut une couche de mapping (c'est le sujet du prochain chapitre sur le Repository pattern).</li> <li>Courbe d'apprentissage -- Les concepts de DDD (Entity, Value Object, Aggregate) demandent un investissement initial.</li> </ul> <p>Quand utiliser ce pattern ?</p> <p>Le Domain Model vaut l'investissement quand la logique m\u00e9tier est complexe et susceptible d'\u00e9voluer. Si votre application est essentiellement un CRUD avec peu de r\u00e8gles m\u00e9tier, un transaction script ou un framework comme Django avec ses mod\u00e8les \"fat\" sera plus adapt\u00e9. Il n'y a pas de honte \u00e0 choisir la simplicit\u00e9 quand elle suffit.</p> <p>Dans le prochain chapitre, nous verrons comment persister ce mod\u00e8le de domaine sans le contaminer avec des d\u00e9tails techniques, gr\u00e2ce au pattern Repository.</p>"},{"location":"partie1/chapitre_02_repository/","title":"Chapitre 2 -- Le pattern Repository","text":"<p>Avant / Apr\u00e8s</p> Avant Domaine coupl\u00e9 \u00e0 SQLAlchemy (<code>save()</code>, <code>load()</code>) Apr\u00e8s <code>AbstractRepository</code> + <code>SqlAlchemyRepository</code>, domaine ind\u00e9pendant"},{"location":"partie1/chapitre_02_repository/#le-probleme-de-la-persistance","title":"Le probl\u00e8me de la persistance","text":"<p>Au chapitre pr\u00e9c\u00e9dent, nous avons construit un mod\u00e8le de domaine riche : des <code>LigneDeCommande</code>, des <code>Lot</code>, une fonction <code>allouer()</code> avec des r\u00e8gles m\u00e9tier claires. Tout fonctionne en m\u00e9moire, les tests passent, la logique est pure.</p> <p>Pour persister ces objets, nous avons besoin d'un conteneur qui regroupe les lots d'un m\u00eame SKU. C'est le r\u00f4le de la classe <code>Produit</code> : un objet simple qui poss\u00e8de un <code>sku</code> et une liste de <code>lots</code>. Nous verrons au chapitre 7 pourquoi ce conteneur est en r\u00e9alit\u00e9 un Agr\u00e9gat au sens du DDD, mais pour l'instant, il suffit de le voir comme un regroupement pratique.</p> <p>Mais une application r\u00e9elle doit sauvegarder ses donn\u00e9es. Les objets du domaine doivent \u00eatre persist\u00e9s dans une base de donn\u00e9es, puis recharg\u00e9es plus tard. Et c'est l\u00e0 que les ennuis commencent.</p> <p>La tentation naturelle est d'ajouter des m\u00e9thodes <code>save()</code> et <code>load()</code> directement dans le mod\u00e8le de domaine :</p> <pre><code># Ce qu'on veut \u00e9viter\nclass Produit:\n    def save(self):\n        db.execute(\"INSERT INTO products ...\")\n\n    @classmethod\n    def load(cls, sku):\n        row = db.execute(\"SELECT * FROM products WHERE sku = ?\", sku)\n        return cls(**row)\n</code></pre> <p>Ce code m\u00e9lange deux responsabilit\u00e9s : la logique m\u00e9tier et l'acc\u00e8s aux donn\u00e9es. Le mod\u00e8le de domaine, qui \u00e9tait pur et testable, devient soudain d\u00e9pendant de la base de donn\u00e9es.</p> <p>Le pi\u00e8ge</p> <p>Si le mod\u00e8le de domaine conna\u00eet la BDD, chaque test unitaire devra instancier une connexion. Les tests deviennent lents, fragiles, et difficiles \u00e0 maintenir.</p> <p>La question est donc : comment persister les objets du domaine sans polluer le mod\u00e8le ?</p> <p>La r\u00e9ponse : le pattern Repository.</p>"},{"location":"partie1/chapitre_02_repository/#le-pattern-repository","title":"Le pattern Repository","text":"<p>Le Repository est une abstraction qui donne l'illusion d'une collection d'objets en m\u00e9moire. Du point de vue du code qui l'utilise, un repository ressemble \u00e0 un simple <code>set</code> ou une <code>list</code> Python : on peut y ajouter des objets, en r\u00e9cup\u00e9rer, sans jamais se soucier de la fa\u00e7on dont ils sont stock\u00e9s.</p> <p>L'interface est volontairement minimale :</p> <ul> <li><code>add(produit)</code> -- ajouter un nouvel agr\u00e9gat</li> <li><code>get(sku)</code> -- r\u00e9cup\u00e9rer un agr\u00e9gat existant par son identifiant</li> </ul> <p>C'est tout. Pas de <code>save()</code>, pas de <code>update()</code>, pas de <code>delete()</code>. Le repository cache toute la complexit\u00e9 de la persistance derri\u00e8re cette interface \u00e9l\u00e9mentaire.</p> <pre><code>Code m\u00e9tier                    Repository                     BDD\n-----------                    ----------                     ---\n                  add(produit)                  INSERT INTO ...\nproduit = repo \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; repo \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; DB\n                  get(sku)                     SELECT * FROM ...\nproduit = repo &lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 repo &lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 DB\n</code></pre> <p>Le domaine ne sait pas comment les objets sont stock\u00e9s. PostgreSQL ? SQLite ? Un fichier JSON ? Un service distant ? Peu importe. Le contrat est le m\u00eame.</p>"},{"location":"partie1/chapitre_02_repository/#le-port-linterface-abstraite","title":"Le port : l'interface abstraite","text":"<p>Dans notre projet, le port est d\u00e9fini par la classe <code>AbstractRepository</code>. C'est une classe abstraite qui \u00e9tablit le contrat que toute impl\u00e9mentation doit respecter.</p> <p>Voici le code de <code>src/allocation/adapters/repository.py</code> :</p> <pre><code>import abc\nfrom allocation.domain import model\n\n\nclass AbstractRepository(abc.ABC):\n    \"\"\"\n    Interface abstraite du repository.\n\n    D\u00e9finit le contrat que tout repository doit respecter.\n    Le pattern repose sur deux op\u00e9rations fondamentales :\n    - add : ajouter un nouvel agr\u00e9gat\n    - get : r\u00e9cup\u00e9rer un agr\u00e9gat existant\n    \"\"\"\n\n    seen: set[model.Produit]\n\n    def __init__(self) -&gt; None:\n        self.seen: set[model.Produit] = set()\n\n    def add(self, produit: model.Produit) -&gt; None:\n        \"\"\"Ajoute un produit au repository et le marque comme vu.\"\"\"\n        self._add(produit)\n        self.seen.add(produit)\n\n    def get(self, sku: str) -&gt; model.Produit | None:\n        \"\"\"R\u00e9cup\u00e8re un produit par son SKU et le marque comme vu.\"\"\"\n        produit = self._get(sku)\n        if produit:\n            self.seen.add(produit)\n        return produit\n\n    def get_par_r\u00e9f_lot(self, r\u00e9f_lot: str) -&gt; model.Produit | None:\n        \"\"\"R\u00e9cup\u00e8re le produit contenant le lot de r\u00e9f\u00e9rence donn\u00e9e.\"\"\"\n        produit = self._get_par_r\u00e9f_lot(r\u00e9f_lot)\n        if produit:\n            self.seen.add(produit)\n        return produit\n\n    @abc.abstractmethod\n    def _add(self, produit: model.Produit) -&gt; None:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _get(self, sku: str) -&gt; model.Produit | None:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _get_par_r\u00e9f_lot(self, r\u00e9f_lot: str) -&gt; model.Produit | None:\n        raise NotImplementedError\n</code></pre> <p>Analysons les choix de conception :</p>"},{"location":"partie1/chapitre_02_repository/#methodes-publiques-et-methodes-abstraites-protegees","title":"M\u00e9thodes publiques et m\u00e9thodes abstraites prot\u00e9g\u00e9es","text":"<p>Les m\u00e9thodes publiques (<code>add</code>, <code>get</code>, <code>get_par_r\u00e9f_lot</code>) ne sont pas abstraites. Elles contiennent la logique commune \u00e0 toutes les impl\u00e9mentations -- en l'occurrence, le suivi des objets dans <code>self.seen</code>. Les m\u00e9thodes abstraites pr\u00e9fix\u00e9es d'un underscore (<code>_add</code>, <code>_get</code>, <code>_get_par_r\u00e9f_lot</code>) sont les points d'extension que chaque impl\u00e9mentation concr\u00e8te doit fournir.</p> <p>Ce pattern (parfois appel\u00e9 Template Method) garantit que le comportement de suivi est appliqu\u00e9 uniform\u00e9ment, quelle que soit l'impl\u00e9mentation.</p>"},{"location":"partie1/chapitre_02_repository/#lattribut-seen","title":"L'attribut <code>seen</code>","text":"<p>L'ensemble <code>seen</code> trace tous les objets qui ont \u00e9t\u00e9 ajout\u00e9s ou consult\u00e9s via le repository. Cet attribut est crucial pour le pattern Unit of Work (que nous verrons au chapitre 6) : il permet de savoir quels agr\u00e9gats ont \u00e9t\u00e9 manipul\u00e9s au cours d'une transaction, et donc quels events doivent \u00eatre collect\u00e9s et trait\u00e9s.</p> <pre><code>repo.add(produit)          # produit est ajout\u00e9 \u00e0 seen\nproduit = repo.get(\"SKU\")  # produit est ajout\u00e9 \u00e0 seen\n# -&gt; self.seen contient tous les agr\u00e9gats touch\u00e9s\n</code></pre>"},{"location":"partie1/chapitre_02_repository/#le-vocabulaire-ports-and-adapters","title":"Le vocabulaire Ports and Adapters","text":"<p>Dans l'architecture Ports and Adapters (aussi appel\u00e9e architecture hexagonale), un port est une interface que le domaine d\u00e9finit pour communiquer avec le monde ext\u00e9rieur. <code>AbstractRepository</code> est un port : il exprime ce que le domaine attend de la couche de persistance, sans dicter comment l'impl\u00e9menter.</p> <p>Port = interface d\u00e9finie par le domaine</p> <p>Le port appartient au domaine. C'est le domaine qui dicte le contrat : \"Je veux pouvoir ajouter un <code>Produit</code> et en r\u00e9cup\u00e9rer un par son SKU.\" La couche infrastructure doit s'y conformer.</p>"},{"location":"partie1/chapitre_02_repository/#ladapter-concret-sqlalchemy","title":"L'adapter concret : SQLAlchemy","text":"<p>Un adapter est une impl\u00e9mentation concr\u00e8te d'un port. Il fait le lien entre l'abstraction d\u00e9finie par le domaine et une technologie sp\u00e9cifique. Dans notre cas, <code>SqlAlchemyRepository</code> est l'adapter qui connecte le port <code>AbstractRepository</code> \u00e0 une base de donn\u00e9es via SQLAlchemy.</p> <pre><code>from sqlalchemy.orm import Session\nfrom allocation.domain import model\n\n\nclass SqlAlchemyRepository(AbstractRepository):\n    \"\"\"\n    Impl\u00e9mentation concr\u00e8te du repository avec SQLAlchemy.\n\n    Utilise une session SQLAlchemy pour persister et r\u00e9cup\u00e9rer\n    les agr\u00e9gats Produit.\n    \"\"\"\n\n    def __init__(self, session: Session):\n        super().__init__()\n        self.session = session\n\n    def _add(self, produit: model.Produit) -&gt; None:\n        self.session.add(produit)\n\n    def _get(self, sku: str) -&gt; model.Produit | None:\n        return (\n            self.session.query(model.Produit)\n            .filter_by(sku=sku)\n            .first()\n        )\n\n    def _get_par_r\u00e9f_lot(self, r\u00e9f_lot: str) -&gt; model.Produit | None:\n        return (\n            self.session.query(model.Produit)\n            .join(model.Lot)\n            .filter(model.Lot.r\u00e9f\u00e9rence == r\u00e9f_lot)\n            .first()\n        )\n</code></pre> <p>Quelques observations :</p> <ol> <li>L'appel \u00e0 <code>super().__init__()</code> initialise le <code>set</code> <code>seen</code> dans la classe parente.</li> <li><code>_add</code> d\u00e9l\u00e8gue simplement \u00e0 <code>session.add()</code> de SQLAlchemy. La session se charge du tracking et de l'insertion.</li> <li><code>_get</code> utilise l'API de requ\u00eatage de SQLAlchemy pour filtrer par SKU.</li> <li><code>_get_par_r\u00e9f_lot</code> fait une jointure pour trouver le <code>Produit</code> \u00e0 partir d'une r\u00e9f\u00e9rence de lot.</li> </ol> <p>Adapter = impl\u00e9mentation concr\u00e8te du port</p> <p>L'adapter traduit les op\u00e9rations abstraites du port en appels concrets \u00e0 une technologie. Si demain on migre vers MongoDB, on \u00e9crit un <code>MongoRepository</code> qui impl\u00e9mente les m\u00eames m\u00e9thodes <code>_add</code>, <code>_get</code>, <code>_get_par_r\u00e9f_lot</code>. Le reste du code ne change pas.</p>"},{"location":"partie1/chapitre_02_repository/#persistence-ignorance","title":"Persistence Ignorance","text":"<p>Un principe fondamental de cette architecture est la Persistence Ignorance : le mod\u00e8le de domaine ne sait absolument rien de la base de donn\u00e9es. Il n'importe pas SQLAlchemy, ne conna\u00eet pas les tables, n'a pas de m\u00e9thodes <code>save()</code>.</p> <p>Regardez la classe <code>Produit</code> dans <code>src/allocation/domain/model.py</code> :</p> <pre><code>class Produit:\n    \"\"\"\n    Agr\u00e9gat racine pour la gestion des produits.\n    \"\"\"\n\n    def __init__(self, sku: str, lots: list[Lot] | None = None,\n                 num\u00e9ro_version: int = 0):\n        self.sku = sku\n        self.lots = lots or []\n        self.num\u00e9ro_version = num\u00e9ro_version\n        self.\u00e9v\u00e9nements: list[events.Event] = []\n\n    def allouer(self, ligne: LigneDeCommande) -&gt; str:\n        # ... logique m\u00e9tier pure ...\n</code></pre> <p>Aucune r\u00e9f\u00e9rence \u00e0 la BDD. Aucun import de SQLAlchemy. La classe <code>Produit</code> est un objet Python ordinaire, testable en isolation totale.</p>"},{"location":"partie1/chapitre_02_repository/#comment-ca-marche-alors","title":"Comment \u00e7a marche alors ?","text":"<p>C'est le module <code>src/allocation/adapters/orm.py</code> qui fait le lien, en utilisant le classical mapping de SQLAlchemy. Ce m\u00e9canisme permet de d\u00e9finir les tables d'un c\u00f4t\u00e9, les classes du domaine de l'autre, et de les associer explicitement :</p> <pre><code>from sqlalchemy import Column, Date, ForeignKey, Integer, MetaData, String, Table\nfrom sqlalchemy.orm import registry, relationship\nfrom allocation.domain import model\n\nmetadata = MetaData()\nmapper_registry = registry(metadata=metadata)\n\n# D\u00e9finition des tables\norder_lines = Table(\n    \"order_lines\", metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"id_commande\", String(255)),\n    Column(\"sku\", String(255)),\n    Column(\"quantite\", Integer),\n)\n\nproducts = Table(\n    \"products\", metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"sku\", String(255)),\n    Column(\"numero_version\", Integer, nullable=False, server_default=\"0\"),\n)\n\nbatches = Table(\n    \"batches\", metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"reference\", String(255)),\n    Column(\"sku\", String(255)),\n    Column(\"quantite_achetee\", Integer),\n    Column(\"eta\", Date, nullable=True),\n    Column(\"product_sku\", String(255), ForeignKey(\"products.sku\")),\n)\n\nallocations = Table(\n    \"allocations\", metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"orderline_id\", Integer, ForeignKey(\"order_lines.id\")),\n    Column(\"batch_id\", Integer, ForeignKey(\"batches.id\")),\n)\n\n\ndef start_mappers() -&gt; None:\n    \"\"\"\n    Configure le mapping entre les classes du domaine et les tables SQL.\n    \"\"\"\n    lines_mapper = mapper_registry.map_imperatively(\n        model.LigneDeCommande, order_lines,\n        properties={\n            \"id_commande\": order_lines.c.id_commande,\n            \"quantit\u00e9\": order_lines.c.quantite,\n        },\n    )\n    batches_mapper = mapper_registry.map_imperatively(\n        model.Lot, batches,\n        properties={\n            \"r\u00e9f\u00e9rence\": batches.c.reference,\n            \"_quantit\u00e9_achet\u00e9e\": batches.c.quantite_achetee,\n            \"_allocations\": relationship(\n                lines_mapper, secondary=allocations, collection_class=set\n            ),\n        },\n    )\n    mapper_registry.map_imperatively(\n        model.Produit, products,\n        properties={\n            \"num\u00e9ro_version\": products.c.numero_version,\n            \"lots\": relationship(\n                batches_mapper,\n                primaryjoin=(products.c.sku == batches.c.product_sku),\n            ),\n        },\n    )\n</code></pre> <p>Classical mapping vs. declarative</p> <p>L'approche classique de SQLAlchemy (utilis\u00e9e ici via <code>map_imperatively</code>) est plus verbeuse que l'approche d\u00e9clarative (o\u00f9 les classes h\u00e9ritent de <code>Base</code>), mais elle a un avantage crucial : le mod\u00e8le de domaine reste totalement ind\u00e9pendant de l'ORM. Les classes <code>Produit</code>, <code>Lot</code> et <code>LigneDeCommande</code> n'h\u00e9ritent d'aucune classe SQLAlchemy.</p> <p>La fonction <code>start_mappers()</code> est appel\u00e9e une seule fois au d\u00e9marrage de l'application. \u00c0 partir de ce moment, SQLAlchemy sait comment convertir les objets du domaine en lignes de table, et inversement.</p>"},{"location":"partie1/chapitre_02_repository/#dependency-inversion","title":"Dependency Inversion","text":"<p>Le pattern Repository illustre parfaitement le principe d'inversion des d\u00e9pendances (le \"D\" de SOLID). Comparons deux approches :</p>"},{"location":"partie1/chapitre_02_repository/#approche-classique-dependance-directe","title":"Approche classique (d\u00e9pendance directe)","text":"<pre><code>Domaine \u2500\u2500depends on\u2500\u2500&gt; Infrastructure (SQLAlchemy)\n</code></pre> <p>Le domaine importe et utilise directement SQLAlchemy. Il est coupl\u00e9 \u00e0 une technologie sp\u00e9cifique.</p>"},{"location":"partie1/chapitre_02_repository/#notre-approche-dependance-inversee","title":"Notre approche (d\u00e9pendance invers\u00e9e)","text":"<pre><code>Domaine \u2500\u2500d\u00e9finit\u2500\u2500&gt; AbstractRepository (port)\n                           ^\n                           |\n                       impl\u00e9mente\n                           |\nInfrastructure \u2500\u2500\u2500\u2500&gt; SqlAlchemyRepository (adapter)\n</code></pre> <p>Le domaine d\u00e9finit l'interface (<code>AbstractRepository</code>). L'infrastructure l'impl\u00e9mente (<code>SqlAlchemyRepository</code>). Les d\u00e9pendances pointent vers l'int\u00e9rieur, vers le domaine.</p> <p>Cons\u00e9quence</p> <p>Le domaine ne d\u00e9pend de rien. C'est l'infrastructure qui d\u00e9pend du domaine. Si on veut changer de base de donn\u00e9es, on ne touche pas au domaine -- on \u00e9crit un nouvel adapter.</p> <p>Ce principe se g\u00e9n\u00e9ralise \u00e0 toute communication avec le monde ext\u00e9rieur : envoyer un email, appeler une API, lire un fichier. Le domaine d\u00e9finit le port (ce dont il a besoin), et l'infrastructure fournit l'adapter (comment le faire concr\u00e8tement).</p>"},{"location":"partie1/chapitre_02_repository/#fake-repository-pour-les-tests","title":"Fake Repository pour les tests","text":"<p>L'un des b\u00e9n\u00e9fices les plus imm\u00e9diats du pattern Repository est la possibilit\u00e9 de cr\u00e9er un fake pour les tests. Puisque le contrat est d\u00e9fini par l'interface abstraite, on peut \u00e9crire une impl\u00e9mentation qui stocke tout en m\u00e9moire, dans un simple <code>set</code> Python.</p> <p>Voici le <code>FakeRepository</code> utilis\u00e9 dans <code>tests/unit/test_handlers.py</code> :</p> <pre><code>class FakeRepository(AbstractRepository):\n    \"\"\"\n    Fake repository qui stocke les produits en m\u00e9moire.\n    Utilis\u00e9 pour les tests unitaires.\n    \"\"\"\n\n    def __init__(self, produits: list[model.Produit] | None = None):\n        super().__init__()\n        self._produits = set(produits or [])\n\n    def _add(self, produit: model.Produit) -&gt; None:\n        self._produits.add(produit)\n\n    def _get(self, sku: str) -&gt; model.Produit | None:\n        return next((p for p in self._produits if p.sku == sku), None)\n\n    def _get_par_r\u00e9f_lot(self, r\u00e9f_lot: str) -&gt; model.Produit | None:\n        return next(\n            (\n                p\n                for p in self._produits\n                for l in p.lots\n                if l.r\u00e9f\u00e9rence == r\u00e9f_lot\n            ),\n            None,\n        )\n</code></pre> <p>C'est tout. Pas de base de donn\u00e9es, pas de fichier de configuration, pas de conteneur Docker. Juste un <code>set</code> Python.</p>"},{"location":"partie1/chapitre_02_repository/#pourquoi-cest-puissant","title":"Pourquoi c'est puissant","text":"<p>Les tests qui utilisent le <code>FakeRepository</code> sont :</p> <ul> <li>Rapides -- pas de connexion \u00e0 une BDD, pas d'I/O. Les tests s'ex\u00e9cutent en millisecondes.</li> <li>Isol\u00e9s -- chaque test cr\u00e9e son propre fake, sans effet de bord.</li> <li>D\u00e9terministes -- pas de probl\u00e8me d'\u00e9tat partag\u00e9, de donn\u00e9es r\u00e9siduelles ou de transactions concurrentes.</li> <li>Faciles \u00e0 \u00e9crire -- pas besoin de fixtures complexes pour initialiser la base.</li> </ul> <p>Voici un exemple de test concret utilisant le fake :</p> <pre><code>class TestAjouterLot:\n    def test_ajouter_un_lot(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"COUSSIN-CARRE\", 100, None))\n\n        assert bus.uow.produits.get(\"COUSSIN-CARRE\") is not None\n        assert bus.uow.committed\n\n    def test_ajouter_lot_produit_existant(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"LAMPE-RONDE\", 100, None))\n        bus.handle(commands.Cr\u00e9erLot(\"b2\", \"LAMPE-RONDE\", 99, None))\n\n        produit = bus.uow.produits.get(\"LAMPE-RONDE\")\n        assert len(produit.lots) == 2\n</code></pre> <p>Le <code>FakeRepository</code> est imbriqu\u00e9 dans un <code>FakeUnitOfWork</code> (que nous d\u00e9taillerons au chapitre 6), mais le principe est le m\u00eame : on remplace l'adapter concret par un fake, et le code m\u00e9tier ne voit pas la diff\u00e9rence.</p> <p>Fake vs Mock</p> <p>Un fake est une impl\u00e9mentation simplifi\u00e9e mais fonctionnelle d'une interface. Il a un vrai comportement (ici : stocker et retrouver des objets). Un mock, en revanche, se contente de v\u00e9rifier que certaines m\u00e9thodes ont \u00e9t\u00e9 appel\u00e9es avec certains arguments. Les fakes sont g\u00e9n\u00e9ralement pr\u00e9f\u00e9rables car ils testent le comportement plut\u00f4t que l'impl\u00e9mentation.</p>"},{"location":"partie1/chapitre_02_repository/#le-schema-densemble","title":"Le sch\u00e9ma d'ensemble","text":"<p>R\u00e9capitulons comment les pi\u00e8ces s'assemblent :</p> <pre><code>src/allocation/\n    domain/\n        model.py              &lt;-- Mod\u00e8le de domaine (Produit, Lot, LigneDeCommande)\n                                   Ne conna\u00eet PAS la BDD\n    adapters/\n        repository.py         &lt;-- AbstractRepository (port)\n                                   + SqlAlchemyRepository (adapter)\n        orm.py                &lt;-- Classical mapping SQLAlchemy\n                                   Fait le lien entre model.py et la BDD\n\ntests/unit/\n    test_handlers.py          &lt;-- FakeRepository (fake adapter pour les tests)\n</code></pre> <p>Le flux est toujours le m\u00eame :</p> <ol> <li>Le code m\u00e9tier manipule un <code>AbstractRepository</code> (le port).</li> <li>En production, c'est un <code>SqlAlchemyRepository</code> (l'adapter r\u00e9el) qui est inject\u00e9.</li> <li>En test, c'est un <code>FakeRepository</code> (le fake adapter) qui est inject\u00e9.</li> <li>Le mod\u00e8le de domaine reste ignorant de tout cela.</li> </ol>"},{"location":"partie1/chapitre_02_repository/#exercices","title":"Exercices","text":"<p>Exercice 1 -- FileRepository</p> <p>Impl\u00e9mentez un <code>FileRepository</code> qui persiste les produits dans un fichier JSON. Il doit respecter le contrat de <code>AbstractRepository</code> (m\u00e9thodes <code>_add</code>, <code>_get</code>, <code>_get_par_r\u00e9f_lot</code>). \u00c9crivez un test pour v\u00e9rifier qu'on peut ajouter un produit, puis le retrouver apr\u00e8s avoir recr\u00e9\u00e9 le repository.</p> <p>Exercice 2 -- M\u00e9thode <code>list_all</code></p> <p>Ajoutez une m\u00e9thode <code>list_all() -&gt; list[Produit]</code> \u00e0 l'<code>AbstractRepository</code>. Impl\u00e9mentez-la dans <code>SqlAlchemyRepository</code> et <code>FakeRepository</code>. R\u00e9fl\u00e9chissez : cette m\u00e9thode devrait-elle ajouter les produits \u00e0 <code>seen</code> ?</p> <p>Exercice 3 -- V\u00e9rifier le mapping ORM</p> <p>\u00c9crivez un test d'int\u00e9gration qui cr\u00e9e un <code>Produit</code> avec un <code>Lot</code>, le persiste via <code>SqlAlchemyRepository</code>, puis le recharge et v\u00e9rifie que tous les attributs sont corrects. Utilisez une base SQLite en m\u00e9moire (<code>sqlite://</code>).</p>"},{"location":"partie1/chapitre_02_repository/#resume","title":"R\u00e9sum\u00e9","text":""},{"location":"partie1/chapitre_02_repository/#tableau-des-concepts","title":"Tableau des concepts","text":"Concept R\u00f4le Fichier Repository Abstraction de la couche de persistance <code>adapters/repository.py</code> Port (<code>AbstractRepository</code>) Interface d\u00e9finie par le domaine <code>adapters/repository.py</code> Adapter (<code>SqlAlchemyRepository</code>) Impl\u00e9mentation concr\u00e8te du port <code>adapters/repository.py</code> Classical Mapping Liaison entre classes du domaine et tables SQL <code>adapters/orm.py</code> Persistence Ignorance Le domaine ne conna\u00eet pas la BDD <code>domain/model.py</code> Fake (<code>FakeRepository</code>) Impl\u00e9mentation en m\u00e9moire pour les tests <code>tests/unit/test_handlers.py</code>"},{"location":"partie1/chapitre_02_repository/#avantages","title":"Avantages","text":"<ul> <li>D\u00e9couplage -- Le mod\u00e8le de domaine ne d\u00e9pend pas de la technologie de persistance. On peut changer de BDD sans modifier la logique m\u00e9tier.</li> <li>Testabilit\u00e9 -- Gr\u00e2ce au fake, les tests unitaires sont rapides, isol\u00e9s et d\u00e9terministes. Pas besoin de base de donn\u00e9es pour tester la logique m\u00e9tier.</li> <li>Lisibilit\u00e9 -- L'interface <code>add()</code> / <code>get()</code> est simple et intuitive. Le code m\u00e9tier lit comme du langage naturel.</li> <li>Extensibilit\u00e9 -- Ajouter une nouvelle source de donn\u00e9es revient \u00e0 \u00e9crire un nouvel adapter. Le reste du syst\u00e8me n'est pas affect\u00e9.</li> </ul>"},{"location":"partie1/chapitre_02_repository/#inconvenients","title":"Inconv\u00e9nients","text":"<ul> <li>Complexit\u00e9 additionnelle -- On introduit une couche d'abstraction suppl\u00e9mentaire (interface + impl\u00e9mentation + mapping ORM). Pour une application tr\u00e8s simple, c'est du sur-engineering.</li> <li>Courbe d'apprentissage -- Le classical mapping de SQLAlchemy est moins intuitif que l'approche d\u00e9clarative. Il faut comprendre le concept de ports and adapters pour saisir la motivation.</li> <li>Code suppl\u00e9mentaire -- Le fake doit \u00eatre maintenu en parall\u00e8le de l'impl\u00e9mentation r\u00e9elle. Si l'interface \u00e9volue, il faut mettre \u00e0 jour les deux.</li> </ul> <p>R\u00e8gle d'or</p> <p>Le pattern Repository n'est pas n\u00e9cessaire pour toutes les applications. Il prend tout son sens quand la logique m\u00e9tier est suffisamment complexe pour m\u00e9riter d'\u00eatre isol\u00e9e et test\u00e9e ind\u00e9pendamment de la base de donn\u00e9es.</p> <p>Prochain chapitre : Chapitre 3 -- Couplage et abstractions, o\u00f9 nous approfondirons le principe d'inversion des d\u00e9pendances et les strat\u00e9gies pour introduire des abstractions pertinentes.</p>"},{"location":"partie1/chapitre_03_abstractions/","title":"Chapitre 3 -- Couplage et abstractions","text":"<p>Avant / Apr\u00e8s</p> Avant Service Layer d\u00e9pend de SQLAlchemy et <code>smtplib</code> Apr\u00e8s Service Layer d\u00e9pend d'abstractions (ports)"},{"location":"partie1/chapitre_03_abstractions/#le-probleme-du-couplage","title":"Le probl\u00e8me du couplage","text":"<p>Imaginez un syst\u00e8me d'allocation de stock o\u00f9 chaque composant conna\u00eet directement tous les autres. Le service layer appelle SQLAlchemy. Les handlers envoient des emails via <code>smtplib</code>. Les tests doivent d\u00e9marrer une base de donn\u00e9es et un serveur SMTP pour fonctionner.</p> <p>Quand tout d\u00e9pend de tout, modifier un composant revient \u00e0 tirer sur un fil : tout le reste se d\u00e9tricote.</p> <pre><code>   Couplage direct : chaque module d\u00e9pend des d\u00e9tails des autres.\n\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502  Service      \u2502\u2500\u2500\u2500\u2500&gt;\u2502  SQLAlchemy   \u2502\u2500\u2500\u2500\u2500&gt;\u2502  PostgreSQL   \u2502\n   \u2502  Layer        \u2502     \u2502  (ORM)        \u2502     \u2502  (BDD)        \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502\n          \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502  smtplib      \u2502\u2500\u2500\u2500\u2500&gt;\u2502  Serveur SMTP \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n   Probl\u00e8me : pour tester le Service Layer, il faut PostgreSQL ET un serveur SMTP.\n   Pour changer de BDD, il faut modifier le Service Layer.\n</code></pre> <p>Ce sch\u00e9ma illustre le couplage direct : les modules de haut niveau (la logique d'orchestration) d\u00e9pendent des modules de bas niveau (la base de donn\u00e9es, le serveur de mail). Changer un d\u00e9tail d'infrastructure force \u00e0 modifier le code m\u00e9tier.</p> <p>Maintenant, comparons avec une architecture o\u00f9 l'on a introduit des abstractions :</p> <pre><code>   D\u00e9pendances invers\u00e9es : tout pointe vers les abstractions.\n\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502  Service      \u2502\u2500\u2500\u2500\u2500&gt;\u2502  AbstractRepository \u2502&lt;\u2500\u2500\u2500\u2500\u2502 SqlAlchemy    \u2502\n   \u2502  Layer        \u2502     \u2502  (port)             \u2502     \u2502 Repository    \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502\n          \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502  AbstractNotifications  \u2502&lt;\u2500\u2502 Email         \u2502\n                         \u2502  (port)                 \u2502  \u2502 Notifications \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n   Le Service Layer ne conna\u00eet QUE les abstractions.\n   Les impl\u00e9mentations concr\u00e8tes aussi.\n   Personne ne d\u00e9pend des d\u00e9tails.\n</code></pre> <p>Les fl\u00e8ches ont chang\u00e9 de direction. Le Service Layer ne conna\u00eet plus SQLAlchemy ni <code>smtplib</code>. Il ne conna\u00eet que des abstractions. C'est le coeur du Dependency Inversion Principle.</p>"},{"location":"partie1/chapitre_03_abstractions/#le-dependency-inversion-principle-dip","title":"Le Dependency Inversion Principle (DIP)","text":"<p>Le DIP, cinqui\u00e8me principe SOLID, s'\u00e9nonce ainsi :</p> <p>Dependency Inversion Principle</p> <p>Les modules de haut niveau ne doivent pas d\u00e9pendre des modules de bas niveau. Les deux doivent d\u00e9pendre d'abstractions. Les abstractions ne doivent pas d\u00e9pendre des d\u00e9tails. Les d\u00e9tails doivent d\u00e9pendre des abstractions.</p> <p>En pratique, cela signifie que notre code m\u00e9tier ne doit jamais importer <code>sqlalchemy</code> ou <code>smtplib</code>. Il travaille avec des interfaces abstraites, et ce sont les couches d'infrastructure qui fournissent les impl\u00e9mentations concr\u00e8tes.</p>"},{"location":"partie1/chapitre_03_abstractions/#illustration-avec-le-repository","title":"Illustration avec le Repository","text":"<p>Voici comment notre projet applique ce principe. D'abord, l'abstraction -- le port -- qui d\u00e9finit le contrat :</p> <pre><code># src/allocation/adapters/repository.py\n\nclass AbstractRepository(abc.ABC):\n    \"\"\"\n    Interface abstraite du repository.\n    D\u00e9finit le contrat que tout repository doit respecter.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.seen: set[model.Produit] = set()\n\n    def add(self, produit: model.Produit) -&gt; None:\n        \"\"\"Ajoute un produit au repository et le marque comme vu.\"\"\"\n        self._add(produit)\n        self.seen.add(produit)\n\n    def get(self, sku: str) -&gt; model.Produit | None:\n        \"\"\"R\u00e9cup\u00e8re un produit par son SKU et le marque comme vu.\"\"\"\n        produit = self._get(sku)\n        if produit:\n            self.seen.add(produit)\n        return produit\n\n    @abc.abstractmethod\n    def _add(self, produit: model.Produit) -&gt; None:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _get(self, sku: str) -&gt; model.Produit | None:\n        raise NotImplementedError\n</code></pre> <p>Remarquez la structure : les m\u00e9thodes publiques <code>add</code> et <code>get</code> contiennent la logique commune (le tracking via <code>self.seen</code>), tandis que les m\u00e9thodes pr\u00e9fix\u00e9es par <code>_</code> sont les points d'extension que chaque impl\u00e9mentation concr\u00e8te doit fournir. C'est le Template Method pattern au service du DIP.</p> <p>Ensuite, l'impl\u00e9mentation concr\u00e8te -- l'adapter -- qui sait parler \u00e0 SQLAlchemy :</p> <pre><code># src/allocation/adapters/repository.py\n\nclass SqlAlchemyRepository(AbstractRepository):\n    \"\"\"Impl\u00e9mentation concr\u00e8te du repository avec SQLAlchemy.\"\"\"\n\n    def __init__(self, session: Session):\n        super().__init__()\n        self.session = session\n\n    def _add(self, produit: model.Produit) -&gt; None:\n        self.session.add(produit)\n\n    def _get(self, sku: str) -&gt; model.Produit | None:\n        return (\n            self.session.query(model.Produit)\n            .filter_by(sku=sku)\n            .first()\n        )\n</code></pre> <p>Le Service Layer re\u00e7oit un <code>AbstractRepository</code>. Il ne sait pas -- et n'a pas besoin de savoir -- si derri\u00e8re se cache PostgreSQL, un fichier CSV, ou un simple dictionnaire en m\u00e9moire.</p>"},{"location":"partie1/chapitre_03_abstractions/#illustration-avec-les-notifications","title":"Illustration avec les notifications","text":"<p>Le m\u00eame pattern s'applique \u00e0 d'autres pr\u00e9occupations d'infrastructure. Pour les notifications :</p> <pre><code># src/allocation/adapters/notifications.py\n\nclass AbstractNotifications(abc.ABC):\n    \"\"\"Interface abstraite pour les notifications.\"\"\"\n\n    @abc.abstractmethod\n    def send(self, destination: str, message: str) -&gt; None:\n        raise NotImplementedError\n\n\nclass EmailNotifications(AbstractNotifications):\n    \"\"\"Impl\u00e9mentation concr\u00e8te envoyant des emails via SMTP.\"\"\"\n\n    def __init__(self, smtp_host: str = \"localhost\", smtp_port: int = 587):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n\n    def send(self, destination: str, message: str) -&gt; None:\n        msg = f\"Subject: Notification d'allocation\\n\\n{message}\"\n        with smtplib.SMTP(self.smtp_host, self.smtp_port) as smtp:\n            smtp.sendmail(\n                from_addr=\"allocations@example.com\",\n                to_addrs=[destination],\n                msg=msg,\n            )\n</code></pre> <p>L'abstraction <code>AbstractNotifications</code> d\u00e9finit un contrat minimal : une seule m\u00e9thode <code>send</code>. L'impl\u00e9mentation <code>EmailNotifications</code> encapsule toute la m\u00e9canique SMTP. Demain, si l'on veut envoyer des SMS ou des notifications Slack, il suffit de cr\u00e9er un nouvel adapter sans toucher au code m\u00e9tier.</p>"},{"location":"partie1/chapitre_03_abstractions/#ports-and-adapters-architecture-hexagonale","title":"Ports and Adapters (architecture hexagonale)","text":"<p>Le pattern que nous venons de voir porte un nom : Ports and Adapters, aussi appel\u00e9 architecture hexagonale (Alistair Cockburn, 2005).</p> <p>L'id\u00e9e est simple :</p> <ul> <li>Le domaine est au centre. Il ne d\u00e9pend de rien d'ext\u00e9rieur.</li> <li>Les ports sont les interfaces que le domaine expose ou requiert   (par exemple <code>AbstractRepository</code>, <code>AbstractNotifications</code>).</li> <li>Les adapters sont les impl\u00e9mentations concr\u00e8tes qui connectent le domaine   au monde ext\u00e9rieur (base de donn\u00e9es, API, email, etc.).</li> </ul> <pre><code>                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 API Web  \u2502\u2500\u2500\u2500\u253c\u2500\u2500&gt;\u2502                 \u2502   \u2502   \u2502              \u2502\n         \u2502 (adapter)\u2502   \u2502   \u2502   Domaine        \u2502   \u2502&lt;\u2500\u2500\u2502  PostgreSQL  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502   \u2502                 \u2502   \u2502   \u2502  (adapter)   \u2502\n                        \u2502   \u2502   LigneDeCommande\u2502   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   \u2502   Lot            \u2502   \u2502\n         \u2502 CLI      \u2502\u2500\u2500\u2500\u253c\u2500\u2500&gt;\u2502   Produit        \u2502   \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 (adapter)\u2502   \u2502   \u2502   allouer()      \u2502   \u2502&lt;\u2500\u2500\u2502  SMTP        \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502   \u2502                 \u2502   \u2502   \u2502  (adapter)   \u2502\n                        \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502         ports           \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Dans notre projet, cela se traduit par :</p> Concept Dans notre code Domaine <code>allocation.domain.model</code> Port (persistance) <code>AbstractRepository</code> Port (notifications) <code>AbstractNotifications</code> Adapter (BDD) <code>SqlAlchemyRepository</code> Adapter (email) <code>EmailNotifications</code> <p>Le domaine d\u00e9finit les ports : \"j'ai besoin d'un m\u00e9canisme pour stocker et r\u00e9cup\u00e9rer des produits\" et \"j'ai besoin d'un m\u00e9canisme pour envoyer des notifications\". Ce sont des interfaces, pas des impl\u00e9mentations. Les adapters fournissent la r\u00e9alit\u00e9 concr\u00e8te derri\u00e8re ces interfaces.</p> <p>L'avantage fondamental : on peut remplacer n'importe quel adapter sans toucher au domaine ni \u00e0 la logique d'orchestration.</p>"},{"location":"partie1/chapitre_03_abstractions/#quand-abstraire-quand-ne-pas-abstraire","title":"Quand abstraire, quand ne pas abstraire","text":"<p>L'abstraction est un outil puissant, mais elle a un co\u00fbt : l'indirection. Chaque couche d'abstraction ajoute un fichier, une interface, un niveau suppl\u00e9mentaire \u00e0 comprendre pour le d\u00e9veloppeur qui lit le code.</p> <p>Le pi\u00e8ge de l'abstraction pr\u00e9matur\u00e9e</p> <p>Abstraire trop t\u00f4t, c'est construire un pont avant de savoir o\u00f9 passe la rivi\u00e8re. On risque de cr\u00e9er des abstractions inutiles qui compliquent le code sans apporter de valeur.</p>"},{"location":"partie1/chapitre_03_abstractions/#la-regle-des-3","title":"La r\u00e8gle des 3","text":"<p>Une heuristique utile est la r\u00e8gle des 3 :</p> <ol> <li> <p>3 impl\u00e9mentations : Si vous n'avez qu'une seule impl\u00e9mentation (par    exemple, un seul type de base de donn\u00e9es), l'abstraction est peut-\u00eatre    pr\u00e9matur\u00e9e. Quand vous en avez 3 (SQL, fichier, in-memory pour les tests),    le pattern devient \u00e9vident.</p> </li> <li> <p>3 raisons de changer : Si un composant pourrait changer pour 3 raisons    diff\u00e9rentes (changer de BDD, am\u00e9liorer les performances, supporter un    nouveau format), c'est un bon candidat pour une abstraction.</p> </li> </ol> <p>Dans notre cas, le <code>Repository</code> a au moins deux impl\u00e9mentations d\u00e8s le d\u00e9part :</p> <ul> <li><code>SqlAlchemyRepository</code> pour la production</li> <li><code>FakeRepository</code> pour les tests</li> </ul> <p>Et on pourrait facilement imaginer un <code>RedisRepository</code> pour du cache, ou un <code>FileRepository</code> pour de l'export. L'abstraction se justifie pleinement.</p>"},{"location":"partie1/chapitre_03_abstractions/#quand-ne-pas-abstraire","title":"Quand NE PAS abstraire","text":"<p>Ne cr\u00e9ez pas d'abstraction si :</p> <ul> <li>Il n'y a qu'une seule impl\u00e9mentation et aucune raison pr\u00e9visible d'en avoir   une deuxi\u00e8me.</li> <li>Le code est si simple qu'une abstraction le rendrait plus difficile \u00e0 lire.</li> <li>Vous le faites \"au cas o\u00f9\". Le YAGNI (You Ain't Gonna Need It) est   un contrepoids sain au DIP.</li> </ul> <p>Le bon r\u00e9flexe : commencez concret, puis extrayez l'abstraction quand le besoin se manifeste. Le refactoring est moins co\u00fbteux qu'une mauvaise abstraction.</p>"},{"location":"partie1/chapitre_03_abstractions/#edge-to-edge-testing-avec-des-fakes","title":"Edge-to-edge testing avec des fakes","text":"<p>L'un des b\u00e9n\u00e9fices les plus imm\u00e9diats de l'architecture Ports and Adapters est la possibilit\u00e9 de faire du edge-to-edge testing : tester de bout en bout sans infrastructure r\u00e9elle, en rempla\u00e7ant les adapters par des fakes.</p>"},{"location":"partie1/chapitre_03_abstractions/#le-fakerepository","title":"Le FakeRepository","text":"<p>On r\u00e9utilise le <code>FakeRepository</code> d\u00e9fini au chapitre 2 : une impl\u00e9mentation en m\u00e9moire qui stocke les produits dans un simple <code>set</code> Python, respectant exactement le m\u00eame contrat que <code>SqlAlchemyRepository</code>. Pas de base de donn\u00e9es, pas de connexion, pas de migration. Les tests s'ex\u00e9cutent en millisecondes.</p>"},{"location":"partie1/chapitre_03_abstractions/#le-fakenotifications","title":"Le FakeNotifications","text":"<p>Le m\u00eame principe s'applique aux notifications. Le <code>FakeNotifications</code> stocke les appels dans une liste au lieu d'envoyer de vrais emails :</p> <pre><code>class FakeNotifications(AbstractNotifications):\n    def __init__(self):\n        self.envoy\u00e9es: list[tuple[str, str]] = []\n\n    def send(self, destination: str, message: str) -&gt; None:\n        self.envoy\u00e9es.append((destination, message))\n</code></pre> <p>Dans les tests, on peut alors v\u00e9rifier :</p> <pre><code># Exemple d'assertion dans un test\nassert notifications.envoy\u00e9es == [\n    (\"stock@example.com\", \"Le SKU SMALL-TABLE est en rupture de stock\")\n]\n</code></pre>"},{"location":"partie1/chapitre_03_abstractions/#pourquoi-cest-puissant","title":"Pourquoi c'est puissant","text":"<p>Le edge-to-edge testing combine les avantages des tests unitaires et des tests d'int\u00e9gration :</p> Aspect Tests unitaires Tests d'int\u00e9gration Edge-to-edge (fakes) Vitesse Rapide Lent Rapide Couverture de code Faible \u00c9lev\u00e9e \u00c9lev\u00e9e Fragilit\u00e9 Faible \u00c9lev\u00e9e Faible Besoin d'infrastructure Non Oui Non <p>Les tests avec fakes traversent toute la pile applicative -- du handler jusqu'au repository -- mais sans jamais toucher \u00e0 une vraie base de donn\u00e9es. On teste le comportement r\u00e9el du syst\u00e8me, pas un mock fragile qui simule un sc\u00e9nario id\u00e9alis\u00e9.</p>"},{"location":"partie1/chapitre_03_abstractions/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Identifier les abstractions manquantes</p> <p>Imaginez que votre syst\u00e8me doit g\u00e9n\u00e9rer des fichiers PDF pour les bons de livraison. Dessinez le port (interface abstraite) et deux adapters (un r\u00e9el avec une biblioth\u00e8que PDF, un fake pour les tests). Quels param\u00e8tres la m\u00e9thode du port prend-elle ?</p> <p>Exercice 2 -- Mesurer le couplage</p> <p>Listez tous les <code>import</code> de <code>handlers.py</code>. Combien pointent vers le domaine ? Combien vers l'infrastructure ? Si un import pointe vers l'infrastructure, est-ce un probl\u00e8me ? Pourquoi ?</p> <p>Exercice 3 -- YAGNI vs DIP</p> <p>Votre application n'envoie des emails que via SMTP et n'aura jamais besoin d'autre chose. Faut-il quand m\u00eame cr\u00e9er une <code>AbstractNotifications</code> ? Argumentez pour et contre.</p>"},{"location":"partie1/chapitre_03_abstractions/#resume","title":"R\u00e9sum\u00e9","text":"<p>Ce chapitre a introduit les concepts de couplage et d'abstraction, et montr\u00e9 comment le Dependency Inversion Principle et l'architecture Ports and Adapters permettent de construire un syst\u00e8me d\u00e9coupl\u00e9 et testable.</p> Concept D\u00e9finition B\u00e9n\u00e9fice Couplage Degr\u00e9 de d\u00e9pendance entre composants Le r\u00e9duire rend le syst\u00e8me plus flexible DIP D\u00e9pendre d'abstractions, pas de d\u00e9tails concrets Le code m\u00e9tier est isol\u00e9 de l'infrastructure Port Interface abstraite d\u00e9finissant un contrat (<code>AbstractRepository</code>) D\u00e9finit ce dont le domaine a besoin sans dire comment Adapter Impl\u00e9mentation concr\u00e8te d'un port (<code>SqlAlchemyRepository</code>) Encapsule les d\u00e9tails d'infrastructure Fake Impl\u00e9mentation simple d'un port pour les tests (<code>FakeRepository</code>) Tests rapides sans infrastructure Edge-to-edge testing Tester toute la pile avec des fakes Couverture large, ex\u00e9cution rapide <p>\u00c0 retenir</p> <ul> <li>Le couplage direct entre composants rend le syst\u00e8me fragile et difficile \u00e0 tester.</li> <li>Le DIP inverse les d\u00e9pendances : tout le monde d\u00e9pend des abstractions.</li> <li>L'architecture Ports and Adapters place le domaine au centre et l'infrastructure \u00e0 la p\u00e9riph\u00e9rie.</li> <li>N'abstraire que quand c'est justifi\u00e9 : la r\u00e8gle des 3 est un bon guide.</li> <li>Les fakes permettent un edge-to-edge testing rapide et fiable.</li> </ul> <p>Dans le chapitre suivant, nous verrons comment la Service Layer orchestre les cas d'utilisation en s'appuyant sur ces abstractions.</p>"},{"location":"partie1/chapitre_04_service_layer/","title":"Chapitre 4 -- La Service Layer","text":"<p>Avant / Apr\u00e8s</p> Avant Toute la logique dans les routes Flask Apr\u00e8s Handlers fins orchestrent, Flask ne fait que traduire HTTP <p>Ce que vous allez apprendre</p> <ul> <li>Pourquoi la logique d'orchestration n'a pas sa place dans les routes Flask</li> <li>Ce qu'est une Service Layer et ce qu'elle contient (et ne contient pas)</li> <li>Comment \u00e9crire des handlers fins et proc\u00e9duraux</li> <li>Comment transformer Flask en thin adapter qui ne fait que traduire HTTP</li> <li>Comment tester l'orchestration sans framework web ni base de donn\u00e9es</li> </ul>"},{"location":"partie1/chapitre_04_service_layer/#le-probleme-des-routes-flask-qui-grossissent","title":"Le probl\u00e8me : des routes Flask qui grossissent","text":"<p>Dans les chapitres pr\u00e9c\u00e9dents, nous avons construit un mod\u00e8le de domaine (<code>Lot</code>, <code>LigneDeCommande</code>, <code>allouer()</code>) et un Repository pour persister nos objets dans un conteneur <code>Produit</code>. La logique d'allocation que nous avions \u00e9crite comme fonction libre au chapitre 1 est maintenant une m\u00e9thode de <code>Produit</code> -- c'est lui qui poss\u00e8de les lots et qui sait comment les trier. Imaginons maintenant une premi\u00e8re route Flask pour allouer du stock :</p> <pre><code># Version na\u00efve -- toute la logique dans la route\n@app.route(\"/allocate\", methods=[\"POST\"])\ndef allocate_endpoint():\n    data = request.json\n    # 1. Ouvrir une session / transaction\n    session = get_session()\n    # 2. R\u00e9cup\u00e9rer l'agr\u00e9gat\n    produit = repo.get(data[\"sku\"])\n    if produit is None:\n        return jsonify({\"message\": \"SKU inconnu\"}), 400\n    # 3. Construire le value object\n    ligne = LigneDeCommande(data[\"id_commande\"], data[\"sku\"], data[\"quantit\u00e9\"])\n    # 4. Appeler la logique m\u00e9tier\n    r\u00e9f_lot = produit.allouer(ligne)\n    # 5. Committer\n    session.commit()\n    return jsonify({\"r\u00e9f_lot\": r\u00e9f_lot}), 201\n</code></pre> <p>Ce code fonctionne, mais il pose plusieurs probl\u00e8mes :</p> <p>Duplication. Si demain on ajoute une CLI, un worker Celery ou un consumer Redis, il faudra recopier toute cette s\u00e9quence (r\u00e9cup\u00e9rer le produit, construire la ligne, allouer, committer). Chaque point d'entr\u00e9e r\u00e9impl\u00e9mentera le m\u00eame workflow.</p> <p>Testabilit\u00e9. Pour tester cette logique, on doit d\u00e9marrer Flask, envoyer de vraies requ\u00eates HTTP et souvent brancher une base de donn\u00e9es. Les tests deviennent lents et fragiles.</p> <p>Responsabilit\u00e9 mal plac\u00e9e. Flask est un framework de pr\u00e9sentation. Son r\u00f4le est de convertir des requ\u00eates HTTP en appels applicatifs, pas d'orchestrer un workflow m\u00e9tier.</p>"},{"location":"partie1/chapitre_04_service_layer/#la-service-layer-une-couche-dorchestration","title":"La Service Layer : une couche d'orchestration","text":"<p>La Service Layer est une couche mince qui se place entre les points d'entr\u00e9e (Flask, CLI...) et le mod\u00e8le de domaine. Son r\u00f4le est pr\u00e9cis :</p> <ol> <li>R\u00e9cup\u00e9rer les objets n\u00e9cessaires via le Repository</li> <li>Appeler les m\u00e9thodes du domaine</li> <li>Committer la transaction</li> </ol> <p>Elle ne contient pas de logique m\u00e9tier. La logique m\u00e9tier reste dans le mod\u00e8le de domaine (c'est <code>Produit.allouer()</code> qui d\u00e9cide quel lot choisir, pas le handler). La Service Layer se contente de coordonner.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Entrypoints                      \u2502\n\u2502         (Flask, CLI, Consumer...)             \u2502\n\u2502  Convertit le protocole externe en commands   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Service Layer                      \u2502\n\u2502         (handlers.py)                         \u2502\n\u2502  Orchestre : UoW \u2192 Repository \u2192 Domaine       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Mod\u00e8le de domaine                    \u2502\n\u2502  (Produit, Lot, LigneDeCommande)              \u2502\n\u2502  Contient TOUTE la logique m\u00e9tier             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"partie1/chapitre_04_service_layer/#les-handlers-fins-et-proceduraux","title":"Les handlers : fins et proc\u00e9duraux","text":"<p>Nos handlers vivent dans <code>src/allocation/service_layer/handlers.py</code>. Chaque handler prend une command (un simple dataclass d\u00e9crivant l'intention) et un Unit of Work, puis orchestre le workflow en quelques lignes.</p>"},{"location":"partie1/chapitre_04_service_layer/#ajouter_lot-creer-un-lot-de-stock","title":"<code>ajouter_lot</code> -- cr\u00e9er un lot de stock","text":"<pre><code>def ajouter_lot(\n    cmd: commands.Cr\u00e9erLot,\n    uow: AbstractUnitOfWork,\n) -&gt; None:\n    with uow:\n        produit = uow.produits.get(sku=cmd.sku)\n        if produit is None:\n            produit = model.Produit(sku=cmd.sku, lots=[])\n            uow.produits.add(produit)\n        produit.lots.append(\n            model.Lot(r\u00e9f=cmd.r\u00e9f, sku=cmd.sku, quantit\u00e9=cmd.quantit\u00e9, eta=cmd.eta)\n        )\n        uow.commit()\n</code></pre> <p>Le handler est proc\u00e9dural : il ouvre le Unit of Work, r\u00e9cup\u00e8re ou cr\u00e9e le produit, ajoute le lot, puis committe. Pas de boucle complexe, pas de logique conditionnelle m\u00e9tier.</p>"},{"location":"partie1/chapitre_04_service_layer/#allouer-allouer-une-ligne-de-commande","title":"<code>allouer</code> -- allouer une ligne de commande","text":"<pre><code>def allouer(\n    cmd: commands.Allouer,\n    uow: AbstractUnitOfWork,\n) -&gt; str:\n    ligne = model.LigneDeCommande(\n        id_commande=cmd.id_commande, sku=cmd.sku, quantit\u00e9=cmd.quantit\u00e9\n    )\n    with uow:\n        produit = uow.produits.get(sku=cmd.sku)\n        if produit is None:\n            raise SkuInconnu(f\"SKU inconnu : {cmd.sku}\")\n        r\u00e9f_lot = produit.allouer(ligne)\n        uow.commit()\n    return r\u00e9f_lot\n</code></pre> <p>Observez que toute la logique d'allocation (trier les lots par ETA, v\u00e9rifier la quantit\u00e9 disponible, choisir le meilleur lot) est dans <code>produit.allouer()</code>. Le handler ne fait que pr\u00e9parer les donn\u00e9es et d\u00e9clencher l'appel.</p>"},{"location":"partie1/chapitre_04_service_layer/#la-ligne-de-demarcation","title":"La ligne de d\u00e9marcation","text":"<p>Un bon test pour savoir si la logique est au bon endroit : si vous enlevez le handler et appelez directement <code>produit.allouer()</code> dans un test unitaire, la r\u00e8gle m\u00e9tier fonctionne-t-elle toujours ? Si oui, la logique est bien dans le domaine. Le handler ne fait que du \"plumbing\".</p>"},{"location":"partie1/chapitre_04_service_layer/#flask-comme-thin-adapter","title":"Flask comme thin adapter","text":"<p>Maintenant que la Service Layer existe, Flask n'a plus qu'un seul r\u00f4le : traduire le protocole HTTP en objets que la couche service comprend, puis convertir le r\u00e9sultat en r\u00e9ponse HTTP.</p> <p>Voici le code r\u00e9el de <code>src/allocation/entrypoints/flask_app.py</code> :</p> <pre><code>app = Flask(__name__)\nbus = bootstrap.bootstrap()\n\n\n@app.route(\"/add_batch\", methods=[\"POST\"])\ndef add_batch_endpoint():\n    data = request.json\n    eta = data.get(\"eta\")\n    if eta is not None:\n        eta = datetime.fromisoformat(eta).date()\n\n    cmd = commands.Cr\u00e9erLot(\n        r\u00e9f=data[\"ref\"],\n        sku=data[\"sku\"],\n        quantit\u00e9=data[\"qty\"],\n        eta=eta,\n    )\n    bus.handle(cmd)\n    return \"OK\", 201\n\n\n@app.route(\"/allocate\", methods=[\"POST\"])\ndef allocate_endpoint():\n    data = request.json\n    try:\n        cmd = commands.Allouer(\n            id_commande=data[\"orderid\"],\n            sku=data[\"sku\"],\n            quantit\u00e9=data[\"qty\"],\n        )\n        results = bus.handle(cmd)\n        r\u00e9f_lot = results.pop(0)\n    except handlers.SkuInconnu as e:\n        return jsonify({\"message\": str(e)}), 400\n\n    return jsonify({\"batchref\": r\u00e9f_lot}), 201\n</code></pre> <p>Chaque endpoint suit la m\u00eame structure en trois temps :</p> <ol> <li>Extraire les donn\u00e9es de la requ\u00eate HTTP (<code>request.json</code>)</li> <li>Construire une command (un dataclass immuable)</li> <li>D\u00e9l\u00e9guer au bus (qui dispatch vers le handler)</li> </ol> <p>Il n'y a aucune logique m\u00e9tier dans ces fonctions. Pas de <code>if</code> sur la disponibilit\u00e9 du stock, pas de tri des lots, pas d'acc\u00e8s direct au Repository. Flask ne sait m\u00eame pas que des lots existent.</p> <p>Adaptateurs et ports</p> <p>Flask est un adapter au sens de l'architecture hexagonale. Il adapte le port HTTP vers l'interface de la Service Layer. Si demain vous remplacez Flask par FastAPI, seul cet adaptateur change -- ni les handlers, ni le domaine ne sont touch\u00e9s.</p>"},{"location":"partie1/chapitre_04_service_layer/#testabilite-des-fakes-plutot-que-des-mocks","title":"Testabilit\u00e9 : des fakes plut\u00f4t que des mocks","text":"<p>L'un des gains majeurs de la Service Layer est la testabilit\u00e9. On peut tester toute l'orchestration sans d\u00e9marrer Flask et sans toucher \u00e0 la base de donn\u00e9es, en rempla\u00e7ant les adaptateurs concrets par des fakes.</p>"},{"location":"partie1/chapitre_04_service_layer/#fakerepository-et-fakeunitofwork","title":"FakeRepository et FakeUnitOfWork","text":"<p>On utilise le <code>FakeRepository</code> d\u00e9fini au chapitre 2 et un <code>FakeUnitOfWork</code> qui l'encapsule (d\u00e9taill\u00e9 au chapitre 6). Ces fakes sont des impl\u00e9mentations en m\u00e9moire des abstractions : le <code>FakeRepository</code> stocke les produits dans un <code>set</code> Python, et le <code>FakeUnitOfWork</code> trace les commits via un bool\u00e9en <code>self.committed</code> sans toucher \u00e0 aucune base de donn\u00e9es.</p>"},{"location":"partie1/chapitre_04_service_layer/#les-tests-des-handlers","title":"Les tests des handlers","text":"<p>Avec ces fakes, tester un handler est direct et rapide :</p> <pre><code>class TestAjouterLot:\n    def test_ajouter_lot_pour_nouveau_produit(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"l1\", \"COUSSIN-CARRE\", 100, None))\n\n        assert bus.uow.produits.get(\"COUSSIN-CARRE\") is not None\n        assert bus.uow.committed\n\n    def test_ajouter_lot_pour_produit_existant(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"l1\", \"LAMPE-RONDE\", 100, None))\n        bus.handle(commands.Cr\u00e9erLot(\"l2\", \"LAMPE-RONDE\", 99, None))\n\n        produit = bus.uow.produits.get(\"LAMPE-RONDE\")\n        assert len(produit.lots) == 2\n\n\nclass TestAllouer:\n    def test_allouer_retourne_ref_lot(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"l1\", \"CHAISE-COMFY\", 100, None))\n        results = bus.handle(commands.Allouer(\"c1\", \"CHAISE-COMFY\", 10))\n\n        assert results.pop(0) == \"l1\"\n\n    def test_allouer_erreur_pour_sku_inconnu(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"l1\", \"VRAI-SKU\", 100, None))\n\n        with pytest.raises(handlers.SkuInconnu, match=\"SKU-INEXISTANT\"):\n            bus.handle(commands.Allouer(\"c1\", \"SKU-INEXISTANT\", 10))\n</code></pre> <p>Remarquez ce que ces tests ne font pas :</p> <ul> <li>Pas de <code>app.test_client()</code> -- aucune requ\u00eate HTTP</li> <li>Pas de <code>session</code> SQLAlchemy -- aucune base de donn\u00e9es</li> <li>Pas de <code>mock.patch</code> -- on injecte de vrais objets (les fakes)</li> </ul> <p>Les tests sont rapides (millisecondes), isol\u00e9s et lisibles. Ils v\u00e9rifient le comportement m\u00e9tier (est-ce que le lot est bien cr\u00e9\u00e9 ? est-ce que l'allocation retourne la bonne r\u00e9f\u00e9rence ?) sans \u00eatre coupl\u00e9s \u00e0 aucune infrastructure.</p>"},{"location":"partie1/chapitre_04_service_layer/#et-les-tests-de-lapi","title":"Et les tests de l'API ?","text":"<p>Les tests de l'API Flask deviennent des tests d'int\u00e9gration l\u00e9gers : ils v\u00e9rifient uniquement que Flask parse correctement le JSON, appelle le bon handler, et retourne le bon code HTTP. La logique m\u00e9tier, elle, est d\u00e9j\u00e0 couverte par les tests unitaires des handlers.</p>"},{"location":"partie1/chapitre_04_service_layer/#la-pyramide-des-tests","title":"La pyramide des tests","text":"<p>Avec la Service Layer en place, la r\u00e9partition des tests \u00e9volue :</p> Couche Type de test Vitesse Ce qu'on teste Domaine Unitaire Tr\u00e8s rapide R\u00e8gles m\u00e9tier pures Service Layer Unitaire (avec fakes) Rapide Orchestration, workflows Entrypoints Int\u00e9gration Plus lent Traduction HTTP, s\u00e9rialisation End-to-end Syst\u00e8me Lent Le syst\u00e8me complet <p>La majorit\u00e9 des tests se concentre sur les deux premi\u00e8res couches. Les tests d'int\u00e9gration de l'API sont peu nombreux car ils ne v\u00e9rifient que le \"c\u00e2blage\".</p>"},{"location":"partie1/chapitre_04_service_layer/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Nouvelle command</p> <p>Ajoutez un handler <code>d\u00e9sallouer</code> qui prend une command <code>D\u00e9sallouer(id_commande, sku, quantit\u00e9)</code> et retire une allocation. \u00c9crivez le test correspondant avec le <code>FakeUnitOfWork</code>. O\u00f9 devrait vivre la logique de d\u00e9sallocation ?</p> <p>Exercice 2 -- Handler trop gros</p> <p>Un coll\u00e8gue \u00e9crit un handler de 30 lignes qui v\u00e9rifie le stock disponible, applique des promotions, calcule les frais de port et envoie un email. Quels principes sont viol\u00e9s ? Comment le refactorer ?</p> <p>Exercice 3 -- Ajouter un endpoint CLI</p> <p>\u00c9crivez un point d'entr\u00e9e CLI (avec <code>argparse</code> ou <code>click</code>) qui appelle <code>bus.handle(commands.Allouer(...))</code>. V\u00e9rifiez que vous n'avez rien chang\u00e9 dans les handlers ni le domaine.</p>"},{"location":"partie1/chapitre_04_service_layer/#resume","title":"R\u00e9sum\u00e9","text":"<p>La Service Layer est le ciment entre le monde ext\u00e9rieur et le mod\u00e8le de domaine. Elle applique le principe de responsabilit\u00e9 unique \u00e0 l'\u00e9chelle des couches :</p> Couche Responsabilit\u00e9 Exemple Entrypoints Traduire un protocole externe en commands Flask parse le JSON, construit <code>commands.Allouer</code>, d\u00e9l\u00e8gue au bus Service Layer Orchestrer le workflow applicatif Le handler ouvre le UoW, r\u00e9cup\u00e8re le produit, appelle <code>produit.allouer()</code>, committe Domaine Impl\u00e9menter les r\u00e8gles m\u00e9tier <code>Produit.allouer()</code> trie les lots, v\u00e9rifie la disponibilit\u00e9, choisit le lot <p>Quelques principes \u00e0 retenir :</p> <ul> <li>Les handlers sont fins. Quelques lignes de code proc\u00e9dural. Si un handler d\u00e9passe 15 lignes, de la logique m\u00e9tier s'est probablement gliss\u00e9e au mauvais endroit.</li> <li>Le domaine ne sait rien de la persistance. Il ne conna\u00eet ni le Repository, ni le Unit of Work. C'est le handler qui fait le lien.</li> <li>Les entrypoints ne savent rien du domaine. Flask ne manipule jamais directement un <code>Produit</code> ou un <code>Lot</code>. Il envoie des commands et re\u00e7oit des r\u00e9sultats.</li> <li>Les fakes sont pr\u00e9f\u00e9r\u00e9s aux mocks. En impl\u00e9mentant les interfaces abstraites (<code>AbstractRepository</code>, <code>AbstractUnitOfWork</code>), on obtient des doubles de test fiables et maintenables.</li> </ul> <p>R\u00e8gle d'or</p> <p>Si vous ne savez pas o\u00f9 placer un bout de code, posez-vous la question : \"Est-ce une r\u00e8gle m\u00e9tier (domaine), une \u00e9tape du workflow (service layer), ou une traduction de protocole (entrypoint) ?\"</p> <p>Prochain chapitre : TDD \u00e0 haute et basse vitesse -- comment exploiter cette architecture en couches pour \u00e9crire des tests \u00e0 la fois rapides et fiables.</p>"},{"location":"partie1/chapitre_05_tdd/","title":"Chapitre 5 -- TDD \u00e0 haute et basse vitesse","text":"<p>Avant / Apr\u00e8s</p> Avant Tests unitaires OU tests E2E co\u00fbteux Apr\u00e8s Strat\u00e9gie 2 vitesses : haute (fakes) + basse (domaine pur)"},{"location":"partie1/chapitre_05_tdd/#ou-en-sommes-nous","title":"O\u00f9 en sommes-nous ?","text":"<p>Dans les chapitres pr\u00e9c\u00e9dents, nous avons construit un mod\u00e8le de domaine (<code>Lot</code>, <code>LigneDeCommande</code>, <code>Produit</code>), un Repository pour le persister, et une Service Layer pour orchestrer les cas d'utilisation. Nous avons \u00e9galement \u00e9crit des tests \u00e0 diff\u00e9rents niveaux.</p> <p>Mais une question reste ouverte : \u00e0 quel niveau faut-il \u00e9crire nos tests ? Faut-il tester chaque m\u00e9thode du domaine ? Passer syst\u00e9matiquement par la service layer ? \u00c9crire des tests end-to-end pour tout ?</p> <p>Ce chapitre propose un cadre de r\u00e9flexion pour choisir le bon niveau de test selon la situation, en s'appuyant sur la m\u00e9taphore de la bo\u00eete de vitesses : parfois on roule en haute vitesse (high gear), parfois en basse vitesse (low gear).</p>"},{"location":"partie1/chapitre_05_tdd/#la-pyramide-des-tests","title":"La pyramide des tests","text":"<p>La pyramide des tests est un mod\u00e8le classique qui guide la r\u00e9partition de l'effort de test :</p> <pre><code>         /  E2E  \\           &lt;- Peu, lents, co\u00fbteux\n        /----------\\\n       / Integration \\       &lt;- Nombre moyen\n      /----------------\\\n     /   Unit Tests     \\    &lt;- Nombreux, rapides\n    /____________________\\\n</code></pre> <p>Unit tests forment la base. Ils sont rapides (millisecondes), isol\u00e9s, et nombreux. Ils testent une unit\u00e9 de logique sans d\u00e9pendance externe.</p> <p>Integration tests v\u00e9rifient que les composants fonctionnent ensemble : le repository avec une vraie base de donn\u00e9es, l'API avec un vrai serveur HTTP.</p> <p>End-to-end tests (E2E) traversent tout le syst\u00e8me, du point d'entr\u00e9e HTTP jusqu'\u00e0 la base de donn\u00e9es. Ils sont lents, fragiles, et co\u00fbteux \u00e0 maintenir.</p>"},{"location":"partie1/chapitre_05_tdd/#pourquoi-cette-forme-pyramidale","title":"Pourquoi cette forme pyramidale ?","text":"<p>La raison est \u00e9conomique. Plus un test est haut dans la pyramide :</p> <ul> <li>Plus il est lent \u00e0 ex\u00e9cuter (secondes voire minutes contre millisecondes)</li> <li>Plus il est fragile face aux changements d'infrastructure</li> <li>Plus il est difficile \u00e0 debugger quand il \u00e9choue</li> <li>Plus il couvre de code par test, mais avec moins de pr\u00e9cision</li> </ul> <p>\u00c0 l'inverse, les unit tests du bas de la pyramide sont rapides, stables, et pr\u00e9cis. C'est pourquoi on en veut un maximum.</p> <p>R\u00e8gle empirique</p> <p>Si votre suite de tests met plus de quelques secondes \u00e0 s'ex\u00e9cuter, vous n'avez probablement pas assez de unit tests et trop de tests d'int\u00e9gration.</p>"},{"location":"partie1/chapitre_05_tdd/#tests-haute-vitesse-high-gear","title":"Tests \"haute vitesse\" (high gear)","text":"<p>Les tests high gear sont ceux qui passent par la service layer. Ils ne connaissent pas les d\u00e9tails internes du domaine. Ils envoient des commands et v\u00e9rifient les r\u00e9sultats.</p> <p>C'est notre fichier <code>tests/unit/test_handlers.py</code>, qui utilise les fakes d\u00e9finis aux chapitres pr\u00e9c\u00e9dents : le <code>FakeRepository</code> (chapitre 2) et le <code>FakeUnitOfWork</code> (chapitre 6). Ces fakes remplacent la base de donn\u00e9es par de simples structures en m\u00e9moire. Les tests restent donc rapides (pas d'I/O) tout en traversant la logique r\u00e9elle de la service layer et du domaine.</p>"},{"location":"partie1/chapitre_05_tdd/#des-tests-qui-expriment-le-quoi","title":"Des tests qui expriment le \"quoi\"","text":"<p>Regardons les tests d'allocation :</p> <pre><code>class TestAllouer:\n    def test_allouer_retourne_la_r\u00e9f\u00e9rence_du_lot(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"CHAISE-COMFY\", 100, None))\n        results = bus.handle(commands.Allouer(\"o1\", \"CHAISE-COMFY\", 10))\n\n        assert results.pop(0) == \"b1\"\n\n    def test_allouer_l\u00e8ve_sku_inconnu(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"VRAI-SKU\", 100, None))\n\n        with pytest.raises(handlers.SkuInconnu, match=\"SKU-INEXISTANT\"):\n            bus.handle(commands.Allouer(\"o1\", \"SKU-INEXISTANT\", 10))\n</code></pre> <p>Ces tests ne savent pas comment l'allocation fonctionne en interne. Ils ne connaissent ni <code>Lot</code>, ni <code>LigneDeCommande</code>, ni la strat\u00e9gie de tri. Ils envoient une command <code>Allouer</code> et v\u00e9rifient le r\u00e9sultat.</p> <p>C'est le \"quoi\" : quand j'alloue la commande o1 pour le SKU CHAISE-COMFY, j'obtiens le lot b1.</p>"},{"location":"partie1/chapitre_05_tdd/#tests-de-changement-de-quantite","title":"Tests de changement de quantit\u00e9","text":"<p>Le m\u00eame principe s'applique aux sc\u00e9narios plus complexes :</p> <pre><code>class TestModifierQuantit\u00e9Lot:\n    def test_changes_quantit\u00e9_disponible(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"TAPIS-ADORABLE\", 100, None))\n        [lot] = bus.uow.produits.get(\"TAPIS-ADORABLE\").lots\n        assert lot.quantit\u00e9_disponible == 100\n\n        bus.handle(commands.ModifierQuantit\u00e9Lot(\"b1\", 50))\n        assert lot.quantit\u00e9_disponible == 50\n\n    def test_r\u00e9alloue_si_n\u00e9cessaire(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"TASSE-INDIGO\", 50, None))\n        bus.handle(commands.Allouer(\"o1\", \"TASSE-INDIGO\", 20))\n        bus.handle(commands.Allouer(\"o2\", \"TASSE-INDIGO\", 20))\n\n        bus.handle(commands.Cr\u00e9erLot(\"b2\", \"TASSE-INDIGO\", 100, None))\n        bus.handle(commands.ModifierQuantit\u00e9Lot(\"b1\", 25))\n\n        # L'une des lignes a \u00e9t\u00e9 r\u00e9allou\u00e9e au nouveau lot\n        assert bus.uow.produits.get(\"TASSE-INDIGO\").lots[0].quantit\u00e9_disponible == 5\n</code></pre> <p>Le test <code>test_r\u00e9alloue_si_n\u00e9cessaire</code> v\u00e9rifie un sc\u00e9nario m\u00e9tier complet : quand on r\u00e9duit la quantit\u00e9 d'un lot en dessous de ses allocations, le syst\u00e8me doit automatiquement r\u00e9allouer les lignes en exc\u00e8s vers un autre lot. On ne teste pas le m\u00e9canisme interne de r\u00e9allocation, on v\u00e9rifie que le r\u00e9sultat final est correct.</p>"},{"location":"partie1/chapitre_05_tdd/#avantages-des-tests-high-gear","title":"Avantages des tests high gear","text":"<ul> <li>Rapides : gr\u00e2ce aux fakes, pas d'I/O</li> <li>Stables : ils ne cassent pas quand on refactore le domaine</li> <li>Expressifs : ils d\u00e9crivent les cas d'utilisation m\u00e9tier</li> <li>Bonne couverture : chaque test traverse service layer + domaine</li> </ul>"},{"location":"partie1/chapitre_05_tdd/#tests-basse-vitesse-low-gear","title":"Tests \"basse vitesse\" (low gear)","text":"<p>Les tests low gear sont les tests unitaires du mod\u00e8le de domaine. Ils travaillent directement avec les objets <code>Lot</code>, <code>LigneDeCommande</code>, et <code>Produit</code>.</p> <p>C'est notre fichier <code>tests/unit/test_model.py</code> :</p> <pre><code>def cr\u00e9er_lot_et_ligne(\n    sku: str, quantit\u00e9_lot: int, quantit\u00e9_ligne: int\n) -&gt; tuple[Lot, LigneDeCommande]:\n    return (\n        Lot(\"lot-001\", sku, quantit\u00e9_lot, eta=date.today()),\n        LigneDeCommande(\"commande-ref\", sku, quantit\u00e9_ligne),\n    )\n</code></pre>"},{"location":"partie1/chapitre_05_tdd/#tests-granulaires-du-lot","title":"Tests granulaires du Lot","text":"<pre><code>class TestLot:\n    def test_allouer_r\u00e9duit_la_quantit\u00e9_disponible(self):\n        lot, ligne = cr\u00e9er_lot_et_ligne(\"PETITE-TABLE\", 20, 2)\n        lot.allouer(ligne)\n        assert lot.quantit\u00e9_disponible == 18\n\n    def test_peut_allouer_si_disponible_sup\u00e9rieur(self):\n        lot, ligne = cr\u00e9er_lot_et_ligne(\"ELEGANTE-LAMPE\", 20, 2)\n        assert lot.peut_allouer(ligne)\n\n    def test_ne_peut_pas_allouer_si_disponible_insuffisant(self):\n        lot, ligne = cr\u00e9er_lot_et_ligne(\"ELEGANTE-LAMPE\", 2, 20)\n        assert not lot.peut_allouer(ligne)\n\n    def test_allocation_idempotente(self):\n        lot, ligne = cr\u00e9er_lot_et_ligne(\"ANGULAR-DESK\", 20, 2)\n        lot.allouer(ligne)\n        lot.allouer(ligne)\n        assert lot.quantit\u00e9_disponible == 18\n</code></pre> <p>Ces tests sont tr\u00e8s proches de l'impl\u00e9mentation. Ils v\u00e9rifient directement les m\u00e9thodes <code>allouer()</code>, <code>peut_allouer()</code>, et <code>d\u00e9sallouer()</code> de la classe <code>Lot</code>. Ils testent le \"comment\" de la logique d'allocation.</p>"},{"location":"partie1/chapitre_05_tdd/#tests-de-la-strategie-dallocation-dans-produit","title":"Tests de la strat\u00e9gie d'allocation dans Produit","text":"<pre><code>class TestProduit:\n    def test_pr\u00e9f\u00e8re_les_lots_en_stock_aux_livraisons(self):\n        lot_en_stock = Lot(\"lot-stock\", \"HORLOGE-RETRO\", 100, eta=None)\n        lot_en_transit = Lot(\n            \"lot-transit\", \"HORLOGE-RETRO\", 100,\n            eta=date.today() + timedelta(days=1)\n        )\n        produit = Produit(\n            sku=\"HORLOGE-RETRO\",\n            lots=[lot_en_stock, lot_en_transit]\n        )\n        ligne = LigneDeCommande(\"oref\", \"HORLOGE-RETRO\", 10)\n\n        produit.allouer(ligne)\n\n        assert lot_en_stock.quantit\u00e9_disponible == 90\n        assert lot_en_transit.quantit\u00e9_disponible == 100\n\n    def test_pr\u00e9f\u00e8re_les_lots_avec_eta_la_plus_proche(self):\n        plus_t\u00f4t = Lot(\"lot-rapide\", \"LAMPE-MINIMALE\", 100, eta=date.today())\n        moyen = Lot(\n            \"lot-normal\", \"LAMPE-MINIMALE\", 100,\n            eta=date.today() + timedelta(days=5)\n        )\n        plus_tard = Lot(\n            \"lot-lent\", \"LAMPE-MINIMALE\", 100,\n            eta=date.today() + timedelta(days=10)\n        )\n        produit = Produit(\n            sku=\"LAMPE-MINIMALE\", lots=[moyen, plus_t\u00f4t, plus_tard]\n        )\n        ligne = LigneDeCommande(\"order1\", \"LAMPE-MINIMALE\", 10)\n\n        produit.allouer(ligne)\n\n        assert plus_t\u00f4t.quantit\u00e9_disponible == 90\n        assert moyen.quantit\u00e9_disponible == 100\n        assert plus_tard.quantit\u00e9_disponible == 100\n</code></pre> <p>Ces tests v\u00e9rifient la r\u00e8gle m\u00e9tier pr\u00e9cise : les lots en stock sont pr\u00e9f\u00e9r\u00e9s aux livraisons, et parmi les livraisons, la plus proche en date l'emporte. Ils sont indispensables pour d\u00e9velopper cette logique, car ils donnent un feedback imm\u00e9diat et pr\u00e9cis.</p>"},{"location":"partie1/chapitre_05_tdd/#quand-les-tests-low-gear-brillent","title":"Quand les tests low gear brillent","text":"<p>Les tests low gear sont particuli\u00e8rement utiles quand :</p> <ul> <li>On d\u00e9veloppe une nouvelle r\u00e8gle m\u00e9tier et on a besoin de feedback rapide et pr\u00e9cis</li> <li>La logique est complexe (algorithmes de tri, calculs, r\u00e8gles conditionnelles)</li> <li>On veut documenter le comportement attendu d'une entit\u00e9 ou d'un value object</li> <li>On d\u00e9bogue un cas limite sp\u00e9cifique</li> </ul>"},{"location":"partie1/chapitre_05_tdd/#quand-utiliser-quel-niveau","title":"Quand utiliser quel niveau ?","text":"<p>La m\u00e9taphore de la bo\u00eete de vitesses est \u00e9clairante. Quand on d\u00e9marre un projet ou une nouvelle fonctionnalit\u00e9 :</p>"},{"location":"partie1/chapitre_05_tdd/#phase-1-basse-vitesse-low-gear-developper-la-logique","title":"Phase 1 : Basse vitesse (low gear) -- D\u00e9velopper la logique","text":"<p>On commence par des tests du domaine pour construire la logique m\u00e9tier pas \u00e0 pas.</p> <pre><code># On d\u00e9veloppe la r\u00e8gle d'allocation lot par lot\ndef test_allouer_r\u00e9duit_la_quantit\u00e9_disponible(self):\n    lot, ligne = cr\u00e9er_lot_et_ligne(\"PETITE-TABLE\", 20, 2)\n    lot.allouer(ligne)\n    assert lot.quantit\u00e9_disponible == 18\n</code></pre> <p>\u00c0 ce stade, on avance lentement mais avec pr\u00e9cision. Chaque test v\u00e9rifie un aspect sp\u00e9cifique du mod\u00e8le. C'est le moment de la d\u00e9couverte : on explore le domaine, on affine les r\u00e8gles, on ajuste les abstractions.</p>"},{"location":"partie1/chapitre_05_tdd/#phase-2-haute-vitesse-high-gear-stabiliser-et-proteger","title":"Phase 2 : Haute vitesse (high gear) -- Stabiliser et prot\u00e9ger","text":"<p>Une fois la logique en place, on remonte vers la service layer pour \u00e9crire les tests de non-r\u00e9gression :</p> <pre><code># On v\u00e9rifie le cas d'utilisation complet\ndef test_allouer_retourne_la_r\u00e9f\u00e9rence_du_lot(self):\n    bus = bootstrap_test_bus()\n    bus.handle(commands.Cr\u00e9erLot(\"b1\", \"CHAISE-COMFY\", 100, None))\n    results = bus.handle(commands.Allouer(\"o1\", \"CHAISE-COMFY\", 10))\n    assert results.pop(0) == \"b1\"\n</code></pre> <p>Ces tests sont plus stables dans le temps. Si on d\u00e9cide de refactorer le mod\u00e8le de domaine (changer la structure interne de <code>Lot</code>, r\u00e9organiser <code>Produit</code>), les tests high gear continuent de passer tant que le comportement externe reste le m\u00eame.</p>"},{"location":"partie1/chapitre_05_tdd/#le-bon-ratio","title":"Le bon ratio","text":"<p>En pratique, une base de code mature tend vers cette r\u00e9partition :</p> <ul> <li>Beaucoup de tests high gear : ils couvrent tous les cas d'utilisation et servent de filet de s\u00e9curit\u00e9 pour le refactoring</li> <li>Quelques tests low gear : ils documentent les r\u00e8gles m\u00e9tier complexes et les cas limites du domaine</li> <li>Tr\u00e8s peu de tests E2E : ils v\u00e9rifient que le syst\u00e8me fonctionne de bout en bout (API -&gt; BDD -&gt; r\u00e9ponse)</li> </ul> <p>Conseil pratique</p> <p>Si vous pouvez supprimer un test low gear sans perdre de couverture fonctionnelle (parce qu'un test high gear couvre d\u00e9j\u00e0 le m\u00eame sc\u00e9nario), c'est probablement un bon candidat \u00e0 la suppression. Moins de tests \u00e0 maintenir, c'est moins de friction lors du refactoring.</p>"},{"location":"partie1/chapitre_05_tdd/#le-piege-des-tests-couples-a-limplementation","title":"Le pi\u00e8ge des tests coupl\u00e9s \u00e0 l'impl\u00e9mentation","text":"<p>Le plus grand danger en mati\u00e8re de tests, c'est d'\u00e9crire des tests qui v\u00e9rifient comment le code fonctionne plut\u00f4t que ce qu'il fait. Ces tests sont fragiles : ils cassent d\u00e8s qu'on refactore, m\u00eame si le comportement reste identique.</p>"},{"location":"partie1/chapitre_05_tdd/#exemple-de-test-fragile","title":"Exemple de test fragile","text":"<p>Imaginons un test qui v\u00e9rifie les d\u00e9tails internes :</p> <pre><code># MAUVAIS : couplage \u00e0 l'impl\u00e9mentation\ndef test_allocation_adds_to_internal_set():\n    lot = Lot(\"b1\", \"SKU-001\", 100)\n    ligne = LigneDeCommande(\"o1\", \"SKU-001\", 10)\n    lot.allouer(ligne)\n\n    # On v\u00e9rifie la structure interne !\n    assert ligne in lot._allocations\n    assert len(lot._allocations) == 1\n</code></pre> <p>Ce test acc\u00e8de \u00e0 <code>_allocations</code>, un attribut priv\u00e9. Si on d\u00e9cide de remplacer le <code>set</code> par une <code>list</code>, ou de renommer l'attribut, le test casse -- alors que le comportement n'a pas chang\u00e9.</p>"},{"location":"partie1/chapitre_05_tdd/#le-meme-test-oriente-comportement","title":"Le m\u00eame test, orient\u00e9 comportement","text":"<pre><code># BON : on teste le comportement observable\ndef test_allouer_r\u00e9duit_la_quantit\u00e9_disponible():\n    lot, ligne = cr\u00e9er_lot_et_ligne(\"PETITE-TABLE\", 20, 2)\n    lot.allouer(ligne)\n    assert lot.quantit\u00e9_disponible == 18\n</code></pre> <p>Ce test v\u00e9rifie le r\u00e9sultat observable : apr\u00e8s une allocation, la quantit\u00e9 disponible diminue. Peu importe comment c'est impl\u00e9ment\u00e9 en interne.</p>"},{"location":"partie1/chapitre_05_tdd/#symptomes-de-tests-couples-a-limplementation","title":"Sympt\u00f4mes de tests coupl\u00e9s \u00e0 l'impl\u00e9mentation","text":"<p>Voici les signes d'alerte :</p> <ul> <li>Le test acc\u00e8de \u00e0 des attributs priv\u00e9s (<code>_allocations</code>, <code>_quantit\u00e9_achet\u00e9e</code>)</li> <li>Le test v\u00e9rifie des appels de m\u00e9thodes avec <code>mock.assert_called_with()</code></li> <li>Le test casse quand on refactore sans changer le comportement</li> <li>Le test est difficile \u00e0 lire car il reproduit la logique interne</li> </ul>"},{"location":"partie1/chapitre_05_tdd/#la-regle-dor","title":"La r\u00e8gle d'or","text":"<p>Testez les inputs et les outputs, pas les m\u00e9canismes internes.</p> <p>Pour un test high gear, les inputs sont des commands et les outputs sont les effets observables (valeurs de retour, \u00e9tat du repository, events \u00e9mis).</p> <p>Pour un test low gear, les inputs sont des appels de m\u00e9thodes sur le domaine et les outputs sont les propri\u00e9t\u00e9s publiques (<code>quantit\u00e9_disponible</code>, <code>r\u00e9f\u00e9rence</code>, etc.).</p>"},{"location":"partie1/chapitre_05_tdd/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Classer vos tests</p> <p>Prenez un projet existant (le v\u00f4tre ou un projet open source). Classez chaque test en \"low gear\" ou \"high gear\". Quel est le ratio ? Est-il conforme \u00e0 la pyramide ?</p> <p>Exercice 2 -- Refactoring sans casser les tests</p> <p>Dans le mod\u00e8le de domaine, remplacez le <code>set</code> <code>_allocations</code> de <code>Lot</code> par une <code>list</code> (en g\u00e9rant l'unicit\u00e9 manuellement). Les tests high gear doivent-ils changer ? Et les tests low gear ?</p> <p>Exercice 3 -- Supprimer un test redondant</p> <p>Identifiez un test low gear qui est d\u00e9j\u00e0 couvert par un test high gear. Supprimez-le et v\u00e9rifiez que la couverture fonctionnelle n'a pas diminu\u00e9. \u00cates-vous \u00e0 l'aise avec cette suppression ? Pourquoi ?</p>"},{"location":"partie1/chapitre_05_tdd/#resume","title":"R\u00e9sum\u00e9","text":""},{"location":"partie1/chapitre_05_tdd/#principe-general","title":"Principe g\u00e9n\u00e9ral","text":"<p>Le TDD \u00e0 deux vitesses nous invite \u00e0 adapter notre niveau de test \u00e0 la phase de d\u00e9veloppement. En basse vitesse, on construit et on explore. En haute vitesse, on prot\u00e8ge et on stabilise.</p>"},{"location":"partie1/chapitre_05_tdd/#tableau-comparatif","title":"Tableau comparatif","text":"Crit\u00e8re Low gear (domaine) High gear (service layer) E2E Fichier <code>test_model.py</code> <code>test_handlers.py</code> <code>test_api.py</code> Vitesse Tr\u00e8s rapide Rapide (avec fakes) Lent Granularit\u00e9 Fine (une m\u00e9thode) Moyenne (un use case) Large (tout le syst\u00e8me) Stabilit\u00e9 Fragile si le domaine change Stable tant que le comportement tient Fragile (infra) Quand l'utiliser D\u00e9velopper une r\u00e8gle m\u00e9tier Tests de non-r\u00e9gression Smoke tests Ce qu'on teste Le \"comment\" du domaine Le \"quoi\" du use case Le syst\u00e8me entier D\u00e9pendances Aucune Fakes (FakeRepository, FakeUoW) Vraie BDD, vrai serveur"},{"location":"partie1/chapitre_05_tdd/#points-cles-a-retenir","title":"Points cl\u00e9s \u00e0 retenir","text":"<ul> <li>La pyramide des tests guide la r\u00e9partition : beaucoup de unit tests, peu de E2E</li> <li>Les tests high gear passent par la service layer avec des fakes ; ils sont stables et couvrent les use cases</li> <li>Les tests low gear testent le domaine directement ; ils sont utiles pour d\u00e9velopper la logique</li> <li>Commencez en low gear pour d\u00e9velopper une r\u00e8gle, puis remontez en high gear pour la non-r\u00e9gression</li> <li>\u00c9vitez le couplage \u00e0 l'impl\u00e9mentation : testez le comportement (inputs/outputs), pas la m\u00e9canique interne</li> <li>Moins de tests, mieux cibl\u00e9s vaut mieux qu'une couverture exhaustive de chaque d\u00e9tail d'impl\u00e9mentation</li> </ul>"},{"location":"partie1/chapitre_06_unit_of_work/","title":"Chapitre 6 -- Le pattern Unit of Work","text":"<p>Avant / Apr\u00e8s</p> Avant Handler instancie la session SQLAlchemy Apr\u00e8s <code>AbstractUnitOfWork</code> context manager encapsule la transaction <p>Comment garantir que les op\u00e9rations en base de donn\u00e9es sont atomiques, sans coupler nos handlers \u00e0 SQLAlchemy ?</p> <p>Jusqu'ici, notre architecture repose sur un repository qui abstrait l'acc\u00e8s \u00e0 la base de donn\u00e9es, et une service layer qui orchestre les cas d'usage. Mais une question reste ouverte : qui g\u00e8re la transaction ?</p> <p>Dans ce chapitre, nous introduisons le pattern Unit of Work -- un context manager qui encapsule la session, le repository et la transaction dans un seul objet coh\u00e9rent.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#le-probleme-qui-controle-la-transaction","title":"Le probl\u00e8me : qui contr\u00f4le la transaction ?","text":"<p>Notre handler <code>allouer</code> doit faire plusieurs choses dans une seule transaction :</p> <ol> <li>Lire un <code>Produit</code> depuis la base</li> <li>Appeler la logique d'allocation sur le domaine</li> <li>Persister le r\u00e9sultat en base</li> <li>Commiter la transaction</li> </ol> <p>La question est : o\u00f9 vit la gestion de la session et du commit ?</p>"},{"location":"partie1/chapitre_06_unit_of_work/#option-1-le-repository-gere-la-session","title":"Option 1 : le repository g\u00e8re la session","text":"<p>Si le repository cr\u00e9e et commite lui-m\u00eame sa session, chaque op\u00e9ration (<code>add</code>, <code>get</code>) est ind\u00e9pendante. On perd l'atomicit\u00e9 : si l'allocation r\u00e9ussit mais que le commit \u00e9choue, on se retrouve dans un \u00e9tat incoh\u00e9rent.</p> <pre><code># Probl\u00e8me : chaque appel est une transaction s\u00e9par\u00e9e\nproduit = repo.get(\"CHAISE-COMFY\")          # transaction 1\nr\u00e9f_lot = produit.allouer(ligne)            # en m\u00e9moire\nrepo.save(produit)                          # transaction 2 -- et si \u00e7a \u00e9choue ?\n</code></pre>"},{"location":"partie1/chapitre_06_unit_of_work/#option-2-le-handler-gere-la-session","title":"Option 2 : le handler g\u00e8re la session","text":"<p>Si le handler cr\u00e9e la session SQLAlchemy et la passe au repository, on retrouve l'atomicit\u00e9. Mais le handler devient coupl\u00e9 \u00e0 SQLAlchemy -- exactement ce qu'on voulait \u00e9viter avec le repository.</p> <pre><code># Probl\u00e8me : le handler conna\u00eet SQLAlchemy\ndef allouer(cmd, session_factory):\n    session = session_factory()\n    repo = SqlAlchemyRepository(session)\n    produit = repo.get(cmd.sku)\n    r\u00e9f_lot = produit.allouer(ligne)\n    session.commit()  # le handler manipule directement la session\n</code></pre>"},{"location":"partie1/chapitre_06_unit_of_work/#la-solution-un-nouvel-objet-qui-encapsule-la-transaction","title":"La solution : un nouvel objet qui encapsule la transaction","text":"<p>Le Unit of Work r\u00e9sout ce dilemme. C'est un objet qui :</p> <ul> <li>Cr\u00e9e la session \u00e0 l'entr\u00e9e du context manager</li> <li>Fournit le repository configur\u00e9 avec cette session</li> <li>Expose <code>commit()</code> et <code>rollback()</code> sans r\u00e9v\u00e9ler l'impl\u00e9mentation</li> <li>Ferme la session \u00e0 la sortie, avec rollback automatique si <code>commit()</code> n'a pas \u00e9t\u00e9 appel\u00e9</li> </ul> <p>Le handler n'a plus besoin de conna\u00eetre SQLAlchemy. Il travaille avec une abstraction.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#le-pattern-unit-of-work","title":"Le pattern Unit of Work","text":"<p>Le Unit of Work repr\u00e9sente une unit\u00e9 de travail atomique. C'est un concept formalis\u00e9 par Martin Fowler dans Patterns of Enterprise Application Architecture : un objet qui suit les modifications faites pendant une transaction et coordonne leur \u00e9criture en base.</p> <p>Dans notre impl\u00e9mentation, le Unit of Work est un context manager Python. Voici comment un handler l'utilise :</p> <pre><code>def allouer(cmd: Allouer, uow: AbstractUnitOfWork) -&gt; str:\n    ligne = LigneDeCommande(id_commande=cmd.id_commande, sku=cmd.sku, quantit\u00e9=cmd.quantit\u00e9)\n    with uow:\n        produit = uow.produits.get(sku=cmd.sku)\n        if produit is None:\n            raise SkuInconnu(f\"SKU inconnu : {cmd.sku}\")\n        r\u00e9f_lot = produit.allouer(ligne)\n        uow.commit()\n    return r\u00e9f_lot\n</code></pre> <p>Les r\u00e8gles sont simples :</p> <ul> <li><code>with uow:</code> ouvre la transaction et initialise le repository</li> <li><code>uow.produits</code> donne acc\u00e8s au repository (sans savoir comment il est construit)</li> <li><code>uow.commit()</code> valide la transaction</li> <li>Si une exception survient avant le commit, <code>__exit__</code> d\u00e9clenche un rollback automatique</li> <li>La session est ferm\u00e9e dans tous les cas</li> </ul>"},{"location":"partie1/chapitre_06_unit_of_work/#linterface-abstraite-abstractunitofwork","title":"L'interface abstraite : <code>AbstractUnitOfWork</code>","text":"<p>L'interface est d\u00e9finie comme une classe abstraite qui impl\u00e9mente le context manager protocol de Python -- c'est-\u00e0-dire les m\u00e9thodes <code>__enter__</code> et <code>__exit__</code>.</p> src/allocation/service_layer/unit_of_work.py<pre><code>class AbstractUnitOfWork(abc.ABC):\n    \"\"\"\n    Interface abstraite du Unit of Work.\n\n    D\u00e9finit le contrat : un repository produits,\n    et les m\u00e9thodes commit/rollback.\n    \"\"\"\n\n    produits: repository.AbstractRepository\n\n    def __enter__(self) -&gt; AbstractUnitOfWork:\n        return self\n\n    def __exit__(self, *args: object) -&gt; None:\n        self.rollback()\n\n    def commit(self) -&gt; None:\n        self._commit()\n\n    @abc.abstractmethod\n    def _commit(self) -&gt; None:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def rollback(self) -&gt; None:\n        raise NotImplementedError\n</code></pre>"},{"location":"partie1/chapitre_06_unit_of_work/#anatomie-du-context-manager-protocol","title":"Anatomie du context manager protocol","text":"<p>Le protocol <code>with</code> de Python repose sur deux m\u00e9thodes sp\u00e9ciales :</p> M\u00e9thode Quand ? R\u00f4le dans le UoW <code>__enter__</code> \u00c0 l'entr\u00e9e du bloc <code>with</code> Retourne <code>self</code> pour le <code>as</code> <code>__exit__</code> \u00c0 la sortie du bloc <code>with</code> (toujours) Rollback automatique en cas d'erreur <p>Le point crucial est que <code>__exit__</code> est toujours appel\u00e9, m\u00eame si une exception a lieu. C'est ce qui garantit le rollback automatique : si <code>commit()</code> n'a pas \u00e9t\u00e9 appel\u00e9 explicitement, <code>__exit__</code> appelle <code>rollback()</code>.</p> <p>Pourquoi <code>_commit</code> avec un underscore ?</p> <p>La m\u00e9thode publique <code>commit()</code> est d\u00e9finie dans la classe abstraite. Elle d\u00e9l\u00e8gue \u00e0 <code>_commit()</code>, la m\u00e9thode abstraite que les sous-classes impl\u00e9mentent. Ce d\u00e9coupage permet d'ajouter de la logique commune dans <code>commit()</code> (par exemple collecter les events) sans que chaque impl\u00e9mentation doive y penser.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#limplementation-sqlalchemy","title":"L'impl\u00e9mentation SQLAlchemy","text":"<p>Voici l'impl\u00e9mentation concr\u00e8te qui utilise SQLAlchemy :</p> src/allocation/service_layer/unit_of_work.py<pre><code>DEFAULT_SESSION_FACTORY = sessionmaker(\n    bind=create_engine(\n        \"sqlite:///allocation.db\",\n        isolation_level=\"SERIALIZABLE\",\n    )\n)\n\n\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork):\n    \"\"\"\n    Impl\u00e9mentation concr\u00e8te du UoW avec SQLAlchemy.\n\n    G\u00e8re la session SQLAlchemy et le repository associ\u00e9.\n    \"\"\"\n\n    def __init__(self, session_factory: sessionmaker = DEFAULT_SESSION_FACTORY):\n        self.session_factory = session_factory\n\n    def __enter__(self) -&gt; SqlAlchemyUnitOfWork:\n        self.session: Session = self.session_factory()\n        self.produits = repository.SqlAlchemyRepository(self.session)\n        return super().__enter__()\n\n    def __exit__(self, *args: object) -&gt; None:\n        super().__exit__(*args)\n        self.session.close()\n\n    def _commit(self) -&gt; None:\n        self.session.commit()\n\n    def rollback(self) -&gt; None:\n        self.session.rollback()\n</code></pre>"},{"location":"partie1/chapitre_06_unit_of_work/#le-cycle-de-vie-de-la-session","title":"Le cycle de vie de la session","text":"<p>Voici ce qui se passe concr\u00e8tement lors de l'ex\u00e9cution d'un handler :</p> <pre><code>with uow:                          # (1) __enter__ est appel\u00e9\n    |                              #     -&gt; session = session_factory()\n    |                              #     -&gt; produits = SqlAlchemyRepository(session)\n    produit = uow.produits.get()   # (2) lecture via la session\n    produit.allouer(ligne)         # (3) logique m\u00e9tier pure\n    uow.commit()                   # (4) session.commit()\n                                   # (5) __exit__ est appel\u00e9\n                                   #     -&gt; rollback() (sans effet apr\u00e8s commit)\n                                   #     -&gt; session.close()\n</code></pre> <p>Trois points importants :</p> <ol> <li> <p>La session est cr\u00e9\u00e9e \u00e0 l'entr\u00e9e (<code>__enter__</code>), pas dans le constructeur. Cela signifie qu'on peut r\u00e9utiliser un UoW pour plusieurs transactions successives.</p> </li> <li> <p>Le rollback dans <code>__exit__</code> est un filet de s\u00e9curit\u00e9. Apr\u00e8s un <code>commit()</code> r\u00e9ussi, le <code>rollback()</code> n'a aucun effet. Mais si une exception survient avant le commit, il annule toutes les modifications.</p> </li> <li> <p>La session est toujours ferm\u00e9e \u00e0 la sortie, que la transaction ait r\u00e9ussi ou non. Pas de fuite de connexion.</p> </li> </ol> <p>Isolation level <code>SERIALIZABLE</code></p> <p>La session factory utilise le niveau d'isolation <code>SERIALIZABLE</code>, le plus strict. Cela garantit que deux transactions concurrentes ne peuvent pas modifier le m\u00eame produit simultan\u00e9ment. C'est essentiel pour l'allocation de stock o\u00f9 les conditions de course (race conditions) pourraient mener \u00e0 de la surallocation.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#la-collecte-des-events-collect_new_events","title":"La collecte des events : <code>collect_new_events</code>","text":"<p>Le Unit of Work joue un r\u00f4le suppl\u00e9mentaire dans notre architecture : il sert de pont entre les agr\u00e9gats et le message bus.</p> <p>Quand un agr\u00e9gat effectue une op\u00e9ration m\u00e9tier, il peut \u00e9mettre des domain events. Par exemple, <code>Produit.allouer()</code> \u00e9met un event <code>RuptureDeStock</code> si le stock est \u00e9puis\u00e9, et <code>Produit.modifier_quantit\u00e9_lot()</code> \u00e9met des events <code>D\u00e9sallou\u00e9</code> pour les lignes \u00e0 r\u00e9allouer.</p> <p>Le probl\u00e8me est : comment le message bus r\u00e9cup\u00e8re-t-il ces events ?</p> <p>C'est la m\u00e9thode <code>collect_new_events()</code> du UoW qui s'en charge :</p> src/allocation/service_layer/unit_of_work.py<pre><code>def collect_new_events(self):\n    \"\"\"\n    Collecte tous les \u00e9v\u00e9nements \u00e9mis par les agr\u00e9gats vus\n    au cours de cette transaction.\n    \"\"\"\n    for produit in self.produits.seen:\n        while produit.\u00e9v\u00e9nements:\n            yield produit.\u00e9v\u00e9nements.pop(0)\n</code></pre>"},{"location":"partie1/chapitre_06_unit_of_work/#comment-ca-fonctionne","title":"Comment \u00e7a fonctionne","text":"<p>Le m\u00e9canisme repose sur la collaboration entre le repository et le UoW :</p> <ol> <li>Le repository garde une trace de tous les agr\u00e9gats qu'il a vus (via <code>add</code> ou <code>get</code>), dans son attribut <code>seen</code>.</li> <li>Chaque agr\u00e9gat <code>Produit</code> maintient une liste <code>\u00e9v\u00e9nements</code> o\u00f9 il accumule ses domain events.</li> <li>Apr\u00e8s chaque handler, le message bus appelle <code>uow.collect_new_events()</code>.</li> <li>Cette m\u00e9thode it\u00e8re sur les agr\u00e9gats vus et vide leur liste <code>\u00e9v\u00e9nements</code> (avec <code>pop</code>).</li> <li>Les events r\u00e9cup\u00e9r\u00e9s sont r\u00e9inject\u00e9s dans la queue du message bus pour \u00eatre trait\u00e9s \u00e0 leur tour.</li> </ol> src/allocation/service_layer/messagebus.py (extrait)<pre><code>def _handle_command(self, command: commands.Command) -&gt; Any:\n    handler = self.command_handlers.get(type(command))\n    result = self._call_handler(handler, command)\n    self.queue.extend(self.uow.collect_new_events())  # (1)\n    return result\n</code></pre> <ol> <li>Apr\u00e8s chaque command, le bus collecte les events \u00e9mis et les ajoute \u00e0 sa queue.</li> </ol> <p>C'est un m\u00e9canisme \u00e9l\u00e9gant : les agr\u00e9gats n'ont pas besoin de conna\u00eetre le message bus, le bus n'a pas besoin de conna\u00eetre le domaine, et le UoW fait le lien entre les deux.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#le-fake-unit-of-work-pour-les-tests","title":"Le Fake Unit of Work pour les tests","text":"<p>L'un des avantages majeurs du pattern est la testabilit\u00e9. Puisque les handlers d\u00e9pendent de <code>AbstractUnitOfWork</code> (une abstraction), on peut facilement le remplacer par un fake dans les tests unitaires. Le <code>FakeUnitOfWork</code> utilise un <code>FakeRepository</code> qui stocke les produits en m\u00e9moire (un simple <code>set</code>) :</p> tests/unit/test_handlers.py<pre><code>class FakeUnitOfWork(unit_of_work.AbstractUnitOfWork):\n    \"\"\"\n    Fake Unit of Work utilisant le FakeRepository.\n    Permet de tester sans base de donn\u00e9es.\n    \"\"\"\n\n    def __init__(self):\n        self.produits = FakeRepository([])\n        self.committed = False  # (1)\n\n    def __enter__(self):\n        return super().__enter__()\n\n    def __exit__(self, *args):\n        pass\n\n    def _commit(self):\n        self.committed = True  # (2)\n\n    def rollback(self):\n        pass\n</code></pre> <ol> <li>L'attribut <code>committed</code> est initialis\u00e9 \u00e0 <code>False</code>.</li> <li>Quand <code>commit()</code> est appel\u00e9 (via <code>_commit</code>), il passe \u00e0 <code>True</code>.</li> </ol>"},{"location":"partie1/chapitre_06_unit_of_work/#lattribut-committed-verifier-latomicite","title":"L'attribut <code>committed</code> : v\u00e9rifier l'atomicit\u00e9","text":"<p>L'attribut <code>committed</code> est un outil de test simple mais puissant. Il permet de v\u00e9rifier que le handler a bien commit\u00e9 la transaction :</p> <pre><code>class TestAjouterLot:\n    def test_ajouter_un_lot(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"COUSSIN-CARRE\", 100, None))\n\n        assert bus.uow.produits.get(\"COUSSIN-CARRE\") is not None\n        assert bus.uow.committed  # on v\u00e9rifie que le commit a eu lieu\n</code></pre> <p>Sans cet attribut, on ne pourrait pas distinguer un handler qui modifie le repository sans commiter (ce qui serait un bug) d'un handler qui commite correctement.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#le-fakerepository-et-lattribut-seen","title":"Le <code>FakeRepository</code> et l'attribut <code>seen</code>","text":"<p>Le <code>FakeRepository</code> h\u00e9rite de <code>AbstractRepository</code>, qui d\u00e9finit l'attribut <code>seen</code>. Cela signifie que <code>collect_new_events()</code> fonctionne exactement de la m\u00eame mani\u00e8re avec le fake qu'avec l'impl\u00e9mentation r\u00e9elle. Les tests unitaires v\u00e9rifient donc le comportement complet, y compris la propagation des events.</p> <p>Le pattern g\u00e9n\u00e9ral des fakes</p> <p>Un bon fake impl\u00e9mente la m\u00eame interface que le composant r\u00e9el, avec un stockage en m\u00e9moire. Il peut aussi exposer des attributs suppl\u00e9mentaires (comme <code>committed</code>) pour les assertions. C'est plus fiable qu'un mock car on teste le comportement r\u00e9el de l'interface, pas juste les appels de m\u00e9thodes.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#le-flux-complet-du-handler-au-domaine","title":"Le flux complet : du handler au domaine","text":"<p>Voici le flux complet quand le message bus traite une command <code>Allouer</code> :</p> <pre><code>MessageBus.handle(Allouer)\n    |\n    v\nhandler: allouer(cmd, uow)\n    |\n    +---&gt; with uow:                          # UoW.__enter__\n    |         |                               #   cr\u00e9e session + repository\n    |         +---&gt; uow.produits.get(sku)     # Repository.get()\n    |         |         |                     #   marque le Produit comme \"seen\"\n    |         |         v\n    |         +---&gt; produit.allouer(ligne)    # Logique m\u00e9tier pure\n    |         |         |                     #   peut \u00e9mettre des events\n    |         |         v\n    |         +---&gt; uow.commit()              # UoW.commit()\n    |                   |                     #   session.commit()\n    |                   v\n    +---&gt; (sortie du with)                    # UoW.__exit__\n              |                               #   rollback() + session.close()\n              v\nMessageBus: uow.collect_new_events()          # Collecte les events\n    |                                         #   \u00e9mis par les agr\u00e9gats \"seen\"\n    v\nTraitement des events suivants...\n</code></pre> <p>Le diagramme en couches correspondant :</p> <pre><code>+------------------------------------------------------+\n|                    Message Bus                        |\n|   handle(command) -&gt; handler -&gt; collect_new_events()  |\n+------------------------------------------------------+\n          |                          ^\n          v                          |\n+------------------------------------------------------+\n|                   Unit of Work                        |\n|   __enter__  |  commit  |  rollback  |  __exit__     |\n|   fournit: repository (produits)                     |\n+------------------------------------------------------+\n          |                          ^\n          v                          |\n+------------------------------------------------------+\n|                    Repository                         |\n|   add(produit)  |  get(sku)  |  seen: set[Produit]   |\n+------------------------------------------------------+\n          |                          ^\n          v                          |\n+------------------------------------------------------+\n|               Mod\u00e8le de Domaine                       |\n|   Produit -&gt; Lot -&gt; LigneDeCommande                   |\n|   \u00e9v\u00e9nements: [RuptureDeStock, D\u00e9sallou\u00e9, ...]       |\n+------------------------------------------------------+\n</code></pre>"},{"location":"partie1/chapitre_06_unit_of_work/#resume","title":"R\u00e9sum\u00e9","text":"<p>Le pattern Unit of Work r\u00e9sout le probl\u00e8me de la gestion des transactions en introduisant un objet qui encapsule la session, le repository et la logique de commit/rollback.</p>"},{"location":"partie1/chapitre_06_unit_of_work/#ce-que-le-unit-of-work-apporte","title":"Ce que le Unit of Work apporte","text":"Aspect Sans UoW Avec UoW Transaction G\u00e9r\u00e9e par le handler ou le repository Encapsul\u00e9e dans le context manager Atomicit\u00e9 Difficile \u00e0 garantir Garantie par <code>__enter__</code>/<code>__exit__</code> Couplage Handler coupl\u00e9 \u00e0 SQLAlchemy Handler d\u00e9pend d'une abstraction Testabilit\u00e9 N\u00e9cessite une base de donn\u00e9es Fake UoW en m\u00e9moire Collecte des events Pas de m\u00e9canisme standard <code>collect_new_events()</code> centralis\u00e9"},{"location":"partie1/chapitre_06_unit_of_work/#les-fichiers-cles","title":"Les fichiers cl\u00e9s","text":"Fichier R\u00f4le <code>src/allocation/service_layer/unit_of_work.py</code> Interface abstraite et impl\u00e9mentation SQLAlchemy <code>src/allocation/adapters/repository.py</code> Repository avec tracking des agr\u00e9gats vus (<code>seen</code>) <code>src/allocation/service_layer/handlers.py</code> Handlers qui utilisent le UoW comme context manager <code>tests/unit/test_handlers.py</code> <code>FakeUnitOfWork</code> et <code>FakeRepository</code> pour les tests"},{"location":"partie1/chapitre_06_unit_of_work/#les-principes-a-retenir","title":"Les principes \u00e0 retenir","text":"<ol> <li>Le UoW est un context manager qui g\u00e8re le cycle de vie de la transaction : ouverture, commit, rollback, fermeture.</li> <li>Le handler ne conna\u00eet que l'abstraction (<code>AbstractUnitOfWork</code>), jamais SQLAlchemy directement.</li> <li>Le rollback est automatique : si <code>commit()</code> n'est pas appel\u00e9 explicitement, <code>__exit__</code> annule tout.</li> <li>Le UoW collecte les events \u00e9mis par les agr\u00e9gats au cours de la transaction, servant de pont vers le message bus.</li> <li>Le <code>FakeUnitOfWork</code> rend les tests rapides et d\u00e9terministes, sans base de donn\u00e9es.</li> </ol>"},{"location":"partie1/chapitre_06_unit_of_work/#exercices","title":"Exercices","text":"<p>Exercice 1 -- UoW avec rollback explicite</p> <p>Modifiez le <code>FakeUnitOfWork</code> pour que <code>rollback()</code> vide le <code>FakeRepository</code>. \u00c9crivez un test qui v\u00e9rifie qu'apr\u00e8s un rollback, les produits ajout\u00e9s pendant la transaction ont disparu.</p> <p>Exercice 2 -- Double commit</p> <p>Que se passe-t-il si un handler appelle <code>uow.commit()</code> deux fois ? Et si <code>commit()</code> n'est jamais appel\u00e9 ? \u00c9crivez des tests pour v\u00e9rifier chaque sc\u00e9nario.</p> <p>Exercice 3 -- UoW sans context manager</p> <p>Essayez d'utiliser le <code>SqlAlchemyUnitOfWork</code> sans <code>with</code> (en appelant manuellement <code>__enter__</code> et <code>__exit__</code>). Quels risques cela cr\u00e9e-t-il ? Pourquoi le context manager est-il pr\u00e9f\u00e9rable ?</p> <p>Dans le prochain chapitre</p> <p>Nous verrons le pattern Aggregate et la notion de fronti\u00e8re de coh\u00e9rence. L'agr\u00e9gat <code>Produit</code> d\u00e9finit le p\u00e9rim\u00e8tre \u00e0 l'int\u00e9rieur duquel les invariants m\u00e9tier sont garantis -- et le Unit of Work commite exactement un agr\u00e9gat par transaction.</p>"},{"location":"partie1/chapitre_07_aggregats/","title":"Chapitre 7 -- Agr\u00e9gats et fronti\u00e8res de coh\u00e9rence","text":"<p>Avant / Apr\u00e8s</p> Avant Fonction libre <code>allouer(ligne, lots)</code> sans garantie Apr\u00e8s <code>Produit</code> Aggregate Root + <code>num\u00e9ro_version</code> (optimistic locking) <p>Ce que vous allez apprendre</p> <ul> <li>Pourquoi un mod\u00e8le de domaine sans fronti\u00e8res claires m\u00e8ne \u00e0 des incoh\u00e9rences</li> <li>Ce qu'est un Agr\u00e9gat et comment il prot\u00e8ge les invariants m\u00e9tier</li> <li>Le r\u00f4le de l'Aggregate Root comme point d'entr\u00e9e unique</li> <li>Comment choisir les fronti\u00e8res d'un agr\u00e9gat</li> <li>Comment le num\u00e9ro_version et l'optimistic locking prot\u00e8gent contre les acc\u00e8s concurrents</li> <li>Comment <code>Produit</code> devient l'agr\u00e9gat qui contient les <code>Lot</code></li> </ul>"},{"location":"partie1/chapitre_07_aggregats/#le-probleme-un-domaine-sans-frontieres","title":"Le probl\u00e8me : un domaine sans fronti\u00e8res","text":"<p>Au chapitre 1, nous avons d\u00e9fini une fonction libre <code>allouer(ligne, lots)</code> qui prend une liste de lots et choisit le meilleur. C'est simple et lisible, mais cela pose un probl\u00e8me fondamental : qui est responsable de fournir la bonne liste de lots ? Rien n'emp\u00eache du code ext\u00e9rieur de manipuler directement un <code>Lot</code>, de modifier sa quantit\u00e9, ou d'allouer une ligne sans passer par cette strat\u00e9gie.</p> <p>Imaginons deux requ\u00eates HTTP simultan\u00e9es qui tentent d'allouer la m\u00eame quantit\u00e9 de stock :</p> <pre><code>Requete A                          Requete B\n    |                                  |\n    |  lire lot (dispo = 10)           |\n    |                                  |  lire lot (dispo = 10)\n    |  allouer 10 unites               |\n    |                                  |  allouer 10 unites\n    |  sauvegarder (dispo = 0)         |\n    |                                  |  sauvegarder (dispo = 0)\n    v                                  v\n\n    Resultat : 20 unites allouees pour 10 disponibles !\n</code></pre> <p>Sans fronti\u00e8re de coh\u00e9rence, rien ne garantit que les invariants m\u00e9tier (on ne peut pas allouer plus que le stock disponible) sont respect\u00e9s. Chaque requ\u00eate voit un \u00e9tat valide au moment de la lecture, mais l'\u00e9tat global devient incoh\u00e9rent apr\u00e8s l'\u00e9criture.</p> <p>Ce probl\u00e8me est fondamental : dans un syst\u00e8me concurrent, il faut d\u00e9finir explicitement quels objets doivent \u00eatre modifi\u00e9s ensemble, dans une m\u00eame transaction.</p>"},{"location":"partie1/chapitre_07_aggregats/#lagregat-un-cluster-dobjets-coherents","title":"L'Agr\u00e9gat : un cluster d'objets coh\u00e9rents","text":"<p>Un Agr\u00e9gat est un regroupement d'objets du domaine qui forment une unit\u00e9 de coh\u00e9rence. Toute modification \u00e0 l'int\u00e9rieur de l'agr\u00e9gat doit respecter les invariants m\u00e9tier -- les r\u00e8gles qui doivent toujours \u00eatre vraies.</p> <p>Les principes fondamentaux :</p> <ul> <li>Un agr\u00e9gat = une transaction. On ne modifie qu'un seul agr\u00e9gat par transaction.</li> <li>Les objets internes sont inaccessibles de l'ext\u00e9rieur. On ne peut pas aller chercher un <code>Lot</code> directement, on passe par l'agr\u00e9gat.</li> <li>Un seul point d'entr\u00e9e : l'Aggregate Root.</li> </ul> <p>Dans notre domaine, les invariants sont :</p> <ol> <li>On ne peut pas allouer une <code>LigneDeCommande</code> \u00e0 un <code>Lot</code> si la quantit\u00e9 disponible est insuffisante.</li> <li>L'allocation doit privil\u00e9gier les lots en stock, puis ceux avec l'ETA la plus proche.</li> <li>Si la quantit\u00e9 d'un lot change, les allocations en exc\u00e9dent doivent \u00eatre d\u00e9sallou\u00e9es.</li> </ol> <p>Toutes ces r\u00e8gles impliquent de raisonner sur l'ensemble des <code>Lot</code> pour un SKU donn\u00e9. C'est donc le <code>Produit</code> (un SKU et ses lots) qui constitue notre agr\u00e9gat.</p>"},{"location":"partie1/chapitre_07_aggregats/#laggregate-root-le-point-dentree-unique","title":"L'Aggregate Root : le point d'entr\u00e9e unique","text":"<p>L'Aggregate Root est l'objet par lequel on acc\u00e8de \u00e0 tout le contenu de l'agr\u00e9gat. C'est lui qui :</p> <ul> <li>Expose les op\u00e9rations m\u00e9tier (allouer, modifier une quantit\u00e9)</li> <li>V\u00e9rifie les invariants avant chaque modification</li> <li>Contr\u00f4le l'acc\u00e8s aux objets internes (<code>Lot</code>, <code>LigneDeCommande</code>)</li> </ul> <p>Le code ext\u00e9rieur ne doit jamais manipuler directement un <code>Lot</code>. Il demande au <code>Produit</code> de le faire :</p> <pre><code># Correct : passer par l'aggregate root\nproduit.allouer(ligne_de_commande)\n\n# Incorrect : manipuler un Lot directement\nlot = somehow_get_lot(\"lot-001\")\nlot.allouer(ligne_de_commande)  # Aucune garantie de coherence !\n</code></pre> <p>Cette r\u00e8gle a une cons\u00e9quence directe sur le Repository : il manipule des <code>Produit</code>, pas des <code>Lot</code>.</p>"},{"location":"partie1/chapitre_07_aggregats/#la-classe-produit-notre-aggregate-root","title":"La classe <code>Produit</code> : notre Aggregate Root","text":"<p>La fonction libre <code>allouer(ligne, lots)</code> du chapitre 1 va maintenant devenir une m\u00e9thode de <code>Produit</code>. L'agr\u00e9gat poss\u00e8de les lots et prend la responsabilit\u00e9 de la strat\u00e9gie d'allocation. La diff\u00e9rence cl\u00e9 : au lieu de lever une exception <code>RuptureDeStock</code>, l'agr\u00e9gat \u00e9met un \u00e9v\u00e9nement (nous verrons pourquoi au chapitre 8).</p> <p>Voici la classe <code>Produit</code> telle qu'elle appara\u00eet dans notre code source (<code>src/allocation/domain/model.py</code>) :</p> <pre><code>class Produit:\n    \"\"\"\n    Agregat racine pour la gestion des produits.\n\n    Un Produit regroupe tous les Lot pour un SKU donne.\n    C'est la frontiere de coherence : toutes les operations\n    d'allocation passent par cet agregat.\n    \"\"\"\n\n    def __init__(\n        self,\n        sku: str,\n        lots: Optional[list[Lot]] = None,\n        num\u00e9ro_version: int = 0,\n    ):\n        self.sku = sku\n        self.lots = lots or []\n        self.num\u00e9ro_version = num\u00e9ro_version\n        self.\u00e9v\u00e9nements: list[events.Event] = []\n</code></pre> <p>Trois attributs m\u00e9ritent une attention particuli\u00e8re :</p> Attribut R\u00f4le <code>sku</code> L'identit\u00e9 de l'agr\u00e9gat. C'est le SKU du produit. <code>lots</code> Les objets internes \u00e0 l'agr\u00e9gat. La liste de tous les lots pour ce SKU. <code>num\u00e9ro_version</code> Le compteur de version pour l'optimistic locking (voir plus bas). <p>Et une liste <code>\u00e9v\u00e9nements</code> qui collecte les domain events \u00e9mis par les op\u00e9rations m\u00e9tier.</p>"},{"location":"partie1/chapitre_07_aggregats/#la-methode-allouer","title":"La m\u00e9thode <code>allouer()</code>","text":"<pre><code>def allouer(self, ligne: LigneDeCommande) -&gt; str:\n    \"\"\"\n    Alloue une ligne de commande au lot le plus approprie.\n\n    La strategie d'allocation privilegie les lots en stock\n    (sans ETA) puis les lots avec l'ETA la plus proche.\n\n    Retourne la reference du lot choisi.\n    Emet un evenement RuptureDeStock s'il n'y a plus de stock.\n    \"\"\"\n    try:\n        lot = next(\n            l for l in sorted(self.lots)\n            if l.peut_allouer(ligne)\n        )\n    except StopIteration:\n        self.\u00e9v\u00e9nements.append(events.RuptureDeStock(sku=ligne.sku))\n        return \"\"\n\n    lot.allouer(ligne)\n    self.num\u00e9ro_version += 1\n    return lot.r\u00e9f\u00e9rence\n</code></pre> <p>Observons les responsabilit\u00e9s de cette m\u00e9thode :</p> <ol> <li>Elle trie les lots (<code>sorted(self.lots)</code>) pour appliquer la strat\u00e9gie d'allocation (stock d'abord, puis ETA la plus proche).</li> <li>Elle trouve le premier lot capable d'accueillir la ligne (<code>l.peut_allouer(ligne)</code>).</li> <li>Elle g\u00e8re le cas d'erreur : si aucun lot ne convient, elle \u00e9met un \u00e9v\u00e9nement <code>RuptureDeStock</code> au lieu de lever une exception.</li> <li>Elle incr\u00e9mente le <code>num\u00e9ro_version</code> apr\u00e8s chaque allocation r\u00e9ussie.</li> <li>Elle retourne la r\u00e9f\u00e9rence du lot choisi, permettant au code appelant de savoir o\u00f9 l'allocation a \u00e9t\u00e9 faite.</li> </ol> <p>Le code appelant (la service layer) n'a aucune connaissance des <code>Lot</code> individuels. Il demande simplement au <code>Produit</code> d'allouer.</p>"},{"location":"partie1/chapitre_07_aggregats/#la-methode-modifier_quantite_lot","title":"La m\u00e9thode <code>modifier_quantit\u00e9_lot()</code>","text":"<pre><code>def modifier_quantit\u00e9_lot(self, r\u00e9f: str, quantit\u00e9: int) -&gt; None:\n    \"\"\"\n    Modifie la quantite d'un lot et realloue si necessaire.\n\n    Si la nouvelle quantite est inferieure aux allocations existantes,\n    les lignes en excedent sont desallouees et des evenements\n    D\u00e9sallou\u00e9 sont emis pour chacune.\n    \"\"\"\n    lot = next(l for l in self.lots if l.r\u00e9f\u00e9rence == r\u00e9f)\n    lot._quantit\u00e9_achet\u00e9e = quantit\u00e9\n    while lot.quantit\u00e9_disponible &lt; 0:\n        ligne = lot.d\u00e9sallouer_une()\n        self.\u00e9v\u00e9nements.append(\n            events.D\u00e9sallou\u00e9(\n                id_commande=ligne.id_commande,\n                sku=ligne.sku,\n                quantit\u00e9=ligne.quantit\u00e9,\n            )\n        )\n</code></pre> <p>Cette m\u00e9thode illustre un sc\u00e9nario plus complexe :</p> <ol> <li>Elle retrouve le lot concern\u00e9 \u00e0 l'int\u00e9rieur de l'agr\u00e9gat (pas via le repository).</li> <li>Elle modifie la quantit\u00e9 achet\u00e9e.</li> <li>Si la quantit\u00e9 disponible devient n\u00e9gative, elle d\u00e9salloue progressivement des lignes de commande.</li> <li>Pour chaque ligne d\u00e9sallou\u00e9e, elle \u00e9met un \u00e9v\u00e9nement <code>D\u00e9sallou\u00e9</code>. Ce sont ces events qui d\u00e9clencheront une r\u00e9allocation ailleurs dans le syst\u00e8me (via le message bus, que nous verrons au chapitre 8).</li> </ol>"},{"location":"partie1/chapitre_07_aggregats/#le-repository-manipule-des-agregats","title":"Le Repository manipule des Agr\u00e9gats","text":"<p>Le repository est l'interface entre le domaine et la persistance. Il doit op\u00e9rer au niveau de l'agr\u00e9gat, pas au niveau de ses composants internes.</p> <pre><code>class AbstractRepository(abc.ABC):\n\n    def add(self, produit: model.Produit) -&gt; None:\n        \"\"\"Ajoute un produit au repository.\"\"\"\n        ...\n\n    def get(self, sku: str) -&gt; model.Produit | None:\n        \"\"\"Recupere un produit par son SKU.\"\"\"\n        ...\n\n    def get_par_r\u00e9f_lot(self, r\u00e9f_lot: str) -&gt; model.Produit | None:\n        \"\"\"Recupere un produit contenant le lot de reference donnee.\"\"\"\n        ...\n</code></pre> <p>On remarque :</p> <ul> <li><code>add()</code> et <code>get()</code> travaillent avec des <code>Produit</code>, jamais des <code>Lot</code>.</li> <li><code>get_par_r\u00e9f_lot()</code> retrouve le <code>Produit</code> parent \u00e0 partir d'une r\u00e9f\u00e9rence de lot. M\u00eame ici, c'est l'agr\u00e9gat entier qui est retourn\u00e9.</li> <li>La m\u00e9thode <code>seen</code> (un <code>set[Produit]</code>) permet de garder une trace de tous les agr\u00e9gats charg\u00e9s ou ajout\u00e9s, ce qui sera utile pour collecter les domain events.</li> </ul>"},{"location":"partie1/chapitre_07_aggregats/#choisir-les-frontieres-de-lagregat","title":"Choisir les fronti\u00e8res de l'Agr\u00e9gat","text":"<p>Le choix des fronti\u00e8res est une d\u00e9cision de conception cruciale. La r\u00e8gle \u00e0 retenir :</p> <p>Un agr\u00e9gat = une transaction = un verrou</p> <p>Chaque agr\u00e9gat d\u00e9limite une transaction. Pendant qu'une transaction modifie un agr\u00e9gat, aucune autre transaction ne peut le modifier. C'est ainsi qu'on garantit la coh\u00e9rence.</p>"},{"location":"partie1/chapitre_07_aggregats/#trop-gros-le-probleme-de-la-contention","title":"Trop gros : le probl\u00e8me de la contention","text":"<p>Si on faisait un agr\u00e9gat unique <code>Entrep\u00f4t</code> contenant tous les produits et tous les lots, chaque allocation verrouillerait l'ensemble du stock. Deux commandes pour des produits diff\u00e9rents ne pourraient pas \u00eatre trait\u00e9es en parall\u00e8le.</p>"},{"location":"partie1/chapitre_07_aggregats/#trop-petit-le-probleme-de-lincoherence","title":"Trop petit : le probl\u00e8me de l'incoh\u00e9rence","text":"<p>Si chaque <code>Lot</code> \u00e9tait son propre agr\u00e9gat, on n'aurait aucun moyen de garantir que l'allocation choisit le bon lot. Deux transactions pourraient allouer le m\u00eame lot simultan\u00e9ment sans le savoir.</p>"},{"location":"partie1/chapitre_07_aggregats/#la-bonne-granularite-produit","title":"La bonne granularit\u00e9 : <code>Produit</code>","text":"<p>Un <code>Produit</code> regroupe tous les lots pour un SKU donn\u00e9. C'est le bon compromis :</p> <ul> <li>Coh\u00e9rence : toutes les r\u00e8gles d'allocation pour un SKU sont v\u00e9rifi\u00e9es dans une seule transaction.</li> <li>Concurrence : deux allocations pour des SKU diff\u00e9rents se font en parall\u00e8le sans conflit.</li> </ul> <pre><code>+-------------------+   +-------------------+\n|  Produit (SKU-A)  |   |  Produit (SKU-B)  |\n|  +-------+        |   |  +-------+        |\n|  | Lot 1 |        |   |  | Lot 3 |        |\n|  +-------+        |   |  +-------+        |\n|  +-------+        |   |  +-------+        |\n|  | Lot 2 |        |   |  | Lot 4 |        |\n|  +-------+        |   |  +-------+        |\n+-------------------+   +-------------------+\n  ^ transaction A        ^ transaction B\n  (independantes)\n</code></pre>"},{"location":"partie1/chapitre_07_aggregats/#le-versioning-optimiste-optimistic-locking","title":"Le versioning optimiste (Optimistic Locking)","text":"<p>M\u00eame avec des fronti\u00e8res d'agr\u00e9gat bien choisies, il reste un risque : deux transactions concurrentes peuvent tenter de modifier le m\u00eame <code>Produit</code> simultan\u00e9ment. Le num\u00e9ro_version r\u00e9sout ce probl\u00e8me :</p> <ol> <li>Quand on charge un <code>Produit</code>, on lit son <code>num\u00e9ro_version</code>.</li> <li>Quand on le sauvegarde, on v\u00e9rifie que le <code>num\u00e9ro_version</code> en base n'a pas chang\u00e9.</li> <li>Si le num\u00e9ro a chang\u00e9 (une autre transaction est pass\u00e9e entre-temps), la sauvegarde \u00e9choue.</li> </ol> <pre><code>Transaction A                       Transaction B\n     |                                   |\n     | SELECT ... =&gt; version = 3         |\n     |                                   | SELECT ... =&gt; version = 3\n     | allouer(...) =&gt; version = 4       |\n     |                                   | allouer(...) =&gt; version = 4\n     | UPDATE ... WHERE version=3        |\n     | =&gt; OK (1 row)                     |\n     |                                   | UPDATE ... WHERE version=3\n     |                                   | =&gt; ECHEC (0 rows)\n     v                                   v\n</code></pre> <p>La transaction B \u00e9choue car la clause <code>WHERE num\u00e9ro_version=3</code> ne correspond plus \u00e0 l'\u00e9tat en base. C'est le principe de l'optimistic locking : on suppose que les conflits sont rares, mais on les d\u00e9tecte au moment du <code>commit</code>.</p> <p>Dans le mapping ORM (<code>src/allocation/adapters/orm.py</code>), la table <code>products</code> porte ce champ :</p> <pre><code>products = Table(\n    \"products\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"sku\", String(255)),\n    Column(\"numero_version\", Integer, nullable=False, server_default=\"0\"),\n)\n</code></pre> <p>Et dans la classe <code>Produit</code>, chaque appel \u00e0 <code>allouer()</code> incr\u00e9mente le compteur :</p> <pre><code>lot.allouer(ligne)\nself.num\u00e9ro_version += 1\nreturn lot.r\u00e9f\u00e9rence\n</code></pre> <p>Pourquoi optimiste ?</p> <p>On parle de verrouillage optimiste parce qu'on ne pose pas de verrou explicite en base de donn\u00e9es (pas de <code>SELECT ... FOR UPDATE</code>). On laisse les transactions avancer en parall\u00e8le et on ne d\u00e9tecte le conflit qu'au moment du <code>commit</code>. C'est plus performant quand les conflits sont rares.</p>"},{"location":"partie1/chapitre_07_aggregats/#les-domain-events-emis-par-lagregat","title":"Les Domain Events \u00e9mis par l'Agr\u00e9gat","text":"<p>L'agr\u00e9gat <code>Produit</code> ne se contente pas de modifier son \u00e9tat interne. Il \u00e9met des \u00e9v\u00e9nements qui signalent ce qui s'est pass\u00e9 :</p> \u00c9v\u00e9nement Quand D\u00e9clencheur <code>RuptureDeStock</code> Aucun lot ne peut accueillir la ligne <code>allouer()</code> <code>D\u00e9sallou\u00e9</code> Une ligne est d\u00e9sallou\u00e9e suite \u00e0 un changement de quantit\u00e9 <code>modifier_quantit\u00e9_lot()</code> <p>Ces \u00e9v\u00e9nements sont collect\u00e9s dans <code>self.\u00e9v\u00e9nements</code> et seront publi\u00e9s par l'infrastructure (le Unit of Work et le message bus) apr\u00e8s la transaction. C'est une s\u00e9paration nette entre \"ce qui s'est pass\u00e9\" et \"ce qu'il faut faire ensuite\".</p> <pre><code># Dans Produit.__init__\nself.\u00e9v\u00e9nements: list[events.Event] = []\n\n# Dans allouer(), si rupture de stock :\nself.\u00e9v\u00e9nements.append(events.RuptureDeStock(sku=ligne.sku))\n\n# Dans modifier_quantit\u00e9_lot(), pour chaque ligne d\u00e9sallou\u00e9e :\nself.\u00e9v\u00e9nements.append(\n    events.D\u00e9sallou\u00e9(id_commande=ligne.id_commande, sku=ligne.sku, quantit\u00e9=ligne.quantit\u00e9)\n)\n</code></pre>"},{"location":"partie1/chapitre_07_aggregats/#schema-recapitulatif","title":"Sch\u00e9ma r\u00e9capitulatif","text":"<pre><code>+------------------------------------------------------------+\n|                                                            |\n|   Aggregate : Produit                                      |\n|                                                            |\n|   Identite :  sku = \"BLUE-VASE\"                            |\n|   Version :   num\u00e9ro_version = 3                           |\n|   Events :    [RuptureDeStock(...), D\u00e9sallou\u00e9(...)]        |\n|                                                            |\n|   +------------------------+  +------------------------+   |\n|   |  Lot                   |  |  Lot                   |   |\n|   |  r\u00e9f\u00e9rence: \"lot-01\"   |  |  r\u00e9f\u00e9rence: \"lot-02\"   |   |\n|   |  sku: \"BLUE-VASE\"      |  |  sku: \"BLUE-VASE\"      |   |\n|   |  quantit\u00e9: 100         |  |  quantit\u00e9: 50          |   |\n|   |  eta: None (en stock)  |  |  eta: 2025-03-15       |   |\n|   |                        |  |                        |   |\n|   |  _allocations:         |  |  _allocations:         |   |\n|   |    {LigneDeCommande(.),|  |    {LigneDeCommande(.)}|   |\n|   |     LigneDeCommande(.)}|  |                        |   |\n|   +------------------------+  +------------------------+   |\n|                                                            |\n+------------------------------------------------------------+\n         ^\n         |\n    Aggregate Root : le seul point d'acces\n    Repository.get(\"BLUE-VASE\") -&gt; Produit\n</code></pre>"},{"location":"partie1/chapitre_07_aggregats/#resume","title":"R\u00e9sum\u00e9","text":"<p>Les Agr\u00e9gats sont la r\u00e9ponse du Domain-Driven Design au probl\u00e8me de la coh\u00e9rence dans un syst\u00e8me concurrent. En d\u00e9limitant des fronti\u00e8res claires, ils permettent de raisonner localement sur les invariants tout en pr\u00e9servant la performance globale du syst\u00e8me.</p> Concept Ce qu'il faut retenir Agr\u00e9gat Un cluster d'objets modifi\u00e9s ensemble dans une seule transaction. Aggregate Root Le point d'entr\u00e9e unique de l'agr\u00e9gat. Toutes les op\u00e9rations passent par lui. Invariant Une r\u00e8gle m\u00e9tier qui doit toujours \u00eatre vraie. L'agr\u00e9gat la garantit. Fronti\u00e8re Un agr\u00e9gat = une transaction = un verrou. Ni trop gros, ni trop petit. Optimistic Locking Le <code>num\u00e9ro_version</code> d\u00e9tecte les conflits entre transactions concurrentes. Repository Il travaille au niveau de l'agr\u00e9gat, pas de ses composants internes. Domain Events L'agr\u00e9gat \u00e9met des \u00e9v\u00e9nements pour signaler ce qui s'est pass\u00e9."},{"location":"partie1/chapitre_07_aggregats/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Fronti\u00e8res alternatives</p> <p>Imaginez que chaque <code>Lot</code> soit son propre agr\u00e9gat (pas de <code>Produit</code> englobant). Quels invariants ne pourraient plus \u00eatre garantis ? Que se passerait-il en cas d'acc\u00e8s concurrent ?</p> <p>Exercice 2 -- Verrouillage pessimiste</p> <p>Remplacez l'optimistic locking par un <code>SELECT ... FOR UPDATE</code> dans le repository SQLAlchemy. Quels sont les avantages et inconv\u00e9nients de chaque approche ?</p> <p>Exercice 3 -- Nouvel invariant</p> <p>Ajoutez la r\u00e8gle m\u00e9tier : \"un produit ne peut pas avoir plus de 10 lots actifs\". O\u00f9 cette r\u00e8gle doit-elle vivre ? Impl\u00e9mentez-la dans <code>Produit</code> et \u00e9crivez le test correspondant.</p> <p>\u00c0 retenir</p> <p>L'agr\u00e9gat est la r\u00e9ponse \u00e0 la question : \"quels objets doivent \u00eatre coh\u00e9rents entre eux ?\". Dans notre domaine, tous les lots d'un m\u00eame produit doivent \u00eatre coh\u00e9rents, donc <code>Produit</code> est l'agr\u00e9gat qui contient les <code>Lot</code>. Le <code>num\u00e9ro_version</code> garantit qu'une seule transaction \u00e0 la fois peut modifier un <code>Produit</code> donn\u00e9.</p> <p>Chapitre suivant : Events et le Message Bus -- comment les \u00e9v\u00e9nements \u00e9mis par l'agr\u00e9gat d\u00e9clenchent des actions dans le reste du syst\u00e8me.</p>"},{"location":"partie2/chapitre_08_events/","title":"Chapitre 8 -- Events et le Message Bus","text":"<p>Avant / Apr\u00e8s</p> Avant Handler appelle <code>send_email()</code>, <code>publish()</code> directement Apr\u00e8s Domaine \u00e9met events, handlers r\u00e9agissent via Message Bus <p>Pattern : Domain Events + Message Bus Probl\u00e8me r\u00e9solu : Comment r\u00e9agir aux changements du domaine sans coupler la logique m\u00e9tier aux effets de bord ?</p>"},{"location":"partie2/chapitre_08_events/#le-probleme-des-effets-de-bord","title":"Le probl\u00e8me des effets de bord","text":"<p>Jusqu'ici, notre syst\u00e8me d'allocation fait bien son travail : il choisit le bon lot, respecte les r\u00e8gles m\u00e9tier, et le Unit of Work garantit l'atomicit\u00e9 des transactions.</p> <p>Mais la r\u00e9alit\u00e9 rattrape vite une architecture trop simple. Quand une allocation r\u00e9ussit, il faut probablement :</p> <ul> <li>Envoyer un email de confirmation au client</li> <li>Mettre \u00e0 jour un tableau de bord en temps r\u00e9el</li> <li>Notifier un service externe (entrep\u00f4t, logistique, facturation)</li> <li>\u00c9mettre un \u00e9v\u00e9nement vers un bus de messages (Redis, Kafka...)</li> </ul> <p>La tentation naturelle est de tout mettre dans le handler :</p> <pre><code># NE FAITES PAS CA -- handler monolithique\ndef allouer(cmd, uow):\n    ligne = LigneDeCommande(cmd.id_commande, cmd.sku, cmd.quantit\u00e9)\n    with uow:\n        produit = uow.produits.get(sku=cmd.sku)\n        r\u00e9f_lot = produit.allouer(ligne)\n        uow.commit()\n\n    # Effets de bord empil\u00e9s...\n    send_email(\"client@example.com\", f\"Commande {cmd.id_commande} allou\u00e9e\")\n    update_dashboard(cmd.sku, r\u00e9f_lot)\n    notify_warehouse(r\u00e9f_lot, cmd.id_commande)\n    publish_to_redis(\"allocation\", {\"id_commande\": cmd.id_commande})\n    return r\u00e9f_lot\n</code></pre> <p>Ce code pose trois probl\u00e8mes s\u00e9rieux :</p> <ol> <li>Couplage : le handler conna\u00eet les d\u00e9tails de chaque syst\u00e8me externe. Si on ajoute    un nouveau consommateur, il faut modifier le handler.</li> <li>Testabilit\u00e9 : pour tester l'allocation, il faut mocker l'email, le dashboard,    l'entrep\u00f4t et Redis. Les tests deviennent fragiles et lents.</li> <li>Responsabilit\u00e9 : le handler orchestre la logique m\u00e9tier et g\u00e8re les effets de    bord. C'est une violation du Single Responsibility Principle.</li> </ol> <p>La solution ? S\u00e9parer le fait (une allocation a eu lieu) de ses cons\u00e9quences (envoyer un email, notifier un service). C'est exactement ce que permettent les Domain Events.</p>"},{"location":"partie2/chapitre_08_events/#les-domain-events","title":"Les Domain Events","text":"<p>Un Domain Event est un objet qui repr\u00e9sente un fait qui s'est produit dans le syst\u00e8me. Pas une demande, pas une intention -- un constat irr\u00e9vocable.</p> <p>La convention de nommage est importante : les events sont toujours au pass\u00e9 :</p> Event Signification <code>Allou\u00e9</code> Une ligne de commande a \u00e9t\u00e9 allou\u00e9e \u00e0 un lot <code>D\u00e9sallou\u00e9</code> Une ligne de commande a \u00e9t\u00e9 d\u00e9sallou\u00e9e <code>RuptureDeStock</code> Le stock est \u00e9puis\u00e9 pour un SKU donn\u00e9 <p>Comparez avec les commands, qui sont des demandes au pr\u00e9sent imp\u00e9ratif :</p> Command Event correspondant <code>Allouer</code> (alloue !) <code>Allou\u00e9</code> (a \u00e9t\u00e9 allou\u00e9) <code>ModifierQuantit\u00e9Lot</code> (change !) <code>D\u00e9sallou\u00e9</code> (a \u00e9t\u00e9 d\u00e9sallou\u00e9) <p>Cette distinction est fondamentale. Une command peut \u00e9chouer (stock insuffisant, SKU inexistant). Un event, lui, ne peut pas \u00e9chouer : il d\u00e9crit un fait d\u00e9j\u00e0 survenu. On ne peut pas \"refuser\" qu'une allocation ait eu lieu.</p>"},{"location":"partie2/chapitre_08_events/#la-structure-dun-event","title":"La structure d'un Event","text":"<p>Les events sont d\u00e9finis dans <code>src/allocation/domain/events.py</code>. La structure repose sur une classe de base <code>Event</code> et des dataclasses concr\u00e8tes avec <code>frozen=True</code>.</p>"},{"location":"partie2/chapitre_08_events/#la-classe-de-base","title":"La classe de base","text":"<pre><code>class Event:\n    \"\"\"Classe de base pour tous les events du domaine.\"\"\"\n    pass\n</code></pre> <p>Volontairement minimale, elle sert de marqueur de type : elle permet au message bus de distinguer un event d'une command. Pas de m\u00e9thode, pas d'attribut -- juste un contrat.</p>"},{"location":"partie2/chapitre_08_events/#les-events-concrets","title":"Les events concrets","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Allou\u00e9(Event):\n    \"\"\"Une LigneDeCommande a \u00e9t\u00e9 allou\u00e9e \u00e0 un Lot.\"\"\"\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n    r\u00e9f_lot: str\n\n@dataclass(frozen=True)\nclass D\u00e9sallou\u00e9(Event):\n    \"\"\"Une LigneDeCommande a \u00e9t\u00e9 d\u00e9sallou\u00e9e d'un Lot.\"\"\"\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n\n@dataclass(frozen=True)\nclass RuptureDeStock(Event):\n    \"\"\"Le stock est \u00e9puis\u00e9 pour un SKU donn\u00e9.\"\"\"\n    sku: str\n</code></pre>"},{"location":"partie2/chapitre_08_events/#pourquoi-frozentrue","title":"Pourquoi <code>frozen=True</code> ?","text":"<p>Le param\u00e8tre <code>frozen=True</code> rend la dataclass immutable. C'est un choix d\u00e9lib\u00e9r\u00e9 :</p> <ul> <li>Un event repr\u00e9sente un fait pass\u00e9. On ne modifie pas le pass\u00e9.</li> <li>L'immutabilit\u00e9 garantit qu'un handler ne peut pas corrompre un event avant   qu'un autre handler ne le traite.</li> <li>Un objet frozen est hashable, utilisable dans des sets ou comme cl\u00e9 de dict.</li> </ul> <pre><code>event = Allou\u00e9(id_commande=\"o1\", sku=\"LAMP\", quantit\u00e9=10, r\u00e9f_lot=\"batch-001\")\nevent.quantit\u00e9 = 5  # FrozenInstanceError !\n</code></pre> <p>Chaque event porte exactement les donn\u00e9es n\u00e9cessaires pour que ses handlers puissent travailler sans d\u00e9pendre du contexte d'\u00e9mission. <code>Allou\u00e9</code> porte l'<code>id_commande</code>, le <code>sku</code>, la <code>quantit\u00e9</code> et le <code>r\u00e9f_lot</code>. <code>RuptureDeStock</code> ne porte que le <code>sku</code>. Un event est autosuffisant : ses consommateurs n'ont pas besoin d'interroger la base de donn\u00e9es.</p>"},{"location":"partie2/chapitre_08_events/#les-agregats-emettent-des-events","title":"Les agr\u00e9gats \u00e9mettent des events","text":"<p>C'est le domaine qui sait quand quelque chose d'int\u00e9ressant se produit. Pas le handler, pas la couche service -- le domaine lui-m\u00eame. C'est donc l'agr\u00e9gat qui \u00e9met les events.</p> <p>L'agr\u00e9gat <code>Produit</code> maintient une liste d'events en attente :</p> <pre><code>class Produit:\n    def __init__(self, sku: str, lots=None, num\u00e9ro_version: int = 0):\n        self.sku = sku\n        self.lots = lots or []\n        self.num\u00e9ro_version = num\u00e9ro_version\n        self.\u00e9v\u00e9nements: list[events.Event] = []  # (1)\n</code></pre> <p>(1) La liste <code>self.\u00e9v\u00e9nements</code> est le tampon d'events. Les events y sont accumul\u00e9s pendant l'ex\u00e9cution des m\u00e9thodes m\u00e9tier, puis collect\u00e9s par le Unit of Work.</p>"},{"location":"partie2/chapitre_08_events/#emission-lors-de-lallocation","title":"\u00c9mission lors de l'allocation","text":"<p>Quand l'allocation \u00e9choue par manque de stock, le <code>Produit</code> \u00e9met un <code>RuptureDeStock</code> :</p> <pre><code>def allouer(self, ligne: LigneDeCommande) -&gt; str:\n    try:\n        lot = next(\n            l for l in sorted(self.lots) if l.peut_allouer(ligne)\n        )\n    except StopIteration:\n        self.\u00e9v\u00e9nements.append(events.RuptureDeStock(sku=ligne.sku))  # (1)\n        return \"\"\n    lot.allouer(ligne)\n    self.num\u00e9ro_version += 1\n    return lot.r\u00e9f\u00e9rence\n</code></pre> <p>(1) Plut\u00f4t que de lever une exception, le domaine enregistre un fait : \"le stock est \u00e9puis\u00e9\". C'est un changement de philosophie important.</p>"},{"location":"partie2/chapitre_08_events/#emission-lors-du-changement-de-quantite","title":"\u00c9mission lors du changement de quantit\u00e9","text":"<p>Quand la quantit\u00e9 d'un lot diminue, chaque d\u00e9sallocation g\u00e9n\u00e8re un <code>D\u00e9sallou\u00e9</code> :</p> <pre><code>def modifier_quantit\u00e9_lot(self, r\u00e9f: str, quantit\u00e9: int) -&gt; None:\n    lot = next(l for l in self.lots if l.r\u00e9f\u00e9rence == r\u00e9f)\n    lot._quantit\u00e9_achet\u00e9e = quantit\u00e9\n    while lot.quantit\u00e9_disponible &lt; 0:\n        ligne = lot.d\u00e9sallouer_une()\n        self.\u00e9v\u00e9nements.append(\n            events.D\u00e9sallou\u00e9(\n                id_commande=ligne.id_commande, sku=ligne.sku, quantit\u00e9=ligne.quantit\u00e9,\n            )\n        )\n</code></pre> <p>Si trois lignes sont d\u00e9sallou\u00e9es, il y aura trois events <code>D\u00e9sallou\u00e9</code>, et chacun pourra d\u00e9clencher une r\u00e9allocation ind\u00e9pendante.</p>"},{"location":"partie2/chapitre_08_events/#pourquoi-le-domaine-et-pas-le-handler","title":"Pourquoi le domaine et pas le handler ?","text":"<p>On pourrait \u00eatre tent\u00e9 de faire \u00e9mettre les events par le handler. Mais ce serait une erreur :</p> <ul> <li>Le domaine conna\u00eet les r\u00e8gles. C'est lui qui sait qu'une rupture de stock s'est   produite. Le handler ne fait que transmettre la demande.</li> <li>Si un autre handler appelle la m\u00eame m\u00e9thode, les events sont \u00e9mis automatiquement.</li> <li>On garde le domaine comme source de v\u00e9rit\u00e9 pour les faits m\u00e9tier.</li> </ul>"},{"location":"partie2/chapitre_08_events/#le-message-bus","title":"Le Message Bus","text":"<p>Les events sont \u00e9mis par le domaine, mais ils ne servent \u00e0 rien s'ils restent dans une liste. Il faut un m\u00e9canisme pour les router vers les bons handlers. C'est le r\u00f4le du Message Bus.</p>"},{"location":"partie2/chapitre_08_events/#la-structure","title":"La structure","text":"<p>Le Message Bus est un dispatcher d\u00e9fini dans <code>src/allocation/service_layer/messagebus.py</code> :</p> <pre><code>Message = Union[commands.Command, events.Event]\n\nclass MessageBus:\n    def __init__(\n        self,\n        uow: unit_of_work.AbstractUnitOfWork,\n        event_handlers: dict[type[events.Event], list[Callable]],\n        command_handlers: dict[type[commands.Command], Callable],\n        dependencies: dict[str, Any] | None = None,\n    ):\n        self.uow = uow\n        self.event_handlers = event_handlers\n        self.command_handlers = command_handlers\n        self.dependencies = dependencies or {}\n        self.queue: list[Message] = []\n</code></pre> <p>Le bus re\u00e7oit \u00e0 la construction le Unit of Work, un dictionnaire event_handlers (chaque event vers une liste de handlers), un dictionnaire command_handlers (chaque command vers un handler), et des d\u00e9pendances \u00e0 injecter (notifications, etc.).</p>"},{"location":"partie2/chapitre_08_events/#le-point-dentree-handle","title":"Le point d'entr\u00e9e : <code>handle()</code>","text":"<pre><code>def handle(self, message: Message) -&gt; list[Any]:\n    self.queue = [message]\n    results: list[Any] = []\n    while self.queue:\n        message = self.queue.pop(0)\n        if isinstance(message, events.Event):\n            self._handle_event(message)\n        elif isinstance(message, commands.Command):\n            result = self._handle_command(message)\n            results.append(result)\n        else:\n            raise ValueError(f\"Message de type inconnu : {type(message)}\")\n    return results\n</code></pre> <p>Le c\u0153ur du bus est cette boucle <code>while</code>, qui fonctionne comme une file de messages :</p> <ol> <li>Le message initial est plac\u00e9 dans la queue</li> <li>Tant qu'il reste des messages, on d\u00e9pile et on traite</li> <li>Chaque traitement peut g\u00e9n\u00e9rer de nouveaux events ajout\u00e9s \u00e0 la queue</li> <li>La boucle continue jusqu'\u00e0 \u00e9puisement</li> </ol> <p>C'est cette m\u00e9canique qui permet la propagation en cascade : une command peut d\u00e9clencher un event, qui d\u00e9clenche un handler, qui produit un autre event.</p>"},{"location":"partie2/chapitre_08_events/#events-vs-commands-une-asymetrie-deliberee","title":"Events vs. Commands : une asym\u00e9trie d\u00e9lib\u00e9r\u00e9e","text":"<pre><code>def _handle_event(self, event: events.Event) -&gt; None:\n    for handler in self.event_handlers.get(type(event), []):\n        try:\n            self._call_handler(handler, event)\n            self.queue.extend(self.uow.collect_new_events())\n        except Exception:\n            logger.exception(\"Erreur lors du traitement de l'event %s\", event)\n\ndef _handle_command(self, command: commands.Command) -&gt; Any:\n    handler = self.command_handlers.get(type(command))\n    if handler is None:\n        raise ValueError(f\"Aucun handler pour la command {type(command)}\")\n    result = self._call_handler(handler, command)\n    self.queue.extend(self.uow.collect_new_events())\n    return result\n</code></pre> Aspect Command Event Nombre de handlers Exactement un Z\u00e9ro, un ou plusieurs En cas d'erreur L'exception remonte L'exception est loggu\u00e9e, les autres handlers continuent Valeur de retour Peut retourner un r\u00e9sultat Pas de retour attendu <p>Une command est une demande explicite -- si elle \u00e9choue, l'appelant doit le savoir. Un event est un constat -- si l'envoi d'email \u00e9choue, ce n'est pas une raison pour annuler l'allocation.</p>"},{"location":"partie2/chapitre_08_events/#la-collecte-des-events-par-le-unit-of-work","title":"La collecte des events par le Unit of Work","text":"<p>Apr\u00e8s chaque handler, le bus appelle <code>self.uow.collect_new_events()</code> :</p> <pre><code>class AbstractUnitOfWork(abc.ABC):\n    def collect_new_events(self):\n        for produit in self.produits.seen:\n            while produit.\u00e9v\u00e9nements:\n                yield produit.\u00e9v\u00e9nements.pop(0)\n</code></pre> <p>Le UoW it\u00e8re sur tous les agr\u00e9gats vus pendant la transaction, vide leur liste d'events, et les transmet au bus. C'est le pont entre le domaine et l'infrastructure.</p>"},{"location":"partie2/chapitre_08_events/#diagramme-de-sequence-emission-et-collecte-des-events","title":"Diagramme de s\u00e9quence : \u00e9mission et collecte des events","text":"<p>Le cycle complet, de la requ\u00eate HTTP jusqu'au traitement des events :</p> <pre><code>Flask \u2500\u2500\u25ba MessageBus \u2500\u2500\u25ba handler(cmd) \u2500\u2500\u25ba Produit.allouer()\n                                               \u2502\n                                               \u25bc\n                                          \u00e9v\u00e9nements.append(Allou\u00e9)\n                                               \u2502\n               \u25c4\u2500\u2500 collect_new_events() \u25c4\u2500\u2500 uow.commit()\n               \u2502\n               \u25bc\n          handler(Allou\u00e9) \u2500\u2500\u25ba ajouter_allocation_vue()\n</code></pre> <p>Point cl\u00e9 : les events remontent du domaine via le UoW, puis sont re-dispatch\u00e9s par le bus. Le domaine n'appelle jamais directement un handler d'event \u2014 il se contente d'accumuler des faits, et l'infrastructure les achemine.</p>"},{"location":"partie2/chapitre_08_events/#les-event-handlers-concrets","title":"Les Event Handlers concrets","text":"<p>Voyons les handlers d'events d\u00e9finis dans <code>src/allocation/service_layer/handlers.py</code>.</p>"},{"location":"partie2/chapitre_08_events/#notification-de-rupture-de-stock","title":"Notification de rupture de stock","text":"<pre><code>def envoyer_notification_rupture_stock(\n    event: events.RuptureDeStock,\n    notifications: AbstractNotifications,\n) -&gt; None:\n    notifications.send(\n        destination=\"stock@example.com\",\n        message=f\"Rupture de stock pour le SKU {event.sku}\",\n    )\n</code></pre> <p>Ce handler re\u00e7oit un <code>RuptureDeStock</code> et une d\u00e9pendance <code>notifications</code> inject\u00e9e par le bus. Pas besoin du UoW, pas besoin de la base -- juste l'event et l'adapter.</p>"},{"location":"partie2/chapitre_08_events/#reallocation-apres-desallocation","title":"R\u00e9allocation apr\u00e8s d\u00e9sallocation","text":"<pre><code>def r\u00e9allouer(\n    event: events.D\u00e9sallou\u00e9,\n    uow: AbstractUnitOfWork,\n) -&gt; None:\n    allouer(\n        commands.Allouer(\n            id_commande=event.id_commande, sku=event.sku, quantit\u00e9=event.quantit\u00e9,\n        ),\n        uow=uow,\n    )\n</code></pre> <p>Quand une ligne est d\u00e9sallou\u00e9e, ce handler cr\u00e9e une nouvelle command <code>Allouer</code> et la traite. C'est une cha\u00eene r\u00e9active : un changement de quantit\u00e9 entra\u00eene des d\u00e9sallocations, qui entra\u00eenent des r\u00e9allocations.</p>"},{"location":"partie2/chapitre_08_events/#le-cablage-dans-le-bootstrap","title":"Le c\u00e2blage dans le bootstrap","text":"<p>Les associations sont d\u00e9clar\u00e9es dans <code>src/allocation/service_layer/bootstrap.py</code> :</p> <pre><code>EVENT_HANDLERS: dict[type[events.Event], list] = {\n    events.Allou\u00e9: [\n        handlers.publier_\u00e9v\u00e9nement_allocation,\n        handlers.ajouter_allocation_vue,\n    ],\n    events.D\u00e9sallou\u00e9: [\n        handlers.r\u00e9allouer,\n        handlers.supprimer_allocation_vue,\n    ],\n    events.RuptureDeStock: [handlers.envoyer_notification_rupture_stock],\n}\n\nCOMMAND_HANDLERS: dict[type[commands.Command], Any] = {\n    commands.Cr\u00e9erLot: handlers.ajouter_lot,\n    commands.Allouer: handlers.allouer,\n    commands.ModifierQuantit\u00e9Lot: handlers.modifier_quantit\u00e9_lot,\n}\n</code></pre> <p>Pour ajouter un nouveau comportement, il suffit d'ajouter un handler \u00e0 la liste -- sans modifier le code existant. C'est le principe Open/Closed en action :</p> <pre><code>events.RuptureDeStock: [\n    handlers.envoyer_notification_rupture_stock,  # email existant\n    handlers.envoyer_sms_rupture_stock,            # SMS (nouveau !)\n],\n</code></pre>"},{"location":"partie2/chapitre_08_events/#le-flux-complet","title":"Le flux complet","text":"<p>D\u00e9roulons un sc\u00e9nario de bout en bout : un changement de quantit\u00e9 de lot qui d\u00e9clenche une cascade d'events.</p>"},{"location":"partie2/chapitre_08_events/#scenario-la-quantite-dun-lot-diminue","title":"Sc\u00e9nario : la quantit\u00e9 d'un lot diminue","text":"<p>Un fournisseur informe qu'un lot de 50 \"BLUE-VASE\" ne contiendra que 20 unit\u00e9s. Trois commandes de 10 \u00e9taient allou\u00e9es. Avec 20 unit\u00e9s, une doit \u00eatre d\u00e9sallou\u00e9e.</p> <p>\u00c9tape 1 -- La command entre dans le bus :</p> <pre><code>cmd = ModifierQuantit\u00e9Lot(r\u00e9f=\"batch-001\", quantit\u00e9=20)\nbus.handle(cmd)\n</code></pre> <p>\u00c9tape 2 -- Le command handler charge le Produit et appelle la m\u00e9thode m\u00e9tier.</p> <p>\u00c9tape 3 -- Le domaine d\u00e9salloue une ligne et \u00e9met <code>D\u00e9sallou\u00e9(id_commande=\"order-3\", sku=\"BLUE-VASE\", quantit\u00e9=10)</code>.</p> <p>\u00c9tape 4 -- Le UoW collecte l'event et l'ajoute \u00e0 la queue du bus.</p> <p>\u00c9tape 5 -- Le bus d\u00e9pile le <code>D\u00e9sallou\u00e9</code> et appelle le handler <code>r\u00e9allouer</code>.</p> <p>\u00c9tape 6 -- <code>r\u00e9allouer</code> cr\u00e9e une command <code>Allouer</code> et la traite. Le syst\u00e8me tente de r\u00e9allouer la ligne \u00e0 un autre lot.</p> <p>\u00c9tape 7 -- Si la r\u00e9allocation r\u00e9ussit, un <code>Allou\u00e9</code> est \u00e9mis. S'il n'y a plus de stock, un <code>RuptureDeStock</code> d\u00e9clenche l'envoi d'une notification. La boucle continue jusqu'\u00e0 \u00e9puisement de la queue.</p>"},{"location":"partie2/chapitre_08_events/#visualisation-du-flux","title":"Visualisation du flux","text":"<pre><code>ModifierQuantit\u00e9Lot (command)\n    |\n    v\nmodifier_quantit\u00e9_lot (command handler)\n    |\n    v\nProduit.modifier_quantit\u00e9_lot() --- \u00e9met ---&gt; D\u00e9sallou\u00e9 (event)\n    |                                              |\n    v                                              v\nUoW.commit()                              r\u00e9allouer (event handler)\n                                                   |\n                                                   v\n                                           Allouer (command)\n                                                   |\n                                                   v\n                                           Produit.allouer()\n                                              /          \\\n                                        succ\u00e8s            \u00e9chec\n                                          |                |\n                                          v                v\n                                       Allou\u00e9         RuptureDeStock\n                                          |                |\n                                          v                v\n                             publier_\u00e9v\u00e9nement     envoyer_notification\n</code></pre>"},{"location":"partie2/chapitre_08_events/#resume","title":"R\u00e9sum\u00e9","text":"<p>Les Domain Events et le Message Bus r\u00e9solvent le probl\u00e8me des effets de bord en d\u00e9couplant les faits de leurs cons\u00e9quences.</p>"},{"location":"partie2/chapitre_08_events/#les-concepts-cles","title":"Les concepts cl\u00e9s","text":"Concept R\u00f4le Domain Event Objet immutable repr\u00e9sentant un fait pass\u00e9 <code>self.\u00e9v\u00e9nements</code> Tampon dans l'agr\u00e9gat o\u00f9 les events sont accumul\u00e9s Message Bus Dispatcher qui route events et commands vers leurs handlers <code>collect_new_events()</code> M\u00e9thode du UoW qui extrait les events des agr\u00e9gats Event Handler Fonction qui r\u00e9agit \u00e0 un event"},{"location":"partie2/chapitre_08_events/#les-regles-a-retenir","title":"Les r\u00e8gles \u00e0 retenir","text":"<ol> <li>Les events sont au pass\u00e9 : <code>Allou\u00e9</code>, pas <code>Allouer</code>. Ils constatent, ils ne    demandent pas.</li> <li>Les events sont immutables : <code>frozen=True</code>. Le pass\u00e9 ne change pas.</li> <li>Le domaine \u00e9met les events : c'est l'agr\u00e9gat qui sait ce qui s'est pass\u00e9, pas    le handler.</li> <li>Un event peut avoir plusieurs handlers : ajouter un comportement ne n\u00e9cessite pas    de modifier le code existant.</li> <li>Un handler d'event ne fait pas \u00e9chouer les autres : les erreurs sont loggu\u00e9es    mais la propagation continue.</li> <li>La boucle du bus traite en cascade : un handler peut g\u00e9n\u00e9rer de nouveaux events,    qui sont trait\u00e9s \u00e0 leur tour.</li> </ol>"},{"location":"partie2/chapitre_08_events/#schema-darchitecture","title":"Sch\u00e9ma d'architecture","text":"<pre><code>                    +------------------+\n                    |   Point d'entr\u00e9e |\n                    |  (API / CLI)     |\n                    +--------+---------+\n                             |\n                        Command\n                             |\n                             v\n                    +------------------+\n                    |   Message Bus    |&lt;-----------+\n                    +--------+---------+            |\n                             |                      |\n                    +--------+---------+    nouveaux events\n                    | Command Handler  |            |\n                    +--------+---------+            |\n                             |                      |\n                             v                      |\n                    +------------------+            |\n                    |     Domaine      |            |\n                    | (Produit.\u00e9v\u00e9nements) |        |\n                    +--------+---------+            |\n                             |                      |\n                             v                      |\n                    +------------------+            |\n                    |   Unit of Work   |            |\n                    | collect_events() +------------+\n                    +--------+---------+\n                             |\n                             v\n                    +------------------+\n                    | Event Handlers   |\n                    | (email, r\u00e9alloc, |\n                    |  publish, ...)   |\n                    +------------------+\n</code></pre>"},{"location":"partie2/chapitre_08_events/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Nouvel event</p> <p>Cr\u00e9ez un event <code>StockBas(sku, quantit\u00e9_restante)</code> \u00e9mis quand la quantit\u00e9 disponible d'un lot tombe sous un seuil (par exemple 10). Ajoutez un handler qui envoie une notification. \u00c9crivez le test.</p> <p>Exercice 2 -- Boucle infinie</p> <p>Que se passerait-il si un event handler \u00e9mettait le m\u00eame event qu'il traite ? Comment le message bus g\u00e8re-t-il ce cas ? Proposez une protection.</p> <p>Exercice 3 -- Event vs exception</p> <p>Dans le code actuel, <code>Produit.allouer()</code> \u00e9met un event <code>RuptureDeStock</code> au lieu de lever une exception. Quels sont les avantages de chaque approche ? Dans quels cas pr\u00e9f\u00e9rer l'exception ?</p> <p>Avec les Domain Events et le Message Bus, notre architecture gagne en extensibilit\u00e9 (ajouter des r\u00e9actions sans modifier le domaine), en testabilit\u00e9 (chaque handler se teste ind\u00e9pendamment) et en clart\u00e9 (chaque composant a une responsabilit\u00e9 unique).</p> <p>Dans le chapitre suivant, nous verrons comment le Message Bus peut devenir le point d'entr\u00e9e principal de toute l'application, en remplacement de la service layer traditionnelle.</p>"},{"location":"partie2/chapitre_09_message_bus/","title":"Chapitre 9 -- Aller plus loin avec le Message Bus","text":"<p>Avant / Apr\u00e8s</p> Avant API appelle handlers, side-effects dispers\u00e9s Apr\u00e8s Tout passe par <code>bus.handle()</code>, propagation en cascade"},{"location":"partie2/chapitre_09_message_bus/#le-message-bus-comme-cur-de-larchitecture","title":"Le Message Bus comme c\u0153ur de l'architecture","text":"<p>Dans les chapitres pr\u00e9c\u00e9dents, le message bus \u00e9tait un m\u00e9canisme secondaire : l'API appelait directement les service layer handlers, et le bus servait uniquement \u00e0 propager les events en tant que side-effects. Cette approche fonctionnait, mais elle cr\u00e9ait une asym\u00e9trie g\u00eanante : les commands et les events empruntaient des chemins diff\u00e9rents dans l'application.</p> <p>L'id\u00e9e centrale de ce chapitre est simple mais transformatrice : tout passe par le bus. Le message bus n'est plus un outil annexe -- il devient le point d'entr\u00e9e unique de l'application. Toute op\u00e9ration transite par le m\u00eame pipeline, qu'elle soit d\u00e9clench\u00e9e par une requ\u00eate HTTP, un message Redis ou un event interne. Cons\u00e9quences :</p> <ul> <li>Uniformit\u00e9 : commands et events suivent le m\u00eame chemin de dispatch.</li> <li>D\u00e9couplage : l'API ne conna\u00eet plus les handlers, seulement le bus.</li> <li>Extensibilit\u00e9 : ajouter un comportement = ajouter un handler.</li> </ul> <pre><code>                  +-----------+\n  HTTP Request --&gt;|  Flask    |\n                  |  (thin    |---&gt; Command ---&gt; MessageBus\n                  |  adapter) |                     |\n                  +-----------+                     |\n                                            +-------+-------+\n                                            |               |\n                                      Command           Event\n                                      Handler           Handlers\n                                            |               |\n                                            v               v\n                                          UoW           UoW / Adapters\n</code></pre>"},{"location":"partie2/chapitre_09_message_bus/#avant-apres-levolution-du-point-dentree","title":"Avant / Apr\u00e8s : l'\u00e9volution du point d'entr\u00e9e","text":""},{"location":"partie2/chapitre_09_message_bus/#avant-lapi-appelle-directement-les-handlers","title":"Avant : l'API appelle directement les handlers","text":"<p>Dans une architecture classique, le endpoint Flask aurait ressembl\u00e9 \u00e0 ceci :</p> <pre><code>@app.route(\"/allocate\", methods=[\"POST\"])\ndef allocate_endpoint():\n    data = request.json\n    ligne = LigneDeCommande(data[\"id_commande\"], data[\"sku\"], data[\"quantit\u00e9\"])\n    r\u00e9f_lot = services.allouer(ligne, unit_of_work.SqlAlchemyUnitOfWork())\n    return jsonify({\"r\u00e9f_lot\": r\u00e9f_lot}), 201\n</code></pre> <p>L'API connaissait les fonctions du service layer et instanciait elle-m\u00eame les d\u00e9pendances. Apr\u00e8s, dans <code>src/allocation/entrypoints/flask_app.py</code> :</p> <pre><code>bus = bootstrap.bootstrap()\n\n@app.route(\"/allocate\", methods=[\"POST\"])\ndef allocate_endpoint():\n    data = request.json\n    try:\n        cmd = commands.Allouer(\n            id_commande=data[\"orderid\"],\n            sku=data[\"sku\"],\n            quantit\u00e9=data[\"qty\"],\n        )\n        results = bus.handle(cmd)\n        r\u00e9f_lot = results.pop(0)\n    except handlers.SkuInconnu as e:\n        return jsonify({\"message\": str(e)}), 400\n\n    return jsonify({\"batchref\": r\u00e9f_lot}), 201\n</code></pre> <p>Le endpoint ne conna\u00eet plus aucun handler. Son travail se r\u00e9sume \u00e0 :</p> <ol> <li>Extraire les donn\u00e9es de la requ\u00eate HTTP.</li> <li>Construire un objet <code>Command</code>.</li> <li>Le soumettre au <code>MessageBus</code> via <code>bus.handle(cmd)</code>.</li> <li>Convertir le r\u00e9sultat en r\u00e9ponse HTTP.</li> </ol> <p>C'est un thin adapter au sens propre : une fine couche de traduction entre le protocole HTTP et le langage interne du domaine (les commands). Toute la configuration -- quels handlers r\u00e9pondent \u00e0 quels messages, quelles d\u00e9pendances sont inject\u00e9es -- est d\u00e9finie dans le bootstrap, pas dans l'API.</p>"},{"location":"partie2/chapitre_09_message_bus/#la-file-dattente-interne","title":"La file d'attente interne","text":"<p>Le c\u0153ur du m\u00e9canisme r\u00e9side dans la m\u00e9thode <code>handle()</code> du <code>MessageBus</code> et dans son attribut <code>self.queue</code> (<code>src/allocation/service_layer/messagebus.py</code>) :</p> <pre><code>class MessageBus:\n\n    def __init__(\n        self,\n        uow: unit_of_work.AbstractUnitOfWork,\n        event_handlers: dict[type[events.Event], list[Callable]],\n        command_handlers: dict[type[commands.Command], Callable],\n        dependencies: dict[str, Any] | None = None,\n    ):\n        self.uow = uow\n        self.event_handlers = event_handlers\n        self.command_handlers = command_handlers\n        self.dependencies = dependencies or {}\n        self.queue: list[Message] = []\n\n    def handle(self, message: Message) -&gt; list[Any]:\n        self.queue = [message]\n        results: list[Any] = []\n        while self.queue:\n            message = self.queue.pop(0)\n            if isinstance(message, events.Event):\n                self._handle_event(message)\n            elif isinstance(message, commands.Command):\n                result = self._handle_command(message)\n                results.append(result)\n            else:\n                raise ValueError(f\"Message de type inconnu : {type(message)}\")\n        return results\n</code></pre> <p>Le fonctionnement est le suivant :</p> <ol> <li>Le message initial (en g\u00e9n\u00e9ral une <code>Command</code>) est plac\u00e9 dans <code>self.queue</code>.</li> <li>La boucle <code>while self.queue</code> d\u00e9pile les messages un par un.</li> <li>Chaque message est dispatch\u00e9 vers le handler correspondant.</li> <li>Apr\u00e8s l'ex\u00e9cution d'un handler, les events \u00e9mis par les agr\u00e9gats sont    collect\u00e9s via <code>self.uow.collect_new_events()</code> et ajout\u00e9s \u00e0 la queue.</li> <li>La boucle continue jusqu'\u00e0 ce que la queue soit vide.</li> </ol> <p>Ce m\u00e9canisme est visible dans <code>_handle_command</code> et <code>_handle_event</code> :</p> <pre><code>def _handle_command(self, command: commands.Command) -&gt; Any:\n    handler = self.command_handlers.get(type(command))\n    if handler is None:\n        raise ValueError(f\"Aucun handler pour la command {type(command)}\")\n    result = self._call_handler(handler, command)\n    self.queue.extend(self.uow.collect_new_events())  # (1)\n    return result\n\ndef _handle_event(self, event: events.Event) -&gt; None:\n    for handler in self.event_handlers.get(type(event), []):\n        try:\n            self._call_handler(handler, event)\n            self.queue.extend(self.uow.collect_new_events())  # (2)\n        except Exception:\n            logger.exception(\"Erreur lors du traitement de l'event %s\", event)\n</code></pre> <p>(1) et (2) : apr\u00e8s chaque ex\u00e9cution de handler, on collecte les events du domaine et on les r\u00e9injecte dans la queue. C'est ce qui permet la propagation en cascade. La m\u00e9thode <code>collect_new_events</code> du Unit of Work parcourt tous les agr\u00e9gats observ\u00e9s pendant la transaction :</p> <pre><code>def collect_new_events(self):\n    for produit in self.produits.seen:\n        while produit.\u00e9v\u00e9nements:\n            yield produit.\u00e9v\u00e9nements.pop(0)\n</code></pre>"},{"location":"partie2/chapitre_09_message_bus/#difference-de-traitement-entre-commands-et-events","title":"Diff\u00e9rence de traitement entre commands et events","text":"Aspect Command Event Nombre de handlers Exactement 1 0, 1 ou N En cas d'erreur L'exception remonte \u00e0 l'appelant L'exception est logg\u00e9e, les autres handlers continuent Valeur de retour Oui (ajout\u00e9e \u00e0 <code>results</code>) Non <p>Une command est une intention qui doit aboutir ou \u00e9chouer explicitement. Un event est une notification qui ne doit pas bloquer le flux principal.</p>"},{"location":"partie2/chapitre_09_message_bus/#handlers-en-cascade","title":"Handlers en cascade","text":"<p>Le vrai int\u00e9r\u00eat de la queue interne appara\u00eet quand les handlers d\u00e9clenchent eux-m\u00eames de nouveaux events. Prenons un sc\u00e9nario concret.</p>"},{"location":"partie2/chapitre_09_message_bus/#scenario-reduction-de-la-quantite-dun-lot","title":"Sc\u00e9nario : r\u00e9duction de la quantit\u00e9 d'un lot","text":"<p>Un fournisseur nous informe qu'un lot de 50 unit\u00e9s ne contiendra finalement que 25 unit\u00e9s. Certaines lignes de commande d\u00e9j\u00e0 allou\u00e9es \u00e0 ce lot doivent \u00eatre d\u00e9sallou\u00e9es puis r\u00e9allou\u00e9es \u00e0 d'autres lots.</p> <pre><code>1. ModifierQuantit\u00e9Lot (command)\n   --&gt; modifier_quantit\u00e9_lot handler\n       --&gt; Produit.modifier_quantit\u00e9_lot()\n           --&gt; \u00e9met D\u00e9sallou\u00e9 event(s)\n2. D\u00e9sallou\u00e9 (event) ajout\u00e9 \u00e0 la queue\n   --&gt; r\u00e9allouer handler\n       --&gt; Produit.allouer()\n           --&gt; peut \u00e9mettre RuptureDeStock\n3. (optionnel) RuptureDeStock (event) ajout\u00e9 \u00e0 la queue\n   --&gt; envoyer_notification_rupture_stock handler\n       --&gt; envoie un email via l'adapter de notifications\n</code></pre> <p>Dans le domaine (<code>src/allocation/domain/model.py</code>), le mod\u00e8le \u00e9met les events sans savoir ce qui va se passer ensuite :</p> <pre><code>def modifier_quantit\u00e9_lot(self, r\u00e9f: str, quantit\u00e9: int) -&gt; None:\n    lot = next(l for l in self.lots if l.r\u00e9f\u00e9rence == r\u00e9f)\n    lot._quantit\u00e9_achet\u00e9e = quantit\u00e9\n    while lot.quantit\u00e9_disponible &lt; 0:\n        ligne = lot.d\u00e9sallouer_une()\n        self.\u00e9v\u00e9nements.append(\n            events.D\u00e9sallou\u00e9(id_commande=ligne.id_commande, sku=ligne.sku, quantit\u00e9=ligne.quantit\u00e9)\n        )\n</code></pre> <p>C\u00f4t\u00e9 handlers (<code>src/allocation/service_layer/handlers.py</code>), <code>r\u00e9allouer</code> r\u00e9agit \u00e0 l'event <code>D\u00e9sallou\u00e9</code> :</p> <pre><code>def r\u00e9allouer(event: events.D\u00e9sallou\u00e9, uow: AbstractUnitOfWork) -&gt; None:\n    allouer(\n        commands.Allouer(id_commande=event.id_commande, sku=event.sku, quantit\u00e9=event.quantit\u00e9),\n        uow=uow,\n    )\n</code></pre> <p>Et si <code>allouer()</code> \u00e9choue par manque de stock, le domaine \u00e9met un <code>RuptureDeStock</code> event, dispatch\u00e9 vers <code>envoyer_notification_rupture_stock</code> :</p> <pre><code>def envoyer_notification_rupture_stock(\n    event: events.RuptureDeStock, notifications: AbstractNotifications,\n) -&gt; None:\n    notifications.send(\n        destination=\"stock@example.com\",\n        message=f\"Rupture de stock pour le SKU {event.sku}\",\n    )\n</code></pre> <p>Personne n'a eu besoin d'orchestrer cette cascade. Le comportement \u00e9merge de la composition des handlers, pas d'un code d'orchestration central.</p>"},{"location":"partie2/chapitre_09_message_bus/#diagramme-de-sequence-la-boucle-de-la-queue","title":"Diagramme de s\u00e9quence : la boucle de la queue","text":"<p>Voici le d\u00e9roul\u00e9 complet de la queue interne pour le sc\u00e9nario ci-dessus :</p> <pre><code>queue = [ModifierQuantit\u00e9Lot]\n  \u2502\n  \u251c\u2500\u25ba modifier_quantit\u00e9_lot() \u2192 Produit \u00e9met [D\u00e9sallou\u00e9]\n  \u2502   collect_new_events() \u2192 queue = [D\u00e9sallou\u00e9]\n  \u2502\n  \u251c\u2500\u25ba r\u00e9allouer() \u2192 appelle allouer(Allouer)\n  \u2502   \u2192 Produit \u00e9met [Allou\u00e9]\n  \u2502   collect_new_events() \u2192 queue = [Allou\u00e9]\n  \u2502\n  \u251c\u2500\u25ba publier_\u00e9v\u00e9nement_allocation()\n  \u251c\u2500\u25ba ajouter_allocation_vue()\n  \u2502\n  \u2514\u2500\u25ba queue vide, fin\n</code></pre> <p>Point cl\u00e9 : un seul message initial (<code>ModifierQuantit\u00e9Lot</code>) peut d\u00e9clencher toute une cascade. Le bus d\u00e9pile les messages un par un, et chaque handler peut en produire de nouveaux. La boucle <code>while queue:</code> continue tant qu'il reste des messages \u00e0 traiter.</p>"},{"location":"partie2/chapitre_09_message_bus/#linjection-de-dependances-dans-le-bus","title":"L'injection de d\u00e9pendances dans le bus","text":"<p>Les handlers ont besoin de d\u00e9pendances (<code>uow</code>, <code>notifications</code>, etc.), mais on ne veut pas que l'appelant ait \u00e0 les fournir. La solution : le bus les injecte automatiquement en inspectant la signature de chaque handler.</p>"},{"location":"partie2/chapitre_09_message_bus/#la-methode-_call_handler","title":"La m\u00e9thode <code>_call_handler</code>","text":"<pre><code>def _call_handler(self, handler: Callable, message: Message) -&gt; Any:\n    import inspect\n\n    params = inspect.signature(handler).parameters\n    kwargs: dict[str, Any] = {}\n    for name, param in params.items():\n        if name == list(params.keys())[0]:\n            continue  # Premier param\u00e8tre = le message lui-m\u00eame\n        if name == \"uow\":\n            kwargs[name] = self.uow\n        elif name in self.dependencies:\n            kwargs[name] = self.dependencies[name]\n\n    return handler(message, **kwargs)\n</code></pre> <p>La logique est la suivante :</p> <ol> <li><code>inspect.signature(handler).parameters</code> extrait les param\u00e8tres du handler.</li> <li>Le premier param\u00e8tre est toujours le message -- on le saute.</li> <li>Pour chaque param\u00e8tre suivant, le bus cherche une correspondance :<ul> <li><code>\"uow\"</code> : on injecte le Unit of Work.</li> <li>Autre nom : on cherche dans <code>self.dependencies</code>.</li> </ul> </li> <li>Le handler est appel\u00e9 avec le message en premier et les d\u00e9pendances en    keyword arguments.</li> </ol> <p>Prenons <code>envoyer_notification_rupture_stock(event, notifications)</code>. Le bus inspecte la signature, trouve <code>\"notifications\"</code> dans <code>self.dependencies</code>, et appelle <code>handler(event, notifications=email_adapter)</code>. Le handler n'a jamais besoin de savoir d'o\u00f9 viennent ses d\u00e9pendances.</p>"},{"location":"partie2/chapitre_09_message_bus/#le-bootstrap-la-composition-root","title":"Le bootstrap : la composition root","text":"<p>L'assemblage se fait dans <code>src/allocation/service_layer/bootstrap.py</code> :</p> <pre><code>def bootstrap(\n    start_orm: bool = True,\n    uow: unit_of_work.AbstractUnitOfWork | None = None,\n    notifications_adapter: notifications.AbstractNotifications | None = None,\n    **extra_dependencies: Any,\n) -&gt; messagebus.MessageBus:\n    if start_orm:\n        orm.start_mappers()\n    if uow is None:\n        uow = unit_of_work.SqlAlchemyUnitOfWork()\n    if notifications_adapter is None:\n        notifications_adapter = notifications.EmailNotifications()\n\n    dependencies: dict[str, Any] = {\n        \"notifications\": notifications_adapter,\n        **extra_dependencies,\n    }\n    return messagebus.MessageBus(\n        uow=uow,\n        event_handlers=EVENT_HANDLERS,\n        command_handlers=COMMAND_HANDLERS,\n        dependencies=dependencies,\n    )\n</code></pre> <p>La cl\u00e9 <code>\"notifications\"</code> dans le dictionnaire doit correspondre exactement au nom du param\u00e8tre dans la signature du handler. Le nom du param\u00e8tre fait office de contrat. Le mapping handlers/messages est d\u00e9clar\u00e9 explicitement :</p> <pre><code>EVENT_HANDLERS = {\n    events.Allou\u00e9: [\n        handlers.publier_\u00e9v\u00e9nement_allocation,\n        handlers.ajouter_allocation_vue,\n    ],\n    events.D\u00e9sallou\u00e9: [\n        handlers.r\u00e9allouer,\n        handlers.supprimer_allocation_vue,\n    ],\n    events.RuptureDeStock: [handlers.envoyer_notification_rupture_stock],\n}\nCOMMAND_HANDLERS = {\n    commands.Cr\u00e9erLot: handlers.ajouter_lot,\n    commands.Allouer: handlers.allouer,\n    commands.ModifierQuantit\u00e9Lot: handlers.modifier_quantit\u00e9_lot,\n}\n</code></pre> <p>Pour les tests, on injecte des fakes sans toucher au code de production :</p> <pre><code>bus = bootstrap.bootstrap(\n    start_orm=False,\n    uow=FakeUnitOfWork(),\n    notifications_adapter=FakeNotifications(),\n)\nbus.handle(commands.Cr\u00e9erLot(r\u00e9f=\"batch-001\", sku=\"TABLE\", quantit\u00e9=100))\n</code></pre>"},{"location":"partie2/chapitre_09_message_bus/#resume-le-nouveau-schema-darchitecture","title":"R\u00e9sum\u00e9 : le nouveau sch\u00e9ma d'architecture","text":"<pre><code>  Entrypoints             Service Layer              Domain\n (thin adapters)       (MessageBus + Handlers)       (Model)\n +--------------+     +--------------------+     +------------------+\n | Flask API    | cmd |    MessageBus      |     |  Produit         |\n | Redis sub    |----&gt;|  1. queue = [cmd]  |     |  Lot             |\n | CLI          |     |  2. dispatch       |     |  LigneDeCommande |\n +--------------+     |  3. collect events |     +--------+---------+\n                      |  4. repeat         |              |\n                      |  Handlers + Deps   |&lt;-- events----+\n                      +--------------------+\n</code></pre>"},{"location":"partie2/chapitre_09_message_bus/#principes-cles","title":"Principes cl\u00e9s","text":"<ol> <li> <p>Un seul point d'entr\u00e9e : tout passe par <code>bus.handle(message)</code>. Que    l'appelant soit un endpoint Flask, un subscriber Redis ou un test unitaire,    le chemin est identique.</p> </li> <li> <p>Propagation automatique : les events \u00e9mis par le domaine sont collect\u00e9s    et trait\u00e9s sans intervention. Aucun code d'orchestration n'est n\u00e9cessaire.</p> </li> <li> <p>Injection par introspection : le bus injecte les d\u00e9pendances dans les    handlers en inspectant leurs signatures. Les handlers d\u00e9clarent ce dont ils    ont besoin, le bus fournit.</p> </li> <li> <p>S\u00e9paration des responsabilit\u00e9s :</p> <ul> <li>Les entrypoints traduisent les entr\u00e9es externes en commands.</li> <li>Le bus dispatche et orchestre.</li> <li>Les handlers contiennent la logique applicative.</li> <li>Le domaine contient les r\u00e8gles m\u00e9tier et \u00e9met des events.</li> </ul> </li> <li> <p>Testabilit\u00e9 : le bootstrap accepte des fakes pour chaque d\u00e9pendance,    rendant les tests rapides et isol\u00e9s.</p> </li> </ol>"},{"location":"partie2/chapitre_09_message_bus/#ce-que-nous-avons-gagne","title":"Ce que nous avons gagn\u00e9","text":"Avant Apr\u00e8s L'API appelle les handlers directement L'API envoie des commands au bus Les d\u00e9pendances sont pass\u00e9es manuellement Les d\u00e9pendances sont inject\u00e9es automatiquement Les side-effects sont g\u00e9r\u00e9s \u00e0 part Tout transite par le bus, commands comme events Ajouter un comportement = modifier du code Ajouter un handler + l'enregistrer dans le bootstrap Tests coupl\u00e9s aux d\u00e9tails d'impl\u00e9mentation Tests via le bus avec des fakes inject\u00e9es"},{"location":"partie2/chapitre_09_message_bus/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Ajouter un middleware</p> <p>Modifiez <code>_call_handler</code> pour logger le temps d'ex\u00e9cution de chaque handler. V\u00e9rifiez que les tests passent toujours.</p> <p>Exercice 2 -- Handler asynchrone</p> <p>Comment adapteriez-vous le message bus pour supporter des handlers <code>async</code> ? Quelles parties de l'architecture changeraient ?</p> <p>Exercice 3 -- Compteur de messages</p> <p>Ajoutez un attribut <code>self.messages_processed: int</code> au <code>MessageBus</code> qui compte le nombre total de messages (commands + events) trait\u00e9s. \u00c9crivez un test qui v\u00e9rifie que le compteur est correct apr\u00e8s une cascade command \u2192 event \u2192 handler.</p> <p>Le message bus est devenu la colonne vert\u00e9brale de l'application. Toute l'intelligence est dans les handlers et le domaine ; le bus ne fait que distribuer les messages et injecter les d\u00e9pendances. Cette simplicit\u00e9 apparente cache une grande puissance : on peut ajouter des comportements complexes (cascades d'events, notifications, publication externe) sans jamais modifier le code existant.</p>"},{"location":"partie2/chapitre_10_commands/","title":"Chapitre 10 -- Commands et Events : distinguer les intentions des faits","text":"<p>Avant / Apr\u00e8s</p> Avant Commands et events trait\u00e9s identiquement Apr\u00e8s Commands (1 handler, exception) vs Events (N handlers, silencieux) <p>Jusqu'ici, notre message bus traite des messages. Mais tous les messages ne se valent pas. Quand l'API envoie une demande d'allocation, c'est une instruction explicite : \"alloue cette ligne de commande\". Quand le domaine signale qu'un produit est en rupture de stock, c'est un constat : \"le stock est \u00e9puis\u00e9\".</p> <p>Cette distinction n'est pas cosm\u00e9tique. Elle a des cons\u00e9quences concr\u00e8tes sur la mani\u00e8re dont le syst\u00e8me traite ces messages, sur la gestion des erreurs, et sur le couplage entre les composants.</p> <p>Dans ce chapitre, nous allons formaliser cette distinction en introduisant deux types de messages : les commands et les events.</p>"},{"location":"partie2/chapitre_10_commands/#la-distinction-fondamentale","title":"La distinction fondamentale","text":"<p>La diff\u00e9rence tient en une phrase :</p> <p>Une command est une intention -- quelque chose qui doit \u00eatre fait. Un event est un fait -- quelque chose qui s'est produit.</p> <p>Prenons un exemple concret dans notre domaine d'allocation de stock :</p> <ul> <li> <p><code>Allouer</code> est une command : \"je veux que cette ligne soit allou\u00e9e\". C'est une   demande adress\u00e9e au syst\u00e8me. Elle peut r\u00e9ussir ou \u00e9chouer, et l'appelant veut   savoir lequel des deux s'est produit.</p> </li> <li> <p><code>Allou\u00e9</code> est un event : \"cette ligne a \u00e9t\u00e9 allou\u00e9e au lot batch-001\". C'est   un fait accompli. On ne peut pas \"refuser\" un fait. On peut seulement y   r\u00e9agir.</p> </li> </ul> <p>Pensez-y comme la diff\u00e9rence entre dire \"R\u00e9serve-moi une table pour 20h\" (command) et \"La table 12 a \u00e9t\u00e9 r\u00e9serv\u00e9e pour 20h\" (event). La premi\u00e8re est une demande qui peut \u00eatre d\u00e9clin\u00e9e. La seconde est une information que le restaurant diffuse \u00e0 qui veut l'entendre -- le serveur, le chef, le syst\u00e8me de r\u00e9servation en ligne.</p>"},{"location":"partie2/chapitre_10_commands/#les-classes-command","title":"Les classes Command","text":"<p>Les commands vivent dans leur propre module, s\u00e9par\u00e9 des events. Voici notre fichier <code>commands.py</code> :</p> src/allocation/domain/commands.py<pre><code>\"\"\"\nCommands du domaine.\n\nLes commands repr\u00e9sentent des intentions : quelque chose que\nle syst\u00e8me doit faire. Contrairement aux events (faits pass\u00e9s),\nles commands sont des demandes qui peuvent \u00e9chouer.\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom datetime import date\nfrom typing import Optional\n\n\nclass Command:\n    \"\"\"Classe de base pour toutes les commands.\"\"\"\n    pass\n\n\n@dataclass(frozen=True)\nclass Cr\u00e9erLot(Command):\n    \"\"\"Demande de cr\u00e9ation d'un nouveau lot de stock.\"\"\"\n\n    r\u00e9f: str\n    sku: str\n    quantit\u00e9: int\n    eta: Optional[date] = None\n\n\n@dataclass(frozen=True)\nclass Allouer(Command):\n    \"\"\"Demande d'allocation d'une ligne de commande.\"\"\"\n\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n\n\n@dataclass(frozen=True)\nclass ModifierQuantit\u00e9Lot(Command):\n    \"\"\"Demande de modification de la quantit\u00e9 d'un lot.\"\"\"\n\n    r\u00e9f: str\n    quantit\u00e9: int\n</code></pre> <p>Et voici les events correspondants dans <code>events.py</code> :</p> src/allocation/domain/events.py<pre><code>\"\"\"\nEvents du domaine.\n\nLes events repr\u00e9sentent des faits qui se sont produits dans le syst\u00e8me.\nIls sont immuables et nomm\u00e9s au pass\u00e9 (quelque chose s'est pass\u00e9).\n\"\"\"\n\nfrom dataclasses import dataclass\n\n\nclass Event:\n    \"\"\"Classe de base pour tous les events du domaine.\"\"\"\n    pass\n\n\n@dataclass(frozen=True)\nclass Allou\u00e9(Event):\n    \"\"\"Une LigneDeCommande a \u00e9t\u00e9 allou\u00e9e \u00e0 un Lot.\"\"\"\n\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n    r\u00e9f_lot: str\n\n\n@dataclass(frozen=True)\nclass D\u00e9sallou\u00e9(Event):\n    \"\"\"Une LigneDeCommande a \u00e9t\u00e9 d\u00e9sallou\u00e9e d'un Lot.\"\"\"\n\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n\n\n@dataclass(frozen=True)\nclass RuptureDeStock(Event):\n    \"\"\"Le stock est \u00e9puis\u00e9 pour un SKU donn\u00e9.\"\"\"\n\n    sku: str\n</code></pre>"},{"location":"partie2/chapitre_10_commands/#pourquoi-deux-fichiers-separes","title":"Pourquoi deux fichiers s\u00e9par\u00e9s ?","text":"<p>Trois raisons motivent cette s\u00e9paration :</p> <ol> <li> <p>Clart\u00e9 s\u00e9mantique. Un d\u00e9veloppeur qui ouvre <code>commands.py</code> sait    imm\u00e9diatement qu'il regarde les actions que le syst\u00e8me sait ex\u00e9cuter. Celui    qui ouvre <code>events.py</code> voit les choses qui peuvent se produire dans le    domaine. Ce sont deux catalogues distincts.</p> </li> <li> <p>Conventions de nommage diff\u00e9rentes. Les commands sont nomm\u00e9es \u00e0    l'imp\u00e9ratif (<code>Cr\u00e9erLot</code>, <code>Allouer</code>, <code>ModifierQuantit\u00e9Lot</code>) : ce sont    des ordres. Les events sont nomm\u00e9s au pass\u00e9 compos\u00e9 (<code>Allou\u00e9</code>,    <code>D\u00e9sallou\u00e9</code>, <code>RuptureDeStock</code>) : ce sont des constats.</p> </li> <li> <p>Cycle de vie diff\u00e9rent. Les commands viennent de l'ext\u00e9rieur du domaine    (API, CLI, autre service). Les events sont \u00e9mis par le domaine lui-m\u00eame. Les    s\u00e9parer refl\u00e8te cette diff\u00e9rence d'origine.</p> </li> </ol> <p>frozen=True</p> <p>Les deux types utilisent <code>frozen=True</code>. Un message -- qu'il soit command ou event -- est un objet immuable. On ne modifie pas une intention apr\u00e8s l'avoir formul\u00e9e, et on ne r\u00e9\u00e9crit pas l'histoire.</p>"},{"location":"partie2/chapitre_10_commands/#caracteristiques-des-commands","title":"Caract\u00e9ristiques des Commands","text":"<p>Les commands ont quatre propri\u00e9t\u00e9s distinctives :</p>"},{"location":"partie2/chapitre_10_commands/#1-nommees-a-limperatif","title":"1. Nomm\u00e9es \u00e0 l'imp\u00e9ratif","text":"<p>Le nom d'une command exprime ce que l'on veut que le syst\u00e8me fasse :</p> Command Signification <code>Cr\u00e9erLot</code> \"Cr\u00e9e un nouveau lot\" <code>Allouer</code> \"Alloue cette ligne de commande\" <code>ModifierQuantit\u00e9Lot</code> \"Modifie la quantit\u00e9 de ce lot\" <p>On parle au syst\u00e8me comme on parlerait \u00e0 un coll\u00e8gue : \"Fais ceci.\"</p>"},{"location":"partie2/chapitre_10_commands/#2-exactement-un-handler","title":"2. Exactement un handler","text":"<p>Chaque command est prise en charge par un seul handler. C'est logique : si quelqu'un vous demande de faire quelque chose, il y a un responsable pour ex\u00e9cuter cette demande, pas z\u00e9ro, pas trois.</p> bootstrap.py -- enregistrement des command handlers<pre><code>COMMAND_HANDLERS: dict[type[commands.Command], Any] = {\n    commands.Cr\u00e9erLot: handlers.ajouter_lot,\n    commands.Allouer: handlers.allouer,\n    commands.ModifierQuantit\u00e9Lot: handlers.modifier_quantit\u00e9_lot,\n}\n</code></pre> <p>Remarquez le type : <code>dict[type[commands.Command], Callable]</code> -- une seule fonction par command, pas une liste.</p> <p>Si aucun handler n'est enregistr\u00e9 pour une command, c'est une erreur de configuration. Le message bus l\u00e8vera une <code>ValueError</code> :</p> <pre><code>handler = self.command_handlers.get(type(command))\nif handler is None:\n    raise ValueError(f\"Aucun handler pour la command {type(command)}\")\n</code></pre>"},{"location":"partie2/chapitre_10_commands/#3-les-erreurs-remontent","title":"3. Les erreurs remontent","text":"<p>Quand un command handler \u00e9choue, l'exception remonte jusqu'\u00e0 l'appelant. C'est le comportement attendu : si vous demandez au syst\u00e8me d'allouer une ligne et que le SKU n'existe pas, vous voulez le savoir imm\u00e9diatement.</p> handlers.py -- un handler qui peut lever une exception<pre><code>def allouer(\n    cmd: commands.Allouer,\n    uow: AbstractUnitOfWork,\n) -&gt; str:\n    ligne = model.LigneDeCommande(id_commande=cmd.id_commande, sku=cmd.sku, quantit\u00e9=cmd.quantit\u00e9)\n    with uow:\n        produit = uow.produits.get(sku=cmd.sku)\n        if produit is None:\n            raise SkuInconnu(f\"SKU inconnu : {cmd.sku}\")\n        r\u00e9f_lot = produit.allouer(ligne)\n        uow.commit()\n    return r\u00e9f_lot\n</code></pre> <p>L'API Flask peut alors attraper cette exception et retourner un code HTTP adapt\u00e9 :</p> flask_app.py -- l'API traduit l'erreur en r\u00e9ponse HTTP<pre><code>try:\n    cmd = commands.Allouer(\n        id_commande=data[\"id_commande\"],\n        sku=data[\"sku\"],\n        quantit\u00e9=data[\"quantit\u00e9\"],\n    )\n    results = bus.handle(cmd)\n    r\u00e9f_lot = results.pop(0)\nexcept handlers.SkuInconnu as e:\n    return jsonify({\"message\": str(e)}), 400\n</code></pre>"},{"location":"partie2/chapitre_10_commands/#4-dirigees-vers-un-destinataire-precis","title":"4. Dirig\u00e9es vers un destinataire pr\u00e9cis","text":"<p>Une command a un destinataire clair. <code>Allouer</code> est destin\u00e9e au handler <code>allouer</code>. Il n'y a pas d'ambiguit\u00e9, pas de broadcast. C'est une communication point-\u00e0-point.</p>"},{"location":"partie2/chapitre_10_commands/#caracteristiques-des-events","title":"Caract\u00e9ristiques des Events","text":"<p>Les events pr\u00e9sentent des propri\u00e9t\u00e9s sym\u00e9triquement oppos\u00e9es :</p>"},{"location":"partie2/chapitre_10_commands/#1-nommes-au-passe","title":"1. Nomm\u00e9s au pass\u00e9","text":"<p>Un event d\u00e9crit quelque chose qui s'est d\u00e9j\u00e0 produit :</p> Event Signification <code>Allou\u00e9</code> \"Une ligne a \u00e9t\u00e9 allou\u00e9e\" <code>D\u00e9sallou\u00e9</code> \"Une ligne a \u00e9t\u00e9 d\u00e9sallou\u00e9e\" <code>RuptureDeStock</code> \"Le stock est \u00e9puis\u00e9\" <p>On ne dit pas \"D\u00e9salloue\" (ce serait une command), on dit \"\u00c7a a \u00e9t\u00e9 d\u00e9sallou\u00e9\".</p>"},{"location":"partie2/chapitre_10_commands/#2-zero-un-ou-n-handlers","title":"2. Z\u00e9ro, un ou N handlers","text":"<p>Un event peut int\u00e9resser plusieurs parties du syst\u00e8me, ou aucune. C'est du broadcast : l'\u00e9metteur ne sait pas (et ne devrait pas savoir) qui \u00e9coute.</p> bootstrap.py -- enregistrement des event handlers<pre><code>EVENT_HANDLERS: dict[type[events.Event], list] = {\n    events.Allou\u00e9: [\n        handlers.publier_\u00e9v\u00e9nement_allocation,\n        handlers.ajouter_allocation_vue,\n    ],\n    events.D\u00e9sallou\u00e9: [\n        handlers.r\u00e9allouer,\n        handlers.supprimer_allocation_vue,\n    ],\n    events.RuptureDeStock: [handlers.envoyer_notification_rupture_stock],\n}\n</code></pre> <p>Remarquez le type : <code>dict[type[events.Event], list[Callable]]</code> -- une liste de handlers par event. Demain, si l'on veut aussi envoyer un SMS en cas de rupture de stock, il suffit d'ajouter un handler \u00e0 la liste de <code>RuptureDeStock</code> :</p> <pre><code>events.RuptureDeStock: [\n    handlers.envoyer_notification_rupture_stock,\n    handlers.envoyer_sms_responsable_entrep\u00f4t,  # nouveau handler\n],\n</code></pre> <p>L'\u00e9metteur de l'event <code>RuptureDeStock</code> n'a pas besoin d'\u00eatre modifi\u00e9. C'est l'Open/Closed Principle en action.</p>"},{"location":"partie2/chapitre_10_commands/#3-les-erreurs-sont-capturees","title":"3. Les erreurs sont captur\u00e9es","text":"<p>Quand un event handler \u00e9choue, l'erreur est logu\u00e9e mais pas propag\u00e9e. Les autres handlers continuent de s'ex\u00e9cuter. C'est fondamental : un fait s'est produit, et toutes les parties int\u00e9ress\u00e9es doivent avoir la chance d'en \u00eatre inform\u00e9es, m\u00eame si l'une d'elles rencontre un probl\u00e8me.</p> <p>Si l'envoi du SMS \u00e9choue, \u00e7a ne doit pas emp\u00eacher la notification par email.</p>"},{"location":"partie2/chapitre_10_commands/#4-broadcast","title":"4. Broadcast","text":"<p>L'\u00e9metteur d'un event ne choisit pas ses destinataires. Il se contente de dire \"Voil\u00e0 ce qui s'est pass\u00e9\" et le message bus se charge de distribuer l'information. N'importe quel composant peut s'abonner.</p>"},{"location":"partie2/chapitre_10_commands/#le-dispatch-differencie-dans-le-messagebus","title":"Le dispatch diff\u00e9renci\u00e9 dans le MessageBus","text":"<p>La distinction command/event se mat\u00e9rialise dans deux m\u00e9thodes s\u00e9par\u00e9es du message bus. Comparons-les :</p> src/allocation/service_layer/messagebus.py<pre><code>class MessageBus:\n\n    def handle(self, message: Message) -&gt; list[Any]:\n        \"\"\"Point d'entr\u00e9e principal.\"\"\"\n        self.queue = [message]\n        results: list[Any] = []\n        while self.queue:\n            message = self.queue.pop(0)\n            if isinstance(message, events.Event):\n                self._handle_event(message)          # (1)\n            elif isinstance(message, commands.Command):\n                result = self._handle_command(message)  # (2)\n                results.append(result)\n            else:\n                raise ValueError(f\"Message de type inconnu : {type(message)}\")\n        return results\n</code></pre> <ol> <li>Les events sont d\u00e9l\u00e9gu\u00e9s \u00e0 <code>_handle_event</code>.</li> <li>Les commands sont d\u00e9l\u00e9gu\u00e9es \u00e0 <code>_handle_command</code>, et leur r\u00e9sultat est    collect\u00e9.</li> </ol>"},{"location":"partie2/chapitre_10_commands/#_handle_command-strict-et-direct","title":"<code>_handle_command</code> : strict et direct","text":"<pre><code>def _handle_command(self, command: commands.Command) -&gt; Any:\n    \"\"\"Dispatch une command vers son unique handler.\"\"\"\n    logger.debug(\"Traitement de la command %s\", command)\n    handler = self.command_handlers.get(type(command))\n    if handler is None:\n        raise ValueError(f\"Aucun handler pour la command {type(command)}\")\n    result = self._call_handler(handler, command)\n    self.queue.extend(self.uow.collect_new_events())\n    return result\n</code></pre> <p>Points cl\u00e9s :</p> <ul> <li>Un seul handler est recherch\u00e9 (pas une liste).</li> <li>Si le handler est absent, une <code>ValueError</code> est lev\u00e9e.</li> <li>Les exceptions du handler ne sont pas attrap\u00e9es : elles remontent   naturellement \u00e0 l'appelant.</li> <li>Le r\u00e9sultat du handler est retourn\u00e9 (utile pour <code>allouer</code> qui retourne   le <code>r\u00e9f_lot</code>).</li> </ul>"},{"location":"partie2/chapitre_10_commands/#_handle_event-tolerant-et-exhaustif","title":"<code>_handle_event</code> : tol\u00e9rant et exhaustif","text":"<pre><code>def _handle_event(self, event: events.Event) -&gt; None:\n    \"\"\"Dispatch un event vers tous ses handlers.\"\"\"\n    for handler in self.event_handlers.get(type(event), []):\n        try:\n            logger.debug(\"Traitement de l'event %s avec %s\", event, handler)\n            self._call_handler(handler, event)\n            self.queue.extend(self.uow.collect_new_events())\n        except Exception:\n            logger.exception(\"Erreur lors du traitement de l'event %s\", event)\n</code></pre> <p>Points cl\u00e9s :</p> <ul> <li>Tous les handlers sont ex\u00e9cut\u00e9s (boucle <code>for</code>).</li> <li>Si aucun handler n'est enregistr\u00e9, <code>get(..., [])</code> retourne une liste vide :   aucune erreur, l'event est simplement ignor\u00e9.</li> <li>Chaque handler est envelopp\u00e9 dans un <code>try/except</code>. Si l'un \u00e9choue, les   autres continuent.</li> <li>Les erreurs sont loggu\u00e9es via <code>logger.exception</code>, pas propag\u00e9es.</li> <li>La m\u00e9thode ne retourne rien (<code>None</code>).</li> </ul>"},{"location":"partie2/chapitre_10_commands/#le-contraste-resume-en-code","title":"Le contraste r\u00e9sum\u00e9 en code","text":"<p>Le tableau suivant met en parall\u00e8le les deux approches :</p> <pre><code>_handle_command                    _handle_event\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUN handler par command             N handlers par event\nhandler absent = ValueError        handler absent = rien ne se passe\nexception = propag\u00e9e               exception = loggu\u00e9e, on continue\nretourne un r\u00e9sultat               ne retourne rien\n</code></pre>"},{"location":"partie2/chapitre_10_commands/#diagrammes-de-sequence-deux-chemins-asymetriques","title":"Diagrammes de s\u00e9quence : deux chemins asym\u00e9triques","text":"<p>Command (strict) \u2014 un handler, exceptions remont\u00e9es :</p> <pre><code>bus.handle(Allouer)\n  \u2514\u2500\u25ba lookup 1 handler \u2192 allouer()\n       \u251c\u2500\u25ba succ\u00e8s \u2192 return r\u00e9f_lot \u2192 r\u00e9sultat au caller\n       \u2514\u2500\u25ba \u00e9chec \u2192 raise SkuInconnu \u2192 exception remonte\n</code></pre> <p>Event (tol\u00e9rant) \u2014 N handlers, erreurs captur\u00e9es :</p> <pre><code>bus.handle(Allou\u00e9)\n  \u2514\u2500\u25ba lookup N handlers\n       \u251c\u2500\u25ba publier_\u00e9v\u00e9nement_allocation() \u2192 OK\n       \u251c\u2500\u25ba ajouter_allocation_vue() \u2192 OK\n       \u2514\u2500\u25ba (si erreur) \u2192 logger.exception() \u2192 continue\n</code></pre> <p>Point cl\u00e9 : l'asym\u00e9trie entre les deux types de messages est au c\u0153ur du design. Une command est une promesse de traitement (succ\u00e8s ou \u00e9chec explicite). Un event est une notification best-effort (tous les handlers sont essay\u00e9s, aucun ne bloque les autres).</p>"},{"location":"partie2/chapitre_10_commands/#de-lapi-au-domaine-le-parcours-dun-message","title":"De l'API au domaine : le parcours d'un message","text":"<p>Pour bien comprendre comment les deux types de messages coop\u00e8rent, suivons le parcours d'un changement de quantit\u00e9 de lot.</p> <p>\u00c9tape 1 -- L'API re\u00e7oit une requ\u00eate HTTP et cr\u00e9e une command.</p> <pre><code>cmd = commands.ModifierQuantit\u00e9Lot(r\u00e9f=\"batch-001\", quantit\u00e9=5)\nbus.handle(cmd)\n</code></pre> <p>C'est une command : quelqu'un demande au syst\u00e8me de modifier une quantit\u00e9. Si le lot n'existe pas, on veut une erreur.</p> <p>\u00c9tape 2 -- Le command handler s'ex\u00e9cute.</p> <pre><code>def modifier_quantit\u00e9_lot(cmd, uow):\n    with uow:\n        produit = uow.produits.get_par_r\u00e9f_lot(r\u00e9f_lot=cmd.r\u00e9f)\n        produit.modifier_quantit\u00e9_lot(r\u00e9f=cmd.r\u00e9f, quantit\u00e9=cmd.quantit\u00e9)\n        uow.commit()\n</code></pre> <p>Le mod\u00e8le de domaine ajuste la quantit\u00e9. Si des lignes doivent \u00eatre d\u00e9sallou\u00e9es, il \u00e9met un event <code>D\u00e9sallou\u00e9</code> sur l'agr\u00e9gat.</p> <p>\u00c9tape 3 -- Le message bus collecte les events et les traite.</p> <p>L'event <code>D\u00e9sallou\u00e9(id_commande=\"o1\", sku=\"SMALL-TABLE\", quantit\u00e9=10)</code> est ajout\u00e9 \u00e0 la queue. Le bus le dispatche vers son handler :</p> <pre><code>def r\u00e9allouer(event: events.D\u00e9sallou\u00e9, uow):\n    allouer(\n        commands.Allouer(\n            id_commande=event.id_commande,\n            sku=event.sku,\n            quantit\u00e9=event.quantit\u00e9,\n        ),\n        uow=uow,\n    )\n</code></pre> <p>Notez que le handler d'event cr\u00e9e une command (<code>Allouer</code>) pour r\u00e9allouer. C'est un pattern courant : un event d\u00e9clenche une action, et cette action est formul\u00e9e comme une command.</p> <p>\u00c9tape 4 -- L'allocation r\u00e9ussit ou \u00e9met un <code>RuptureDeStock</code>.</p> <p>Si le stock est insuffisant, le domaine \u00e9met <code>RuptureDeStock(sku=\"SMALL-TABLE\")</code>, ce qui d\u00e9clenche l'envoi d'une notification. Si un handler de notification \u00e9choue, l'erreur est loggu\u00e9e mais ne fait pas \u00e9chouer la cha\u00eene.</p> <pre><code>ModifierQuantit\u00e9Lot (command)\n    \u2514\u2500\u2500 modifier_quantit\u00e9_lot handler\n            \u2514\u2500\u2500 D\u00e9sallou\u00e9 (event)\n                    \u2514\u2500\u2500 r\u00e9allouer handler\n                            \u2514\u2500\u2500 Allou\u00e9 (event) ... ou RuptureDeStock (event)\n                                                          \u2514\u2500\u2500 envoyer_notification\n</code></pre>"},{"location":"partie2/chapitre_10_commands/#quand-creer-une-command-vs-un-event","title":"Quand cr\u00e9er une Command vs un Event ?","text":"<p>La r\u00e8gle est simple :</p> <p>La r\u00e8gle d'or</p> <p>Demande ext\u00e9rieure = Command. Un utilisateur, une API, un fichier CSV, un message d'un autre service demande au syst\u00e8me de faire quelque chose.</p> <p>R\u00e9action interne = Event. Le domaine constate que quelque chose s'est produit et en informe le reste du syst\u00e8me.</p> <p>Quelques exemples pour illustrer :</p> Situation Type Pourquoi L'API re\u00e7oit <code>POST /allocate</code> Command Demande explicite d'un acteur ext\u00e9rieur Un fichier CSV contient de nouveaux lots Command Le fichier demande la cr\u00e9ation des lots Le domaine constate qu'une ligne a \u00e9t\u00e9 allou\u00e9e Event Fait interne, broadcast \u00e0 qui veut l'entendre La quantit\u00e9 d'un lot diminue et des lignes d\u00e9bordent Event Le domaine constate la d\u00e9sallocation Un autre service demande de modifier un lot Command Demande explicite, m\u00eame si elle vient d'un service Le stock tombe \u00e0 z\u00e9ro Event Constat, les int\u00e9ress\u00e9s r\u00e9agissent comme ils l'entendent"},{"location":"partie2/chapitre_10_commands/#cas-particulier-les-reactions-en-chaine","title":"Cas particulier : les r\u00e9actions en cha\u00eene","text":"<p>Comme on l'a vu dans le parcours ci-dessus, un event handler peut lui-m\u00eame \u00e9mettre des commands ou des events. Le handler <code>r\u00e9allouer</code> r\u00e9agit \u00e0 un event <code>D\u00e9sallou\u00e9</code> en cr\u00e9ant une command <code>Allouer</code>. C'est parfaitement normal :</p> <ul> <li>L'event <code>D\u00e9sallou\u00e9</code> est un fait : \"cette ligne a \u00e9t\u00e9 d\u00e9sallou\u00e9e\".</li> <li>La command <code>Allouer</code> est une intention : \"r\u00e9alloue cette ligne\".</li> </ul> <p>Le fait d\u00e9clenche l'intention. L'intention peut r\u00e9ussir ou \u00e9chouer. Si elle \u00e9choue dans un handler d'event, l'erreur est loggu\u00e9e.</p>"},{"location":"partie2/chapitre_10_commands/#resume","title":"R\u00e9sum\u00e9","text":""},{"location":"partie2/chapitre_10_commands/#tableau-comparatif","title":"Tableau comparatif","text":"Aspect Command Event S\u00e9mantique Intention (quelque chose \u00e0 faire) Fait (quelque chose s'est produit) Nommage Imp\u00e9ratif : <code>Allouer</code> Pass\u00e9 : <code>Allou\u00e9</code> Nombre de handlers Exactement 1 0, 1 ou N Erreur du handler Propag\u00e9e \u00e0 l'appelant Loggu\u00e9e, les autres continuent R\u00e9sultat Peut retourner une valeur Pas de valeur de retour Origine Ext\u00e9rieure (API, CLI, service) Interne (domaine, handler) Communication Point-\u00e0-point Broadcast Handler absent <code>ValueError</code> Silencieux (liste vide)"},{"location":"partie2/chapitre_10_commands/#ce-que-nous-avons-appris","title":"Ce que nous avons appris","text":"<ul> <li> <p>Les commands et les events sont les deux types de messages qui   circulent dans notre message bus. Les distinguer n'est pas un luxe   acad\u00e9mique : cela d\u00e9termine la gestion des erreurs, le couplage entre   composants, et l'extensibilit\u00e9 du syst\u00e8me.</p> </li> <li> <p>Les commands sont des demandes explicites, nomm\u00e9es \u00e0 l'imp\u00e9ratif, avec un   handler unique qui peut \u00e9chouer bruyamment. Elles viennent de l'ext\u00e9rieur du   domaine.</p> </li> <li> <p>Les events sont des faits constat\u00e9s, nomm\u00e9s au pass\u00e9, avec z\u00e9ro ou   plusieurs handlers qui \u00e9chouent silencieusement. Ils sont \u00e9mis par le domaine.</p> </li> <li> <p>Le message bus impl\u00e9mente cette distinction dans deux m\u00e9thodes :   <code>_handle_command</code> (strict) et <code>_handle_event</code> (tol\u00e9rant).</p> </li> <li> <p>La r\u00e8gle pratique : si c'est une demande venue de l'ext\u00e9rieur, c'est une   command. Si c'est une r\u00e9action interne au domaine, c'est un event.</p> </li> </ul>"},{"location":"partie2/chapitre_10_commands/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Nouvelle command</p> <p>Cr\u00e9ez une command <code>AnnulerCommande(id_commande)</code> qui d\u00e9salloue toutes les lignes d'une commande donn\u00e9e. Quel(s) event(s) devrait-elle \u00e9mettre ? Impl\u00e9mentez le handler et les tests.</p> <p>Exercice 2 -- Valider les commands</p> <p>Les commands sont actuellement de simples dataclasses sans validation. Ajoutez une m\u00e9thode <code>valider()</code> \u00e0 <code>Allouer</code> qui v\u00e9rifie que <code>quantit\u00e9 &gt; 0</code> et que <code>sku</code> n'est pas vide. O\u00f9 cette validation devrait-elle \u00eatre appel\u00e9e : dans le handler ou dans le bus ?</p> <p>Exercice 3 -- Event ou Command ?</p> <p>Pour chaque situation, d\u00e9terminez s'il faut une command ou un event : (a) Un utilisateur annule sa commande. (b) Le stock d'un produit atteint z\u00e9ro. (c) Un service externe demande un rapport d'inventaire. (d) Une allocation vient de r\u00e9ussir.</p>"},{"location":"partie2/chapitre_10_commands/#structure-des-fichiers","title":"Structure des fichiers","text":"<pre><code>src/allocation/\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 commands.py       # Les intentions : Cr\u00e9erLot, Allouer, ...\n\u2502   \u251c\u2500\u2500 events.py         # Les faits : Allou\u00e9, D\u00e9sallou\u00e9, RuptureDeStock\n\u2502   \u2514\u2500\u2500 model.py          # Le mod\u00e8le de domaine qui \u00e9met les events\n\u251c\u2500\u2500 service_layer/\n\u2502   \u251c\u2500\u2500 bootstrap.py      # Enregistrement des handlers (command et event)\n\u2502   \u251c\u2500\u2500 handlers.py       # Les fonctions qui traitent commands et events\n\u2502   \u2514\u2500\u2500 messagebus.py     # Le dispatch diff\u00e9renci\u00e9 (_handle_command / _handle_event)\n\u2514\u2500\u2500 entrypoints/\n    \u2514\u2500\u2500 flask_app.py      # L'API qui cr\u00e9e des commands\n</code></pre>"},{"location":"partie2/chapitre_11_events_externes/","title":"Chapitre 11 -- Events externes et communication entre services","text":"<p>Avant / Apr\u00e8s</p> Avant Service isol\u00e9, communications HTTP directes Apr\u00e8s Events via Redis Pub/Sub, Consumer convertit en commands <p>Ce que vous allez apprendre</p> <ul> <li>La diff\u00e9rence entre events internes et events externes</li> <li>Comment publier des events vers un message broker (Redis Pub/Sub)</li> <li>Comment consommer des events externes et les convertir en commands internes</li> <li>Le pattern Outbox pour garantir la publication fiable des events</li> <li>L'importance de l'idempotence dans les consumers</li> </ul>"},{"location":"partie2/chapitre_11_events_externes/#events-internes-vs-events-externes","title":"Events internes vs events externes","text":"<p>Jusqu'ici, nos events circulent uniquement \u00e0 l'int\u00e9rieur de notre application. Quand un <code>Produit</code> \u00e9met un event <code>Allou\u00e9</code>, le message bus le dispatch vers <code>publier_\u00e9v\u00e9nement_allocation</code> ou <code>r\u00e9allouer</code> -- tout cela dans le m\u00eame processus. Mais d'autres services ont besoin de savoir qu'une allocation a eu lieu, et des syst\u00e8mes externes doivent pouvoir nous informer de changements. Comment faire communiquer ces services sans les coupler ?</p> Aspect Event interne Event externe P\u00e9rim\u00e8tre Au sein d'un seul processus Entre plusieurs services Transport Message bus en m\u00e9moire Message broker (Redis, RabbitMQ, Kafka...) Format Objets Python (dataclasses) Donn\u00e9es s\u00e9rialis\u00e9es (JSON, Protobuf...) Fiabilit\u00e9 Garantie par le processus N\u00e9cessite des m\u00e9canismes d\u00e9di\u00e9s Couplage M\u00eame bounded context Entre bounded contexts diff\u00e9rents <p>Un event interne comme <code>D\u00e9sallou\u00e9</code> d\u00e9clenche une r\u00e9allocation dans le m\u00eame service -- c'est un d\u00e9tail d'impl\u00e9mentation invisible de l'ext\u00e9rieur. Un event externe comme <code>Allou\u00e9</code> informe les autres services qu'une allocation a eu lieu -- c'est un contrat dont d'autres \u00e9quipes d\u00e9pendent.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Service d'allocation           \u2502\n\u2502                                      \u2502\n\u2502  Command \u2500\u2500\u25b6 Handler \u2500\u2500\u25b6 Model       \u2502\n\u2502                            \u2502         \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502                    \u2502 Message Bus  \u2502  \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                    Event Handler     \u2502\n\u2502                    (publish)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 Event externe (JSON)\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502  Message Broker   \u2502\n                   \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2518\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 Exp\u00e9dition \u2502   \u2502 Facturation   \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Les events externes offrent un d\u00e9couplage temporel et spatial : le producteur ne sait pas qui consomme, le consommateur n'a pas besoin d'\u00eatre disponible au moment de la publication, et ajouter un nouvel abonn\u00e9 ne modifie pas le producteur. L'alternative -- des appels HTTP directs -- cr\u00e9e un couplage fort.</p> <p>R\u00e8gle pratique</p> <p>Un event interne peut changer librement (code priv\u00e9). Un event externe est une API publique dont le sch\u00e9ma doit rester r\u00e9trocompatible.</p>"},{"location":"partie2/chapitre_11_events_externes/#redis-pubsub-comme-message-broker","title":"Redis Pub/Sub comme message broker","text":"<p>Redis offre un m\u00e9canisme Pub/Sub simple pour commencer. On cr\u00e9e une abstraction pour la publication, suivant le m\u00eame pattern que notre <code>AbstractNotifications</code> :</p> <pre><code># adapters/redis_eventpublisher.py\n\nimport abc\nimport json\nimport redis\n\n\nclass AbstractEventPublisher(abc.ABC):\n    \"\"\"Interface abstraite pour la publication d'events externes.\"\"\"\n\n    @abc.abstractmethod\n    def publish(self, channel: str, event_data: dict) -&gt; None:\n        raise NotImplementedError\n\n\nclass RedisEventPublisher(AbstractEventPublisher):\n    \"\"\"Publie des events sur des channels Redis Pub/Sub.\"\"\"\n\n    def __init__(self, host: str = \"localhost\", port: int = 6379):\n        self.client = redis.Redis(host=host, port=port)\n\n    def publish(self, channel: str, event_data: dict) -&gt; None:\n        self.client.publish(channel, json.dumps(event_data))\n</code></pre> <p>Notre handler <code>publier_\u00e9v\u00e9nement_allocation</code> utilise cet adapter via l'injection de d\u00e9pendances du message bus : <pre><code># service_layer/handlers.py\n\ndef publier_\u00e9v\u00e9nement_allocation(\n    event: events.Allou\u00e9,\n    publish: AbstractEventPublisher,\n) -&gt; None:\n    \"\"\"Publie un event d'allocation vers le message broker.\"\"\"\n    publish.publish(\n        channel=\"line_allocated\",\n        event_data={\n            \"id_commande\": event.id_commande,\n            \"sku\": event.sku,\n            \"quantit\u00e9\": event.quantit\u00e9,\n            \"r\u00e9f_lot\": event.r\u00e9f_lot,\n        },\n    )\n</code></pre></p> <p>On injecte le publisher dans le bootstrap, comme pour les notifications : <pre><code># service_layer/bootstrap.py\n\ndef bootstrap(\n    # ... param\u00e8tres existants ...\n    publish: AbstractEventPublisher | None = None,\n) -&gt; MessageBus:\n    if publish is None:\n        publish = RedisEventPublisher()\n\n    dependencies = {\n        \"notifications\": notifications_adapter,\n        \"publish\": publish,\n        **extra_dependencies,\n    }\n    return MessageBus(uow=uow, event_handlers=EVENT_HANDLERS,\n                      command_handlers=COMMAND_HANDLERS,\n                      dependencies=dependencies)\n</code></pre></p>"},{"location":"partie2/chapitre_11_events_externes/#consumer-externe","title":"Consumer externe","text":"<p>Notre service doit aussi recevoir des events d'autres services. Quand un syst\u00e8me d'entrep\u00f4t modifie la quantit\u00e9 d'un lot, il publie un event sur Redis. Le consumer est un processus s\u00e9par\u00e9 de l'API Flask qui \u00e9coute Redis et convertit les messages en commands internes :</p> <pre><code># entrypoints/redis_eventconsumer.py\n\nimport json\nimport redis\nfrom allocation.domain import commands\nfrom allocation.service_layer import bootstrap\n\n\ndef main():\n    \"\"\"Point d'entr\u00e9e du consumer Redis.\"\"\"\n    bus = bootstrap.bootstrap()\n    client = redis.Redis(\"localhost\", 6379)\n    pubsub = client.pubsub(ignore_subscribe_messages=True)\n    pubsub.subscribe(\"modifier_quantit\u00e9_lot\")\n\n    for message in pubsub.listen():\n        handle_message(message, bus)\n\n\ndef handle_message(message, bus):\n    \"\"\"Convertit un message Redis en command interne.\"\"\"\n    data = json.loads(message[\"data\"])\n    channel = message[\"channel\"].decode()\n\n    if channel == \"modifier_quantit\u00e9_lot\":\n        cmd = commands.ModifierQuantit\u00e9Lot(\n            r\u00e9f=data[\"r\u00e9f_lot\"],\n            quantit\u00e9=data[\"quantit\u00e9\"],\n        )\n        bus.handle(cmd)\n</code></pre> <p>Events externes deviennent des commands internes</p> <p>Le consumer convertit les events externes en commands, pas en events. Du point de vue de notre service, le message entrant est une intention (\"change cette quantit\u00e9\"), pas un fait pass\u00e9. C'est une command qui peut \u00e9chouer (lot introuvable, quantit\u00e9 invalide...).</p>"},{"location":"partie2/chapitre_11_events_externes/#le-flux-complet","title":"Le flux complet","text":"<pre><code>Syst\u00e8me externe                    Notre service\n      \u2502                                  \u2502\n      \u2502  PUBLISH modifier_quantit\u00e9_lot  \u2502\n      \u2502  {\"r\u00e9f_lot\":\"b1\", \"quantit\u00e9\":10}\u2502\n      \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Redis \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502\n      \u2502                                  \u2502\n      \u2502                     redis_eventconsumer.py\n      \u2502                          \u2502\n      \u2502                     ModifierQuantit\u00e9Lot(r\u00e9f=\"b1\", quantit\u00e9=10)\n      \u2502                          \u2502\n      \u2502                     bus.handle(cmd) \u2500\u2500\u25b6 handler \u2500\u2500\u25b6 domaine\n      \u2502                          \u2502\n      \u2502                     (si r\u00e9allocation n\u00e9cessaire)\n      \u2502                     D\u00e9sallou\u00e9 \u2500\u2500\u25b6 r\u00e9allouer\n      \u2502                     Allou\u00e9   \u2500\u2500\u25b6 publier vers Redis\n</code></pre>"},{"location":"partie2/chapitre_11_events_externes/#le-pattern-outbox","title":"Le pattern Outbox","text":"<p>Que se passe-t-il si l'application crashe apr\u00e8s avoir commit\u00e9 en base, mais avant d'avoir publi\u00e9 l'event sur Redis ? L'event est perdu. C'est le probl\u00e8me du dual write. Le pattern Outbox le r\u00e9sout :</p> <ol> <li>Dans la m\u00eame transaction, on \u00e9crit l'event dans une table <code>outbox</code>.</li> <li>La transaction est commit\u00e9e -- donn\u00e9es et event persist\u00e9s atomiquement.</li> <li>Un processus s\u00e9par\u00e9 (relay) lit l'outbox, publie vers le broker, puis    marque les entr\u00e9es comme publi\u00e9es.</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Transaction BDD             \u2502\n\u2502                                     \u2502\n\u2502  UPDATE produits SET ...            \u2502\n\u2502  INSERT INTO outbox (type, data)    \u2502\n\u2502  COMMIT  \u25c0\u2500\u2500 atomique              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502 (processus s\u00e9par\u00e9)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Outbox Relay              \u2502\n\u2502                                     \u2502\n\u2502  SELECT FROM outbox WHERE NOT pub.  \u2502\n\u2502  redis.publish(channel, data)       \u2502\n\u2502  UPDATE outbox SET published = TRUE \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code># adapters/orm.py (ajout de la table outbox)\n\noutbox = Table(\n    \"outbox\", metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"event_type\", String(100)),\n    Column(\"data\", Text),\n    Column(\"created_at\", DateTime, server_default=func.now()),\n    Column(\"published\", Boolean, default=False),\n)\n</code></pre> <p>Le handler \u00e9crit dans l'outbox au lieu de publier directement : <pre><code>def publier_\u00e9v\u00e9nement_allocation(event: events.Allou\u00e9,\n                            uow: AbstractUnitOfWork) -&gt; None:\n    \"\"\"\u00c9crit l'event dans la table outbox (m\u00eame transaction).\"\"\"\n    with uow:\n        uow.session.execute(outbox.insert().values(\n            event_type=\"Allou\u00e9\",\n            data=json.dumps({\n                \"id_commande\": event.id_commande, \"sku\": event.sku,\n                \"quantit\u00e9\": event.quantit\u00e9, \"r\u00e9f_lot\": event.r\u00e9f_lot,\n            }),\n        ))\n        uow.commit()\n</code></pre></p> <p>Le relay publie les events en attente : <pre><code># entrypoints/outbox_relay.py\n\ndef main():\n    engine = create_engine(\"sqlite:///allocation.db\")\n    r = redis.Redis(\"localhost\", 6379)\n    while True:\n        with engine.begin() as conn:\n            rows = conn.execute(text(\n                \"SELECT id, event_type, data FROM outbox \"\n                \"WHERE published = FALSE ORDER BY id\"\n            )).fetchall()\n            for row in rows:\n                r.publish(row.event_type, row.data)\n                conn.execute(text(\n                    \"UPDATE outbox SET published = TRUE WHERE id = :id\"\n                ), {\"id\": row.id})\n        time.sleep(1)\n</code></pre></p> <p>Compromis</p> <p>Le pattern Outbox garantit une publication at-least-once (au moins une fois). Le relay peut publier un event, crasher avant de le marquer comme publi\u00e9, puis le republier. C'est pourquoi les consumers doivent \u00eatre idempotents.</p>"},{"location":"partie2/chapitre_11_events_externes/#idempotence-des-consumers","title":"Idempotence des consumers","text":"<p>Dans un syst\u00e8me distribu\u00e9, les messages peuvent \u00eatre d\u00e9livr\u00e9s plus d'une fois. Nos consumers doivent \u00eatre idempotents : traiter le m\u00eame message deux fois doit produire le m\u00eame r\u00e9sultat.</p>"},{"location":"partie2/chapitre_11_events_externes/#strategie-1-operations-naturellement-idempotentes","title":"Strat\u00e9gie 1 : op\u00e9rations naturellement idempotentes","text":"<p>\"Fixer la quantit\u00e9 du lot B1 \u00e0 50\" est idempotent -- l'ex\u00e9cuter deux fois donne le m\u00eame r\u00e9sultat. \"Ajouter 10 au lot B1\" ne l'est pas.</p> <p>C'est pourquoi notre command <code>ModifierQuantit\u00e9Lot</code> prend une quantit\u00e9 absolue (<code>quantit\u00e9=50</code>) plut\u00f4t qu'un delta (<code>delta=+10</code>). Ce choix de design rend le consumer naturellement idempotent.</p>"},{"location":"partie2/chapitre_11_events_externes/#strategie-2-table-de-deduplication","title":"Strat\u00e9gie 2 : table de d\u00e9duplication","text":"<p>Pour les op\u00e9rations non idempotentes, on enregistre les identifiants des messages d\u00e9j\u00e0 trait\u00e9s : <pre><code>processed_messages = Table(\n    \"processed_messages\", metadata,\n    Column(\"message_id\", String(100), primary_key=True),\n    Column(\"processed_at\", DateTime, server_default=func.now()),\n)\n\ndef handle_modifier_quantit\u00e9_lot(message, bus):\n    \"\"\"Consumer idempotent avec d\u00e9duplication.\"\"\"\n    data = json.loads(message[\"data\"])\n    message_id = data.get(\"message_id\")\n\n    if message_id and already_processed(message_id):\n        return  # d\u00e9j\u00e0 trait\u00e9, on ignore\n\n    cmd = commands.ModifierQuantit\u00e9Lot(r\u00e9f=data[\"r\u00e9f_lot\"], quantit\u00e9=data[\"quantit\u00e9\"])\n    bus.handle(cmd)\n\n    if message_id:\n        mark_as_processed(message_id)\n</code></pre></p> <p>Identifiants de messages</p> <p>Pour que la d\u00e9duplication fonctionne, chaque message doit porter un identifiant unique (<code>message_id</code>). Le producteur g\u00e9n\u00e8re cet identifiant (typiquement un UUID) et l'inclut dans le payload.</p>"},{"location":"partie2/chapitre_11_events_externes/#resume-vue-densemble","title":"R\u00e9sum\u00e9 : vue d'ensemble","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Service d'allocation                  \u2502\n\u2502                                                \u2502\n\u2502  Flask API \u2500\u2510   Consumer \u2500\u2510   Outbox Relay     \u2502\n\u2502             \u25bc              \u25bc        \u2502          \u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502          \u2502\n\u2502         \u2502     Message Bus      \u2502    \u2502          \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502          \u2502\n\u2502                    \u25bc                \u2502          \u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502          \u2502\n\u2502         \u2502  BDD (+ outbox)     \u251c\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502 Events (JSON)\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502   Message Broker   \u2502\n           \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 Exp\u00e9dition\u2502    \u2502Syst\u00e8me externe\u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Trois points d'entr\u00e9e convergent vers le message bus : l'API Flask (requ\u00eates HTTP), le consumer Redis (events externes), et l'outbox relay (publication). Le domaine ne sait pas d'o\u00f9 viennent les commands ni o\u00f9 partent les events.</p> Concept R\u00f4le Event interne Circule dans le message bus en m\u00e9moire Event externe Traverse les fronti\u00e8res du service via un message broker Publisher Adapter qui s\u00e9rialise et publie les events vers le broker Consumer Processus qui \u00e9coute le broker et cr\u00e9e des commands internes Pattern Outbox Garantit la publication fiable (\u00e9criture BDD + relay) Idempotence Les consumers tol\u00e8rent les messages dupliqu\u00e9s"},{"location":"partie2/chapitre_11_events_externes/#principes-cles","title":"Principes cl\u00e9s","text":"<ul> <li>Les events externes sont des contrats entre services -- leur sch\u00e9ma   doit \u00eatre stable et versionn\u00e9.</li> <li>Le consumer convertit les events externes en commands internes,   car c'est une intention du point de vue du service r\u00e9cepteur.</li> <li>Le pattern Outbox r\u00e9sout le probl\u00e8me du dual write en garantissant   l'atomicit\u00e9 entre la BDD et la publication.</li> <li>Concevez vos commands pour \u00eatre naturellement idempotentes quand   c'est possible (quantit\u00e9s absolues plut\u00f4t que deltas).</li> <li>Gr\u00e2ce aux abstractions, les tests restent rapides et ne n\u00e9cessitent   pas d'infrastructure externe.</li> </ul>"},{"location":"partie2/chapitre_11_events_externes/#exercices","title":"Exercices","text":"<p>Exercice 1 -- FakeEventPublisher</p> <p>Impl\u00e9mentez un <code>FakeEventPublisher</code> qui stocke les events publi\u00e9s dans une liste. \u00c9crivez un test qui v\u00e9rifie que quand une allocation r\u00e9ussit, un event est publi\u00e9 sur le bon channel avec les bonnes donn\u00e9es.</p> <p>Exercice 2 -- Consumer robuste</p> <p>Le consumer actuel ne g\u00e8re pas les erreurs de parsing JSON. Ajoutez un <code>try/except</code> et un logging. Que devrait-il faire si le message est invalide : l'ignorer, le republier, ou le mettre dans une dead letter queue ?</p> <p>Exercice 3 -- Sch\u00e9ma d'events</p> <p>Les events externes sont des contrats entre services. Proposez un m\u00e9canisme pour versionner les events (ex: <code>Allou\u00e9_v1</code>, <code>Allou\u00e9_v2</code>). Comment g\u00e9rer la r\u00e9trocompatibilit\u00e9 ?</p> <p>\u00c0 retenir</p> <p>Les events externes transforment notre service en bon citoyen d'une architecture distribu\u00e9e : il informe les autres de ce qui s'est pass\u00e9 chez lui, et r\u00e9agit \u00e0 ce qui se passe ailleurs, le tout sans couplage direct.</p>"},{"location":"partie2/chapitre_12_cqrs/","title":"Chapitre 12 -- CQRS (Command Query Responsibility Segregation)","text":"<p>Avant / Apr\u00e8s</p> Avant M\u00eame mod\u00e8le pour lecture et \u00e9criture Apr\u00e8s Write model normalis\u00e9 + Read model d\u00e9normalis\u00e9"},{"location":"partie2/chapitre_12_cqrs/#le-probleme-de-la-lecture","title":"Le probl\u00e8me de la lecture","text":"<p>Dans les chapitres pr\u00e9c\u00e9dents, nous avons construit un mod\u00e8le de domaine riche : des agr\u00e9gats (<code>Produit</code>), des entit\u00e9s (<code>Lot</code>), des value objects (<code>LigneDeCommande</code>), des invariants m\u00e9tier, un repository pour la persistance et un message bus pour l'orchestration. Tout cela forme un chemin d'\u00e9criture solide et bien prot\u00e9g\u00e9.</p> <p>Mais posons-nous une question simple : que se passe-t-il quand un utilisateur veut simplement afficher les allocations d'une commande ?</p> <p>Avec notre architecture actuelle, le chemin ressemblerait \u00e0 ceci :</p> <pre><code>   Requ\u00eate GET /allocations/order-123\n        \u2502\n        v\n   Repository.get(sku=...)          # Charge un Produit entier\n        \u2502\n        v\n   Produit                           # Avec tous ses Lot\n     \u251c\u2500\u2500 Lot(\"batch-001\")            # Chaque Lot avec ses allocations\n     \u2502     \u2514\u2500\u2500 {LigneDeCommande, LigneDeCommande, ...}\n     \u251c\u2500\u2500 Lot(\"batch-002\")\n     \u2502     \u2514\u2500\u2500 {LigneDeCommande, LigneDeCommande, ...}\n     \u2514\u2500\u2500 Lot(\"batch-003\")\n           \u2514\u2500\u2500 {LigneDeCommande, ...}\n        \u2502\n        v\n   Parcours de toutes les allocations pour trouver celles de \"order-123\"\n        \u2502\n        v\n   S\u00e9rialisation en JSON\n</code></pre> <p>Pour r\u00e9pondre \u00e0 une question triviale -- \"quels SKUs sont allou\u00e9s \u00e0 cette commande ?\" -- on charge un agr\u00e9gat complet avec tous ses lots, toutes ses allocations, on reconstruit le graphe d'objets, on traverse les relations... C'est comme sortir toute la biblioth\u00e8que pour trouver un seul livre.</p> <p>Le mod\u00e8le de domaine est optimis\u00e9 pour prot\u00e9ger les invariants en \u00e9criture :</p> <ul> <li>L'agr\u00e9gat <code>Produit</code> garantit qu'on n'alloue pas plus que le stock disponible.</li> <li>Le num\u00e9ro de version prot\u00e8ge contre les acc\u00e8s concurrents.</li> <li>Les \u00e9v\u00e9nements tracent chaque changement d'\u00e9tat.</li> </ul> <p>Mais pour la lecture, on n'a besoin d'aucune de ces garanties. Pas d'invariants \u00e0 v\u00e9rifier, pas de concurrence \u00e0 g\u00e9rer, pas d'events \u00e0 \u00e9mettre. On veut juste des donn\u00e9es, le plus vite possible.</p> <p>Le constat fondamental</p> <p>Les besoins de lecture et d'\u00e9criture sont fondamentalement diff\u00e9rents. Utiliser le m\u00eame mod\u00e8le pour les deux, c'est faire un compromis qui p\u00e9nalise les deux c\u00f4t\u00e9s.</p>"},{"location":"partie2/chapitre_12_cqrs/#le-principe-cqrs","title":"Le principe CQRS","text":"<p>CQRS -- Command Query Responsibility Segregation -- propose une solution radicale : s\u00e9parer compl\u00e8tement les chemins d'\u00e9criture et de lecture.</p> <p>L'id\u00e9e vient du principe CQS (Command Query Separation) de Bertrand Meyer, appliqu\u00e9 \u00e0 l'\u00e9chelle de l'architecture :</p> <ul> <li>Les commands (\u00e9criture) passent par le domaine, le message bus, le   repository. Elles modifient l'\u00e9tat du syst\u00e8me.</li> <li>Les queries (lecture) interrogent directement la base de donn\u00e9es.   Elles ne modifient rien.</li> </ul> <pre><code>   CQRS : deux chemins distincts pour deux besoins distincts.\n\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                          API Flask                               \u2502\n   \u2502                                                                  \u2502\n   \u2502   POST /allocate              GET /allocations/&lt;id_commande&gt;     \u2502\n   \u2502        \u2502                              \u2502                          \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502                              \u2502\n            v                              v\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   WRITE PATH    \u2502           \u2502   READ PATH     \u2502\n   \u2502                 \u2502           \u2502                 \u2502\n   \u2502   Command       \u2502           \u2502   View          \u2502\n   \u2502     \u2502           \u2502           \u2502     \u2502           \u2502\n   \u2502     v           \u2502           \u2502     v           \u2502\n   \u2502   Message Bus   \u2502           \u2502   SQL direct    \u2502\n   \u2502     \u2502           \u2502           \u2502     \u2502           \u2502\n   \u2502     v           \u2502           \u2502     v           \u2502\n   \u2502   Handler       \u2502           \u2502   allocations_  \u2502\n   \u2502     \u2502           \u2502           \u2502   view (table)  \u2502\n   \u2502     v           \u2502           \u2502                 \u2502\n   \u2502   Domain Model  \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502     \u2502           \u2502\n   \u2502     v           \u2502\n   \u2502   Repository    \u2502\n   \u2502     \u2502           \u2502\n   \u2502     v           \u2502\n   \u2502   ORM / BDD     \u2502\n   \u2502                 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>\u00c0 gauche, le chemin d'\u00e9criture traverse toute la pile : validation, logique m\u00e9tier, persistance via le repository, \u00e9mission d'events. \u00c0 droite, le chemin de lecture va droit au but : une fonction, une requ\u00eate SQL, un r\u00e9sultat.</p> <p>La cl\u00e9 de CQRS, c'est qu'on utilise deux mod\u00e8les diff\u00e9rents pour deux besoins diff\u00e9rents :</p> Aspect Write model Read model Objectif Prot\u00e9ger les invariants m\u00e9tier Servir des donn\u00e9es rapidement Structure Agr\u00e9gats, entit\u00e9s, value objects Tables d\u00e9normalis\u00e9es, vues Acc\u00e8s Via repository + domain model Via SQL direct Complexit\u00e9 Riche (logique m\u00e9tier) Simple (projection de donn\u00e9es) Optimis\u00e9 pour Coh\u00e9rence et r\u00e8gles m\u00e9tier Performance de lecture"},{"location":"partie2/chapitre_12_cqrs/#le-read-model-allocations_view","title":"Le read model : <code>allocations_view</code>","text":"<p>Le read model est une table d\u00e9normalis\u00e9e con\u00e7ue sp\u00e9cifiquement pour r\u00e9pondre \u00e0 une question de lecture. Contrairement aux tables du write model (qui sont normalis\u00e9es avec des cl\u00e9s \u00e9trang\u00e8res et des jointures), le read model contient exactement les colonnes dont la vue a besoin, dans un format directement exploitable.</p> <p>Dans notre ORM, la table <code>allocations_view</code> est d\u00e9finie ainsi :</p> <pre><code># src/allocation/adapters/orm.py\n\nallocations_view = Table(\n    \"allocations_view\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True, autoincrement=True),\n    Column(\"id_commande\", String(255)),\n    Column(\"sku\", String(255)),\n    Column(\"r\u00e9f_lot\", String(255)),\n)\n</code></pre> <p>Comparons avec les tables du write model, qui n\u00e9cessiteraient des jointures pour obtenir la m\u00eame information :</p> <pre><code>   WRITE MODEL (normalis\u00e9)               READ MODEL (d\u00e9normalis\u00e9)\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500             \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n   order_lines                            allocations_view\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502id_commande     \u2502 sku  \u2502 quantit\u00e9 \u2502   \u2502 id_commande  \u2502 sku  \u2502 r\u00e9f_lot  \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502order-1         \u2502LAMP  \u2502  10      \u2502   \u2502 order-1      \u2502LAMP  \u2502 batch-01 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502 order-1      \u2502TABLE \u2502 batch-03 \u2502\n        \u2502                                 \u2502 order-2      \u2502LAMP  \u2502 batch-02 \u2502\n        \u2502  allocations                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2514\u2500\u2500\u2502orderline_id\u2502 batch_id \u2502      Pas de jointure. Pas de\n           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      reconstruction d'objet.\n           \u2502     1      \u2502    3     \u2502      Tout est d\u00e9j\u00e0 pr\u00eat \u00e0 lire.\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n        lots                 \u2502\n        \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n        \u2502 id \u2502r\u00e9f\u00e9rence \u2502 ...\n        \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502  3 \u2502batch-01  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n   Pour obtenir \"quels SKUs sont allou\u00e9s \u00e0 order-1\", le write model\n   exige 3 tables et 2 jointures. Le read model : 1 table, 0 jointure.\n</code></pre> <p>Le read model duplique de l'information -- oui, c'est volontaire. En d\u00e9normalisant, on \u00e9change de l'espace disque (bon march\u00e9) contre de la vitesse de lecture (pr\u00e9cieuse). C'est un compromis classique et parfaitement justifi\u00e9 pour les chemins de lecture.</p>"},{"location":"partie2/chapitre_12_cqrs/#les-views-des-fonctions-de-lecture-pure","title":"Les views : des fonctions de lecture pure","text":"<p>Le c\u00f4t\u00e9 query de CQRS est impl\u00e9ment\u00e9 par des views : des fonctions simples qui ex\u00e9cutent des requ\u00eates SQL directes sur le read model. Pas de domaine, pas de repository, pas d'agr\u00e9gat. Juste une requ\u00eate et un r\u00e9sultat.</p> <pre><code># src/allocation/views/views.py\n\n\"\"\"\nViews (lecture) pour le pattern CQRS.\n\nLes views sont des fonctions de lecture pure qui interrogent\ndirectement la base de donn\u00e9es, sans passer par le mod\u00e8le de domaine.\n\nC'est le c\u00f4t\u00e9 Query de CQRS : on s\u00e9pare les chemins d'\u00e9criture\n(qui passent par le domaine et le message bus) des chemins de\nlecture (qui interrogent directement la BDD pour la performance).\n\"\"\"\n\nfrom allocation.service_layer import unit_of_work\n\n\ndef allocations(id_commande: str, uow: unit_of_work.AbstractUnitOfWork) -&gt; list[dict]:\n    \"\"\"\n    Retourne les allocations pour un id_commande donn\u00e9.\n\n    Requ\u00eate SQL directe sur la table de lecture (read model).\n    \"\"\"\n    with uow:\n        results = uow.session.execute(\n            text(\"SELECT sku, r\u00e9f_lot FROM allocations_view WHERE id_commande = :id_commande\"),\n            dict(id_commande=id_commande),\n        )\n        return [dict(r._mapping) for r in results]\n</code></pre> <p>Remarquez \u00e0 quel point c'est simple. La fonction <code>allocations</code> :</p> <ol> <li>Ouvre une session via le unit of work.</li> <li>Ex\u00e9cute une requ\u00eate SQL brute sur <code>allocations_view</code>.</li> <li>Retourne une liste de dictionnaires.</li> </ol> <p>Pas de <code>Produit</code>, pas de <code>Lot</code>, pas de <code>LigneDeCommande</code>. Pas de reconstruction d'agr\u00e9gat, pas de travers\u00e9e de relations. La requ\u00eate va directement chercher les donn\u00e9es l\u00e0 o\u00f9 elles sont, dans le format exact dont l'API a besoin.</p> <p>Le endpoint Flask qui utilise cette view est tout aussi direct :</p> <pre><code># src/allocation/entrypoints/flask_app.py\n\n@app.route(\"/allocations/&lt;id_commande&gt;\", methods=[\"GET\"])\ndef allocations_view_endpoint(id_commande: str):\n    \"\"\"\n    GET /allocations/&lt;id_commande&gt;\n\n    Retourne les allocations pour une commande donn\u00e9e (lecture CQRS).\n    \"\"\"\n    from allocation.views import views\n\n    result = views.allocations(id_commande, bus.uow)\n    if not result:\n        return \"not found\", 404\n    return jsonify(result), 200\n</code></pre> <p>Le contraste avec les endpoints d'\u00e9criture est frappant :</p> Endpoint d'\u00e9criture (<code>POST /allocate</code>) Endpoint de lecture (<code>GET /allocations</code>) Construit une <code>Command</code> Appelle une view directement Envoie au message bus Pas de message bus Le handler charge un agr\u00e9gat via le repository La view fait un <code>SELECT</code> SQL Le domaine v\u00e9rifie les invariants Aucune v\u00e9rification m\u00e9tier Des events sont \u00e9mis Aucun event Le r\u00e9sultat est un effet de bord (allocation) Le r\u00e9sultat est une projection de donn\u00e9es"},{"location":"partie2/chapitre_12_cqrs/#mise-a-jour-du-read-model-par-les-event-handlers","title":"Mise \u00e0 jour du read model par les event handlers","text":"<p>Si le read model est une table s\u00e9par\u00e9e, comment reste-t-il synchronis\u00e9 avec le write model ? Par les event handlers. Quand une allocation est effectu\u00e9e, le domaine \u00e9met un event <code>Allou\u00e9</code>. Un handler \u00e9coute cet event et met \u00e0 jour la table <code>allocations_view</code>.</p> <p>Voici comment l'event <code>Allou\u00e9</code> est d\u00e9fini :</p> <pre><code># src/allocation/domain/events.py\n\n@dataclass(frozen=True)\nclass Allou\u00e9(Event):\n    \"\"\"Une LigneDeCommande a \u00e9t\u00e9 allou\u00e9e \u00e0 un Lot.\"\"\"\n\n    id_commande: str\n    sku: str\n    quantit\u00e9: int\n    r\u00e9f_lot: str\n</code></pre> <p>L'event contient toutes les informations n\u00e9cessaires pour mettre \u00e0 jour le read model : le <code>id_commande</code>, le <code>sku</code> et le <code>r\u00e9f_lot</code>. C'est exactement ce que la table <code>allocations_view</code> attend.</p> <p>Le handler de mise \u00e0 jour du read model ressemblerait \u00e0 ceci :</p> <pre><code># src/allocation/service_layer/handlers.py\n\nfrom sqlalchemy import text\n\ndef ajouter_allocation_vue(\n    event: events.Allou\u00e9,\n    uow: AbstractUnitOfWork,\n) -&gt; None:\n    \"\"\"Met \u00e0 jour le read model quand une allocation est effectu\u00e9e.\"\"\"\n    with uow:\n        uow.session.execute(\n            text(\n                \"INSERT INTO allocations_view (id_commande, sku, r\u00e9f_lot)\"\n                \" VALUES (:id_commande, :sku, :r\u00e9f_lot)\"\n            ),\n            dict(id_commande=event.id_commande, sku=event.sku, r\u00e9f_lot=event.r\u00e9f_lot),\n        )\n        uow.commit()\n</code></pre> <p>Et il serait enregistr\u00e9 dans le bootstrap :</p> <pre><code># src/allocation/service_layer/bootstrap.py\n\nEVENT_HANDLERS: dict[type[events.Event], list] = {\n    events.Allou\u00e9: [\n        handlers.publier_\u00e9v\u00e9nement_allocation,\n        handlers.ajouter_allocation_vue,  # &lt;-- mise \u00e0 jour du read model\n    ],\n    events.D\u00e9sallou\u00e9: [handlers.r\u00e9allouer],\n    events.RuptureDeStock: [handlers.envoyer_notification_rupture_stock],\n}\n</code></pre> <p>Le flux complet forme une boucle :</p> <pre><code>   1. Command Allouer arrive\n              \u2502\n              v\n   2. Handler allouer() charge le Produit via le repository\n              \u2502\n              v\n   3. Produit.allouer() alloue et \u00e9met un event Allou\u00e9\n              \u2502\n              v\n   4. Message bus collecte l'event Allou\u00e9\n              \u2502\n              v\n   5. Handler ajouter_allocation_vue() met \u00e0 jour allocations_view\n              \u2502\n              v\n   6. GET /allocations/&lt;id_commande&gt; lit la table allocations_view\n</code></pre>"},{"location":"partie2/chapitre_12_cqrs/#eventual-consistency","title":"Eventual consistency","text":"<p>Le read model n'est pas mis \u00e0 jour dans la m\u00eame transaction que le write model. Il est mis \u00e0 jour par un event handler, dans une transaction s\u00e9par\u00e9e. Cela signifie qu'il existe un court instant o\u00f9 le read model n'est pas encore \u00e0 jour : c'est l'eventual consistency.</p> <p>Eventual consistency</p> <p>Apr\u00e8s une \u00e9criture, le read model peut avoir un l\u00e9ger retard sur le write model. Si un utilisateur alloue une commande puis consulte imm\u00e9diatement ses allocations, il est possible que le r\u00e9sultat n'apparaisse pas encore.</p> <p>En pratique, ce d\u00e9lai est de l'ordre de quelques millisecondes dans un syst\u00e8me monolithique. Mais c'est un aspect \u00e0 garder en t\u00eate, surtout si vous \u00e9voluez vers un syst\u00e8me distribu\u00e9 (avec Redis ou Kafka entre les deux).</p> <p>L'eventual consistency est le prix \u00e0 payer pour la s\u00e9paration propre des responsabilit\u00e9s. Dans la grande majorit\u00e9 des cas, ce compromis est largement acceptable. Les utilisateurs ne remarquent pas un d\u00e9lai de quelques millisecondes, et le syst\u00e8me gagne en clart\u00e9, en performance de lecture et en capacit\u00e9 d'\u00e9volution.</p>"},{"location":"partie2/chapitre_12_cqrs/#aller-plus-loin-desalloue-et-le-read-model","title":"Aller plus loin : D\u00e9sallou\u00e9 et le read model","text":"<p>Le m\u00eame principe s'applique sym\u00e9triquement aux d\u00e9sallocations. Quand un lot change de quantit\u00e9 et que des lignes sont d\u00e9sallou\u00e9es, le domaine \u00e9met des events <code>D\u00e9sallou\u00e9</code>. Un handler peut alors nettoyer le read model :</p> <pre><code>def supprimer_allocation_vue(\n    event: events.D\u00e9sallou\u00e9,\n    uow: AbstractUnitOfWork,\n) -&gt; None:\n    \"\"\"Supprime une allocation du read model quand une d\u00e9sallocation se produit.\"\"\"\n    with uow:\n        uow.session.execute(\n            text(\n                \"DELETE FROM allocations_view\"\n                \" WHERE id_commande = :id_commande AND sku = :sku\"\n            ),\n            dict(id_commande=event.id_commande, sku=event.sku),\n        )\n        uow.commit()\n</code></pre> <p>Le read model reste ainsi coh\u00e9rent avec le write model, en r\u00e9agissant aux m\u00eames events que le reste du syst\u00e8me. C'est l'un des grands avantages de l'architecture event-driven : ajouter un nouveau \"consommateur\" d'events (ici, la mise \u00e0 jour du read model) ne modifie en rien les producteurs d'events (le domaine).</p>"},{"location":"partie2/chapitre_12_cqrs/#quand-utiliser-cqrs","title":"Quand utiliser CQRS","text":"<p>CQRS n'est pas un pattern qu'il faut appliquer partout. C'est un outil puissant, mais qui ajoute de la complexit\u00e9 : une table suppl\u00e9mentaire \u00e0 maintenir, des event handlers \u00e0 \u00e9crire, de l'eventual consistency \u00e0 g\u00e9rer.</p>"},{"location":"partie2/chapitre_12_cqrs/#cqrs-est-utile-quand","title":"CQRS est utile quand :","text":"<ul> <li> <p>Les patterns de lecture et d'\u00e9criture divergent fortement. Si le read   model ressemblerait de toute fa\u00e7on au write model, la s\u00e9paration n'apporte   pas grand-chose. Mais quand les lectures n\u00e9cessitent des jointures complexes,   des agr\u00e9gations, ou des projections sp\u00e9cifiques, un read model d\u00e9normalis\u00e9   simplifie \u00e9norm\u00e9ment les choses.</p> </li> <li> <p>Les performances de lecture sont critiques. Un dashboard qui affiche des   statistiques en temps r\u00e9el ne peut pas se permettre de reconstruire des   agr\u00e9gats \u00e0 chaque requ\u00eate. Un read model pr\u00e9-calcul\u00e9 r\u00e9sout ce probl\u00e8me.</p> </li> <li> <p>Le syst\u00e8me est d\u00e9j\u00e0 event-driven. Si vous avez d\u00e9j\u00e0 un message bus et   des events, ajouter un handler qui met \u00e0 jour un read model est trivial.   L'infrastructure est d\u00e9j\u00e0 en place.</p> </li> <li> <p>Le ratio lecture/\u00e9criture est fortement d\u00e9s\u00e9quilibr\u00e9. La plupart des   syst\u00e8mes font beaucoup plus de lectures que d'\u00e9critures. Optimiser le chemin   de lecture a un impact disproportionn\u00e9 sur les performances globales.</p> </li> </ul>"},{"location":"partie2/chapitre_12_cqrs/#cqrs-est-superflu-quand","title":"CQRS est superflu quand :","text":"<ul> <li> <p>L'application est un simple CRUD. Si les lectures et \u00e9critures portent   sur les m\u00eames structures, un ORM classique suffit amplement.</p> </li> <li> <p>Le domaine est simple. Si vous n'avez ni agr\u00e9gats ni invariants   complexes, vous n'avez probablement pas besoin de s\u00e9parer les chemins.</p> </li> <li> <p>L'\u00e9quipe est petite et le syst\u00e8me jeune. La complexit\u00e9 ajout\u00e9e peut   ralentir le d\u00e9veloppement au d\u00e9but. Mieux vaut commencer simple et \u00e9voluer   vers CQRS quand le besoin se fait sentir.</p> </li> </ul> <p>Approche progressive</p> <p>On peut adopter CQRS de mani\u00e8re incr\u00e9mentale. Commencez par utiliser le m\u00eame ORM pour les lectures et les \u00e9critures, mais dans des modules s\u00e9par\u00e9s. Puis, quand les performances l'exigent, introduisez un read model d\u00e9normalis\u00e9 pour les requ\u00eates les plus co\u00fbteuses. Pas besoin de tout s\u00e9parer d'un coup.</p>"},{"location":"partie2/chapitre_12_cqrs/#resume","title":"R\u00e9sum\u00e9","text":"<p>CQRS s\u00e9pare les responsabilit\u00e9s de lecture et d'\u00e9criture en deux chemins distincts, chacun optimis\u00e9 pour son cas d'usage.</p> <pre><code>   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                                                             \u2502\n   \u2502                      WRITE PATH                             \u2502\n   \u2502                                                             \u2502\n   \u2502   Command \u2500\u2500&gt; Message Bus \u2500\u2500&gt; Handler \u2500\u2500&gt; Domain Model      \u2502\n   \u2502                                              \u2502              \u2502\n   \u2502                                              v              \u2502\n   \u2502                                         Repository          \u2502\n   \u2502                                              \u2502              \u2502\n   \u2502                                              v              \u2502\n   \u2502              Event \u00e9mis \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Tables normalis\u00e9es    \u2502\n   \u2502                \u2502                      (write model)         \u2502\n   \u2502                v                                            \u2502\n   \u2502         Event Handler                                       \u2502\n   \u2502                \u2502                                            \u2502\n   \u2502                v                                            \u2502\n   \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                               \u2502\n   \u2502   \u2502  Table d\u00e9normalis\u00e9e     \u2502                               \u2502\n   \u2502   \u2502  (read model)           \u2502                               \u2502\n   \u2502   \u2502  ex: allocations_view   \u2502                               \u2502\n   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2502\n   \u2502                \u2502                                            \u2502\n   \u2502                v                                            \u2502\n   \u2502                                                             \u2502\n   \u2502                      READ PATH                              \u2502\n   \u2502                                                             \u2502\n   \u2502   Query \u2500\u2500&gt; View function \u2500\u2500&gt; SELECT SQL \u2500\u2500&gt; JSON           \u2502\n   \u2502                                                             \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Concept R\u00f4le Dans notre code Command Intention d'\u00e9criture <code>commands.Allouer</code> Write model Tables normalis\u00e9es, prot\u00e9g\u00e9es par le domaine <code>order_lines</code>, <code>lots</code>, <code>allocations</code> Event Fait qui s'est produit <code>events.Allou\u00e9</code> Read model Table d\u00e9normalis\u00e9e, optimis\u00e9e pour la lecture <code>allocations_view</code> View Fonction de lecture pure, SQL direct <code>views.allocations()</code> Event handler Met \u00e0 jour le read model en r\u00e9action aux events <code>ajouter_allocation_vue()</code> Eventual consistency Le read model peut avoir un l\u00e9ger retard D\u00e9lai entre commit write et update read"},{"location":"partie2/chapitre_12_cqrs/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Nouvelle vue</p> <p>Cr\u00e9ez un read model <code>stock_view</code> qui montre la quantit\u00e9 disponible par SKU. D\u00e9finissez la table, l'event handler qui la met \u00e0 jour (sur <code>Allou\u00e9</code> et <code>D\u00e9sallou\u00e9</code>), et la fonction de lecture.</p> <p>Exercice 2 -- Rebuild du read model</p> <p>Si la table <code>allocations_view</code> est corrompue, comment la reconstruire \u00e0 partir des tables du write model ? \u00c9crivez un script SQL qui le fait.</p> <p>Exercice 3 -- Tester l'eventual consistency</p> <p>\u00c9crivez un test qui v\u00e9rifie que apr\u00e8s un <code>bus.handle(commands.Allouer(...))</code>, la vue <code>allocations</code> retourne bien l'allocation. Ce test prouve-t-il la consistency ou l'eventual consistency ?</p> <p>\u00c0 retenir</p> <ul> <li>Le mod\u00e8le de domaine est optimis\u00e9 pour l'\u00e9criture. Ne le forcez pas \u00e0 servir les lectures.</li> <li>CQRS s\u00e9pare les chemins : commands vers le domaine, queries vers le read model.</li> <li>Le read model est une table d\u00e9normalis\u00e9e, mise \u00e0 jour par des event handlers.</li> <li>Les views sont des fonctions simples : un SELECT SQL, un r\u00e9sultat. Pas de domaine.</li> <li>L'eventual consistency est le prix \u00e0 payer. Il est presque toujours acceptable.</li> <li>Adoptez CQRS quand les besoins de lecture et d'\u00e9criture divergent. Pas avant.</li> </ul>"},{"location":"partie2/chapitre_13_injection_dependances/","title":"Chapitre 13 -- Injection de d\u00e9pendances et bootstrap","text":"<p>Avant / Apr\u00e8s</p> Avant Handlers cr\u00e9ent leurs d\u00e9pendances Apr\u00e8s <code>bootstrap()</code> Composition Root, injection par introspection"},{"location":"partie2/chapitre_13_injection_dependances/#le-probleme-qui-cree-les-dependances","title":"Le probl\u00e8me : qui cr\u00e9e les d\u00e9pendances ?","text":"<p>Nos handlers ont besoin de collaborateurs pour fonctionner. Le handler <code>allouer</code> a besoin d'un Unit of Work pour acc\u00e9der aux produits et persister les changements. Le handler <code>envoyer_notification_rupture_stock</code> a besoin d'un adapter de notifications pour envoyer un email. D'autres handlers pourraient avoir besoin d'un client Redis, d'un logger sp\u00e9cifique, ou de n'importe quel autre service d'infrastructure.</p> <p>La question est simple en apparence, mais fondamentale : qui cr\u00e9e ces objets, et qui les passe aux handlers ?</p> <p>Examinons nos handlers tels qu'ils sont \u00e9crits :</p> <pre><code># src/allocation/service_layer/handlers.py\n\ndef allouer(\n    cmd: commands.Allouer,\n    uow: AbstractUnitOfWork,        # &lt;-- besoin d'un UoW\n) -&gt; str:\n    ligne = model.LigneDeCommande(id_commande=cmd.id_commande, sku=cmd.sku, quantit\u00e9=cmd.quantit\u00e9)\n    with uow:\n        produit = uow.produits.get(sku=cmd.sku)\n        if produit is None:\n            raise SkuInconnu(f\"SKU inconnu : {cmd.sku}\")\n        r\u00e9f_lot = produit.allouer(ligne)\n        uow.commit()\n    return r\u00e9f_lot\n\n\ndef envoyer_notification_rupture_stock(\n    event: events.RuptureDeStock,\n    notifications: AbstractNotifications,  # &lt;-- besoin de notifications\n) -&gt; None:\n    notifications.send(\n        destination=\"stock@example.com\",\n        message=f\"Rupture de stock pour le SKU {event.sku}\",\n    )\n</code></pre> <p>Chaque handler d\u00e9clare ses d\u00e9pendances via ses param\u00e8tres. Mais il ne les cr\u00e9e pas lui-m\u00eame. C'est une d\u00e9cision d\u00e9lib\u00e9r\u00e9e : si <code>allouer</code> instanciait directement un <code>SqlAlchemyUnitOfWork</code>, on ne pourrait plus le tester avec un fake. Si <code>envoyer_notification_rupture_stock</code> cr\u00e9ait un <code>EmailNotifications</code>, impossible de v\u00e9rifier les envois sans serveur SMTP.</p> <p>On pourrait \u00eatre tent\u00e9 de r\u00e9soudre cela de mani\u00e8re ad hoc -- un import ici, un singleton l\u00e0 -- mais cela m\u00e8ne rapidement \u00e0 un r\u00e9seau de d\u00e9pendances implicites, difficile \u00e0 suivre et encore plus difficile \u00e0 tester.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#dependency-injection-di","title":"Dependency Injection (DI)","text":"<p>Le principe de la Dependency Injection est \u00e9l\u00e9gant dans sa simplicit\u00e9 :</p> <p>Dependency Injection</p> <p>Au lieu qu'un composant cr\u00e9e ses d\u00e9pendances, elles lui sont inject\u00e9es de l'ext\u00e9rieur. Le composant d\u00e9clare ce dont il a besoin (via ses param\u00e8tres), et quelqu'un d'autre fournit les instances concr\u00e8tes.</p> <p>C'est l'application directe du Dependency Inversion Principle vu au chapitre 3, mais ici on passe \u00e0 la m\u00e9canique : comment fournir les bonnes instances aux bons handlers ?</p> <p>Il y a trois approches classiques :</p> <ol> <li> <p>Injection par constructeur : les d\u00e9pendances sont pass\u00e9es \u00e0 <code>__init__</code>.    C'est le cas de notre <code>MessageBus</code>, qui re\u00e7oit le <code>uow</code> et les <code>dependencies</code>    \u00e0 sa construction.</p> </li> <li> <p>Injection par param\u00e8tre : les d\u00e9pendances sont pass\u00e9es \u00e0 chaque appel    de fonction. C'est le cas de nos handlers : <code>allouer(cmd, uow=...)</code>.</p> </li> <li> <p>Injection par framework : un conteneur DI r\u00e9sout automatiquement le    graphe de d\u00e9pendances. On en parlera en fin de chapitre.</p> </li> </ol> <p>Notre architecture combine les deux premi\u00e8res approches : le <code>MessageBus</code> re\u00e7oit ses d\u00e9pendances par constructeur, puis les redistribue aux handlers par param\u00e8tre \u00e0 chaque appel.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#la-composition-root-un-seul-point-dassemblage","title":"La Composition Root : un seul point d'assemblage","text":"<p>Dans toute application, il existe un moment o\u00f9 il faut assembler les pi\u00e8ces : cr\u00e9er les instances concr\u00e8tes et les connecter entre elles. Ce lieu s'appelle la Composition Root.</p> <p>Le principe est strict : il ne doit y avoir qu'un seul endroit dans l'application o\u00f9 les d\u00e9pendances concr\u00e8tes sont instanci\u00e9es et reli\u00e9es. Partout ailleurs, le code ne manipule que des abstractions.</p> <pre><code>   Sans Composition Root :                Avec Composition Root :\n   d\u00e9pendances cr\u00e9\u00e9es partout             d\u00e9pendances cr\u00e9\u00e9es en un seul point\n\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Handler A \u2502\u2500\u2500 new UoW()              \u2502   Bootstrap       \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2502   (Composition    \u2502\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2502    Root)          \u2502\n   \u2502 Handler B \u2502\u2500\u2500 new UoW()              \u2502                   \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2502  uow = SqlUoW()  \u2502\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2502  notif = Email()  \u2502\n   \u2502 Handler C \u2502\u2500\u2500 new Email()            \u2502  bus = MessageBus \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2502    (uow, notif)   \u2502\n                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   Probl\u00e8me : couplage direct,                      \u2502\n   impossible de remplacer                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   les impl\u00e9mentations.                     \u2502 Handlers A,B,C\u2502\n                                            \u2502 re\u00e7oivent les \u2502\n                                            \u2502 d\u00e9pendances   \u2502\n                                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Dans notre projet, la Composition Root est le module <code>bootstrap.py</code>.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#le-module-bootstrappy","title":"Le module bootstrap.py","text":"<p>Voici le coeur de l'assemblage de notre application :</p> <pre><code># src/allocation/service_layer/bootstrap.py\n\ndef bootstrap(\n    start_orm: bool = True,\n    uow: unit_of_work.AbstractUnitOfWork | None = None,\n    notifications_adapter: notifications.AbstractNotifications | None = None,\n    **extra_dependencies: Any,\n) -&gt; messagebus.MessageBus:\n    \"\"\"\n    Construit et retourne un MessageBus configur\u00e9.\n    \"\"\"\n    if start_orm:\n        orm.start_mappers()\n\n    if uow is None:\n        uow = unit_of_work.SqlAlchemyUnitOfWork()\n\n    if notifications_adapter is None:\n        notifications_adapter = notifications.EmailNotifications()\n\n    dependencies: dict[str, Any] = {\n        \"notifications\": notifications_adapter,\n        **extra_dependencies,\n    }\n\n    return messagebus.MessageBus(\n        uow=uow,\n        event_handlers=EVENT_HANDLERS,\n        command_handlers=COMMAND_HANDLERS,\n        dependencies=dependencies,\n    )\n</code></pre> <p>D\u00e9composons ce que fait cette fonction :</p> <ol> <li> <p>Initialisation de l'ORM : si <code>start_orm</code> est vrai, on d\u00e9marre le mapping    SQLAlchemy. En production, c'est n\u00e9cessaire. En tests unitaires, on passe    <code>start_orm=False</code> car on n'a pas besoin de base de donn\u00e9es.</p> </li> <li> <p>Cr\u00e9ation du UoW : si aucun <code>uow</code> n'est fourni, on cr\u00e9e le concret    <code>SqlAlchemyUnitOfWork</code>. Si un fake est pass\u00e9, on l'utilise tel quel.</p> </li> <li> <p>Cr\u00e9ation des notifications : m\u00eame logique. Par d\u00e9faut, on cr\u00e9e    <code>EmailNotifications</code>. En test, on passe un <code>FakeNotifications</code>.</p> </li> <li> <p>Assemblage du dictionnaire de d\u00e9pendances : toutes les d\u00e9pendances    suppl\u00e9mentaires (notifications, et potentiellement d'autres) sont regroup\u00e9es    dans un dictionnaire.</p> </li> <li> <p>Construction du MessageBus : le bus re\u00e7oit le UoW, les mappings    handlers/messages, et le dictionnaire de d\u00e9pendances.</p> </li> </ol> <p>Le second \u00e9l\u00e9ment cl\u00e9 est la configuration des handlers, d\u00e9finie dans le m\u00eame module :</p> <pre><code># src/allocation/service_layer/bootstrap.py\n\nEVENT_HANDLERS: dict[type[events.Event], list] = {\n    events.Allou\u00e9: [handlers.publier_\u00e9v\u00e9nement_allocation],\n    events.D\u00e9sallou\u00e9: [handlers.r\u00e9allouer],\n    events.RuptureDeStock: [handlers.envoyer_notification_rupture_stock],\n}\n\nCOMMAND_HANDLERS: dict[type[commands.Command], Any] = {\n    commands.Cr\u00e9erLot: handlers.ajouter_lot,\n    commands.Allouer: handlers.allouer,\n    commands.ModifierQuantit\u00e9Lot: handlers.modifier_quantit\u00e9_lot,\n}\n</code></pre> <p>Ces dictionnaires constituent le routing de l'application : quel handler traite quel message. Ils sont d\u00e9clar\u00e9s de mani\u00e8re statique et centralis\u00e9e, ce qui rend le flux de l'application lisible d'un seul coup d'oeil.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#utilisation-en-production","title":"Utilisation en production","text":"<p>Dans le point d'entr\u00e9e Flask, le bootstrap est appel\u00e9 une seule fois au d\u00e9marrage de l'application :</p> <pre><code># src/allocation/entrypoints/flask_app.py\n\nfrom allocation.service_layer import bootstrap\n\napp = Flask(__name__)\nbus = bootstrap.bootstrap()  # Composition Root -- tout est assembl\u00e9 ici\n</code></pre> <p>\u00c0 partir de l\u00e0, <code>bus</code> est le seul objet dont l'application a besoin. Chaque endpoint se contente de cr\u00e9er une command et de la confier au bus :</p> <pre><code>@app.route(\"/allocate\", methods=[\"POST\"])\ndef allocate_endpoint():\n    data = request.json\n    cmd = commands.Allouer(\n        id_commande=data[\"id_commande\"], sku=data[\"sku\"], quantit\u00e9=data[\"quantit\u00e9\"],\n    )\n    results = bus.handle(cmd)\n    r\u00e9f_lot = results.pop(0)\n    return jsonify({\"r\u00e9f_lot\": r\u00e9f_lot}), 201\n</code></pre> <p>L'endpoint ne sait pas quel UoW est utilis\u00e9, ni comment les notifications sont envoy\u00e9es. Il n'a pas besoin de le savoir. Toute cette m\u00e9canique est cach\u00e9e derri\u00e8re le <code>MessageBus</code>, assembl\u00e9 par le bootstrap.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#linjection-par-introspection","title":"L'injection par introspection","text":"<p>Le m\u00e9canisme le plus subtil de notre architecture se trouve dans la m\u00e9thode <code>_call_handler</code> du <code>MessageBus</code>. C'est elle qui r\u00e9alise l'injection de d\u00e9pendances \u00e0 chaque appel de handler.</p> <pre><code># src/allocation/service_layer/messagebus.py\n\ndef _call_handler(self, handler: Callable, message: Message) -&gt; Any:\n    \"\"\"\n    Appelle un handler en injectant les d\u00e9pendances n\u00e9cessaires.\n\n    Introspection des param\u00e8tres du handler pour d\u00e9terminer\n    quelles d\u00e9pendances injecter.\n    \"\"\"\n    import inspect\n\n    params = inspect.signature(handler).parameters\n    kwargs: dict[str, Any] = {}\n    for name, param in params.items():\n        if name == list(params.keys())[0]:\n            # Premier param\u00e8tre = le message lui-m\u00eame\n            continue\n        if name == \"uow\":\n            kwargs[name] = self.uow\n        elif name in self.dependencies:\n            kwargs[name] = self.dependencies[name]\n\n    return handler(message, **kwargs)\n</code></pre> <p>Voici ce qui se passe, \u00e9tape par \u00e9tape :</p> <ol> <li> <p>Introspection : <code>inspect.signature(handler).parameters</code> examine la    signature du handler pour conna\u00eetre les noms de ses param\u00e8tres.</p> </li> <li> <p>Le premier param\u00e8tre est saut\u00e9 : c'est toujours le message lui-m\u00eame    (la command ou l'event). Il sera pass\u00e9 comme argument positionnel.</p> </li> <li> <p>R\u00e9solution des d\u00e9pendances : pour chaque param\u00e8tre restant, le bus    cherche une correspondance par nom :</p> <ul> <li>Si le param\u00e8tre s'appelle <code>uow</code>, il re\u00e7oit le <code>self.uow</code>.</li> <li>Sinon, le bus cherche dans le dictionnaire <code>self.dependencies</code>.</li> </ul> </li> <li> <p>Appel du handler : le message est pass\u00e9 en premier argument positionnel,    les d\u00e9pendances en keyword arguments.</p> </li> </ol>"},{"location":"partie2/chapitre_13_injection_dependances/#exemple-concret","title":"Exemple concret","text":"<p>Prenons le handler <code>envoyer_notification_rupture_stock</code> :</p> <pre><code>def envoyer_notification_rupture_stock(\n    event: events.RuptureDeStock,\n    notifications: AbstractNotifications,\n) -&gt; None:\n    ...\n</code></pre> <p>Quand le bus doit appeler ce handler :</p> <ul> <li><code>inspect.signature</code> d\u00e9tecte deux param\u00e8tres : <code>event</code> et <code>notifications</code>.</li> <li><code>event</code> est le premier param\u00e8tre, il est saut\u00e9.</li> <li><code>notifications</code> est cherch\u00e9 dans <code>self.dependencies</code> -- et trouv\u00e9, car   le bootstrap a rempli <code>dependencies = {\"notifications\": notifications_adapter}</code>.</li> <li>Le bus appelle : <code>handler(event, notifications=email_adapter)</code>.</li> </ul> <p>Pour le handler <code>allouer</code> :</p> <pre><code>def allouer(\n    cmd: commands.Allouer,\n    uow: AbstractUnitOfWork,\n) -&gt; str:\n    ...\n</code></pre> <ul> <li><code>cmd</code> est le premier param\u00e8tre, saut\u00e9.</li> <li><code>uow</code> est d\u00e9tect\u00e9 par son nom et re\u00e7oit <code>self.uow</code>.</li> <li>Le bus appelle : <code>handler(cmd, uow=sqlalchemy_uow)</code>.</li> </ul> <p>Convention over configuration</p> <p>L'injection fonctionne par convention de nommage : un param\u00e8tre nomm\u00e9 <code>uow</code> re\u00e7oit le Unit of Work, un param\u00e8tre nomm\u00e9 <code>notifications</code> re\u00e7oit l'adapter de notifications. C'est simple, lisible, et ne n\u00e9cessite aucun d\u00e9corateur ni annotation sp\u00e9ciale.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#di-pour-les-tests","title":"DI pour les tests","text":"<p>L'un des b\u00e9n\u00e9fices majeurs de la Dependency Injection est de pouvoir remplacer les impl\u00e9mentations concr\u00e8tes par des fakes dans les tests. Le m\u00eame code de handler est ex\u00e9cut\u00e9, mais avec des d\u00e9pendances diff\u00e9rentes.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#le-bootstrap-de-test","title":"Le bootstrap de test","text":"<p>Voici comment les tests unitaires assemblent le bus :</p> <pre><code># tests/unit/test_handlers.py\n\nclass FakeUnitOfWork(unit_of_work.AbstractUnitOfWork):\n    \"\"\"Fake Unit of Work utilisant le FakeRepository.\"\"\"\n\n    def __init__(self):\n        self.produits = FakeRepository([])\n        self.committed = False\n\n    def __enter__(self):\n        return super().__enter__()\n\n    def __exit__(self, *args):\n        pass\n\n    def _commit(self):\n        self.committed = True\n\n    def rollback(self):\n        pass\n\n\nclass FakeNotifications(AbstractNotifications):\n    \"\"\"Fake pour capturer les notifications envoy\u00e9es.\"\"\"\n\n    def __init__(self):\n        self.envoy\u00e9es: list[tuple[str, str]] = []\n\n    def send(self, destination: str, message: str) -&gt; None:\n        self.envoy\u00e9es.append((destination, message))\n\n\ndef bootstrap_test_bus(uow: FakeUnitOfWork | None = None) -&gt; messagebus.MessageBus:\n    \"\"\"Cr\u00e9e un message bus configur\u00e9 pour les tests.\"\"\"\n    from allocation.service_layer.bootstrap import EVENT_HANDLERS, COMMAND_HANDLERS\n\n    uow = uow or FakeUnitOfWork()\n    notifications = FakeNotifications()\n    return messagebus.MessageBus(\n        uow=uow,\n        event_handlers=EVENT_HANDLERS,\n        command_handlers=COMMAND_HANDLERS,\n        dependencies={\"notifications\": notifications},\n    )\n</code></pre> <p>Observez les points cl\u00e9s :</p> <ul> <li> <p><code>FakeUnitOfWork</code> remplace <code>SqlAlchemyUnitOfWork</code>. Les produits sont   stock\u00e9s en m\u00e9moire dans un <code>FakeRepository</code>. Le <code>_commit</code> se contente de   passer un flag \u00e0 <code>True</code>, ce qui permet de v\u00e9rifier que le commit a eu lieu.</p> </li> <li> <p><code>FakeNotifications</code> remplace <code>EmailNotifications</code>. Au lieu d'envoyer un   email, chaque appel \u00e0 <code>send</code> est enregistr\u00e9 dans une liste <code>self.envoy\u00e9es</code>.   Les tests peuvent ensuite inspecter cette liste.</p> </li> <li> <p><code>bootstrap_test_bus</code> joue le r\u00f4le de Composition Root pour les tests.   Elle r\u00e9utilise les m\u00eames <code>EVENT_HANDLERS</code> et <code>COMMAND_HANDLERS</code> que la   production (les handlers sont identiques), mais injecte des fakes.</p> </li> </ul>"},{"location":"partie2/chapitre_13_injection_dependances/#les-tests-en-action","title":"Les tests en action","text":"<p>Gr\u00e2ce \u00e0 cette architecture, les tests sont simples et expressifs :</p> <pre><code>class TestAllouer:\n    def test_allouer_retourne_r\u00e9f_lot(self):\n        bus = bootstrap_test_bus()\n        bus.handle(commands.Cr\u00e9erLot(\"b1\", \"CHAISE-COMFY\", 100, None))\n        results = bus.handle(commands.Allouer(\"o1\", \"CHAISE-COMFY\", 10))\n\n        assert results.pop(0) == \"b1\"\n</code></pre> <p>Ce test traverse toute la pile applicative -- du <code>MessageBus</code> au handler, du handler au domaine, du domaine au repository -- mais sans aucune infrastructure r\u00e9elle. Il s'ex\u00e9cute en quelques millisecondes.</p> <p>La cl\u00e9 : le handler <code>allouer</code> ne sait pas qu'il travaille avec un fake. Il re\u00e7oit un objet qui respecte le contrat <code>AbstractUnitOfWork</code>, et c'est tout ce qui compte. C'est le polymorphisme au service de la testabilit\u00e9.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#le-parallele-production-tests","title":"Le parall\u00e8le production / tests","text":"<pre><code>   Production :                         Tests :\n\n   bootstrap()                          bootstrap_test_bus()\n     \u2502                                    \u2502\n     \u251c\u2500\u2500 SqlAlchemyUnitOfWork             \u251c\u2500\u2500 FakeUnitOfWork\n     \u251c\u2500\u2500 EmailNotifications               \u251c\u2500\u2500 FakeNotifications\n     \u2514\u2500\u2500 MessageBus                       \u2514\u2500\u2500 MessageBus\n           \u2502                                    \u2502\n           \u251c\u2500\u2500 handlers.allouer                 \u251c\u2500\u2500 handlers.allouer\n           \u251c\u2500\u2500 handlers.ajouter_lot             \u251c\u2500\u2500 handlers.ajouter_lot\n           \u2514\u2500\u2500 handlers.envoyer_notif...        \u2514\u2500\u2500 handlers.envoyer_notif...\n\n   M\u00eames handlers, d\u00e9pendances diff\u00e9rentes.\n</code></pre>"},{"location":"partie2/chapitre_13_injection_dependances/#framework-di-vs-di-manuelle","title":"Framework DI vs DI manuelle","text":"<p>En Java ou C#, la Dependency Injection passe presque toujours par un framework : Spring, Guice, Autofac. Ces frameworks maintiennent un conteneur qui conna\u00eet toutes les classes de l'application, r\u00e9sout automatiquement le graphe de d\u00e9pendances, et g\u00e8re les cycles de vie (singleton, scoped, transient).</p> <p>En Python, la situation est diff\u00e9rente. Le langage est suffisamment dynamique pour que la DI manuelle soit souvent la meilleure option.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#pourquoi-la-di-manuelle-suffit-en-python","title":"Pourquoi la DI manuelle suffit en Python","text":"<p>Notre <code>bootstrap.py</code> fait une trentaine de lignes. Il est lisible, explicite, et facile \u00e0 d\u00e9bugger. Quand quelque chose ne va pas, on sait exactement o\u00f9 regarder : c'est dans le bootstrap.</p> <p>Comparez avec un framework DI hypoth\u00e9tique :</p> <pre><code># Avec un framework DI (hypoth\u00e9tique)\ncontainer = Container()\ncontainer.register(AbstractUnitOfWork, SqlAlchemyUnitOfWork, scope=\"singleton\")\ncontainer.register(AbstractNotifications, EmailNotifications, scope=\"transient\")\ncontainer.register(MessageBus)\ncontainer.auto_wire()\n\nbus = container.resolve(MessageBus)\n</code></pre> <p>C'est plus concis, mais aussi plus magique. Le <code>auto_wire()</code> cache la m\u00e9canique de r\u00e9solution. Quand \u00e7a ne fonctionne pas, le message d'erreur peut \u00eatre cryptique. Et pour un projet de taille raisonnable, le gain par rapport au bootstrap manuel est n\u00e9gligeable.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#quand-envisager-un-framework","title":"Quand envisager un framework","text":"<p>Un framework DI devient int\u00e9ressant quand :</p> <ul> <li>Le nombre de d\u00e9pendances d\u00e9passe la vingtaine et le bootstrap manuel   devient p\u00e9nible \u00e0 maintenir.</li> <li>Vous avez besoin de scopes complexes (par requ\u00eate HTTP, par session,   par thread).</li> <li>Plusieurs \u00e9quipes travaillent sur le m\u00eame projet et ont besoin d'un   m\u00e9canisme standardis\u00e9 pour enregistrer des composants.</li> </ul> <p>Si vous atteignez ce stade, la biblioth\u00e8que dependency-injector est le choix le plus mature en Python. Elle offre des conteneurs, du wiring automatique, et une bonne int\u00e9gration avec les frameworks web.</p> <p>Ne commencez pas par un framework DI</p> <p>La DI manuelle via un bootstrap est suffisante pour la grande majorit\u00e9 des projets Python. N'ajoutez un framework que quand la douleur du bootstrap manuel devient r\u00e9elle, pas par anticipation.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#resume","title":"R\u00e9sum\u00e9","text":"<p>L'injection de d\u00e9pendances et le bootstrap r\u00e9solvent un probl\u00e8me fondamental de toute architecture propre : comment assembler les composants sans cr\u00e9er de couplage entre eux.</p> Concept R\u00f4le Dans notre code Dependency Injection Fournir les d\u00e9pendances de l'ext\u00e9rieur au lieu de les cr\u00e9er en interne Les handlers d\u00e9clarent <code>uow</code>, <code>notifications</code> comme param\u00e8tres Composition Root Un seul point o\u00f9 les d\u00e9pendances concr\u00e8tes sont assembl\u00e9es <code>bootstrap.py</code> Bootstrap Fonction qui cr\u00e9e toutes les d\u00e9pendances et construit le bus <code>bootstrap()</code> Introspection D\u00e9couvrir automatiquement les d\u00e9pendances requises par un handler <code>inspect.signature</code> dans <code>_call_handler</code> Fakes pour les tests Impl\u00e9mentations l\u00e9g\u00e8res pour tester sans infrastructure <code>FakeUnitOfWork</code>, <code>FakeNotifications</code>"},{"location":"partie2/chapitre_13_injection_dependances/#architecture-finale","title":"Architecture finale","text":"<p>Voici le sch\u00e9ma complet de l'architecture, avec le bootstrap au sommet :</p> <pre><code>   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                        BOOTSTRAP                            \u2502\n   \u2502                   (Composition Root)                        \u2502\n   \u2502                                                              \u2502\n   \u2502  Cr\u00e9e :  UoW, Notifications, MessageBus                     \u2502\n   \u2502  Configure : routing commands/events -&gt; handlers             \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u2502 construit\n                              v\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                       MESSAGE BUS                            \u2502\n   \u2502                                                              \u2502\n   \u2502  - Re\u00e7oit les commands et events                             \u2502\n   \u2502  - Dispatch vers les handlers                                \u2502\n   \u2502  - Injecte les d\u00e9pendances par introspection                 \u2502\n   \u2502  - Collecte et traite les events en cascade                  \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                                  \u2502\n          v                                  v\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502  Command      \u2502                   \u2502  Event        \u2502\n   \u2502  Handlers     \u2502                   \u2502  Handlers     \u2502\n   \u2502               \u2502                   \u2502               \u2502\n   \u2502  allouer      \u2502                   \u2502  r\u00e9allouer    \u2502\n   \u2502  ajouter_lot  \u2502                   \u2502  envoyer_notif\u2502\n   \u2502  modifier_qt\u00e9 \u2502                   \u2502  publier      \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                                  \u2502\n          \u2502 utilisent                        \u2502 utilisent\n          v                                  v\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                      ABSTRACTIONS                            \u2502\n   \u2502                                                              \u2502\n   \u2502  AbstractUnitOfWork          AbstractNotifications            \u2502\n   \u2502       \u2502                            \u2502                         \u2502\n   \u2502       \u251c\u2500\u2500 SqlAlchemyUoW            \u251c\u2500\u2500 EmailNotifications    \u2502\n   \u2502       \u2514\u2500\u2500 FakeUoW (tests)          \u2514\u2500\u2500 FakeNotifications     \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                                  \u2502\n          v                                  v\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502  PostgreSQL   \u2502                   \u2502  Serveur     \u2502\n   \u2502  (production) \u2502                   \u2502  SMTP        \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Le flux est toujours descendant : le bootstrap cr\u00e9e le bus, le bus dispatch aux handlers, les handlers utilisent les abstractions, et les abstractions cachent l'infrastructure. Nulle part un composant ne remonte pour cr\u00e9er ou chercher ses propres d\u00e9pendances.</p>"},{"location":"partie2/chapitre_13_injection_dependances/#exercices","title":"Exercices","text":"<p>Exercice 1 -- Nouvelle d\u00e9pendance</p> <p>Ajoutez un <code>AbstractLogger</code> injectable dans les handlers. Modifiez le bootstrap pour injecter un <code>FakeLogger</code> en test et un vrai <code>logging.Logger</code> en production. V\u00e9rifiez que l'introspection de <code>_call_handler</code> le r\u00e9sout correctement.</p> <p>Exercice 2 -- Tester l'injection</p> <p>\u00c9crivez un test qui v\u00e9rifie que si un handler d\u00e9clare un param\u00e8tre <code>inconnu</code> qui n'est pas dans les d\u00e9pendances, le bus le g\u00e8re proprement (que se passe-t-il actuellement ?).</p> <p>Exercice 3 -- Container DI</p> <p>Installez <code>dependency-injector</code> et r\u00e9\u00e9crivez le bootstrap en utilisant un container. Comparez le nombre de lignes, la lisibilit\u00e9 et la facilit\u00e9 de debug avec le bootstrap manuel.</p> <p>\u00c0 retenir</p> <ul> <li>Un handler ne cr\u00e9e jamais ses d\u00e9pendances. Il les re\u00e7oit.</li> <li>Le bootstrap est le seul endroit o\u00f9 les impl\u00e9mentations concr\u00e8tes   sont instanci\u00e9es.</li> <li>L'introspection (<code>inspect.signature</code>) permet au bus d'injecter   automatiquement les bonnes d\u00e9pendances dans chaque handler.</li> <li>En tests, on remplace les impl\u00e9mentations concr\u00e8tes par des fakes   via le m\u00eame m\u00e9canisme de bootstrap.</li> <li>La DI manuelle via un bootstrap explicite est souvent pr\u00e9f\u00e9r\u00e9e en   Python \u00e0 un framework DI. N'ajoutez de la complexit\u00e9 que quand elle   est justifi\u00e9e.</li> </ul>"}]}